#!/usr/bin/env python
# -*- mode: landisk-python; coding: utf-8; -*-
# vim:ts=4 sw=4 sts=4 ai si et sta
from __future__ import with_statement

import traceback
import sys
import os
import httplib
from httplib import HTTPSConnection
import socket
import urllib
import urlparse
import re
import datetime
import time
try:
    import json
except ImportError:
    import simplejson as json

import timezone

    
_empty = object()

##############################################################################
class BaseResource(object):

    def __init__(self, client, resource_info):
        raise NotImplementedError

    def __getattr__(self, name):
        value = None
        if name == 'metadata':
            value = self.get_metadata()
        else:
            metadata = self.metadata
            if name in metadata:
                value = metadata[name]
            else:
                raise AttributeError(name)
        setattr(self, name, value)
        return value

    def get_metadata(self):
        raise NotImplementedError

    def get_files(self):
        raise NotImplementedError


class BaseClient(object):
    pass
##############################################################################


def _iso8601_to_rfc2822(iso8601):
    """
    ISO 8601: '2017-04-01T09:15:00Z'
    RFC 2822: 'Sat, 01 Apr 2017 00:15:00 +0000'
    """
    # FIXME: only UTC
    import calendar
    try:
        import email.utils as emailut
    except:
        import email.Utils as emailut
    p = r'(?P<year>[0-9]{4})-(?P<month>[0-9]{2})-(?P<day>[0-9]{2})T(?P<hour>[0-9]{2}):(?P<minute>[0-9]{2}):(?P<second>[0-9]{2})Z'
    m = re.match(p, iso8601)
    if m:
        year = int(m.group('year'))
        month = int(m.group('month'))
        day = int(m.group('day'))
        hour = int(m.group('hour'))
        minute = int(m.group('minute'))
        second = int(m.group('second'))
        dt = datetime.datetime(year,
                               month,
                               day,
                               hour,
                               minute,
                               second,
                               tzinfo=timezone.utc)
        # NOTE: mktime is localtime only
        # epoch = int(time.mktime(dt.timetuple()))
        epoch = calendar.timegm(dt.timetuple())
        rfc2822 = emailut.formatdate(epoch, localtime=False)
        rfc2822 = rfc2822.replace('-0000', '+0000')
        return rfc2822
    raise None


class BaseDropboxError(Exception):
    pass


class UnknownDropboxError(BaseDropboxError):
    pass


class BadInputParameterDropboxError(BaseDropboxError):
    # 400
    pass


class InvalidAccessTokenDropboxError(BaseDropboxError):
    # 401
    pass


class TooManyRequestsDropboxError(BaseDropboxError):
    # 429

    def __init__(self, retry_after, *args, **kwargs):
        self.retry_after = retry_after
        super(TooManyRequestsDropboxError, self).__init__(*args, **kwargs)


class ServerDropboxError(BaseDropboxError):
    # 5xx
    pass


class EndpointSpecificDropboxError(BaseDropboxError):
    # 409
    pass


class NotFoundDropboxError(EndpointSpecificDropboxError):
    pass


class ConflictDropboxError(EndpointSpecificDropboxError):
    pass


class MalformedPathDropboxError(EndpointSpecificDropboxError):
    pass


class DisallowedNameDropboxError(EndpointSpecificDropboxError):
    pass


class InvalidOauth1TokenInfoDropboxError(EndpointSpecificDropboxError):
    pass


class AppIdMismatchDropboxError(EndpointSpecificDropboxError):
    pass


class InsufficientSpaceDropboxError(EndpointSpecificDropboxError):
    pass


# class RequestTimedOutDropboxError(BaseDropboxError):
#     pass


# class ConnectionResetByPeerDropboxError(BaseDropboxError):
#     pass


class InvalidResponseDropboxError(BaseDropboxError):
    pass


class IncompleteReadDropboxError(BaseDropboxError):
    pass


class _DropboxResource(BaseResource):

    def __init__(self, client, path=None, raw_metadata=None):
        self._client = client

        if path is None:
            self.path = raw_metadata['path_display']
        else:
            self.path = path

        if raw_metadata:
            setattr(self, 'metadata', self._to_resource_metadata(raw_metadata))

    def get_metadata(self):
        try:
            raw_metadata = self._client.get_metadata(self.path)
            return self._to_resource_metadata(raw_metadata)
        except NotFoundDropboxError:
            return {
                'is_deleted': True,
            }

    def _to_resource_metadata(self, raw_metadata):
        _metadata = {}
        _metadata['is_deleted'] = raw_metadata['.tag'] == 'deleted'
        _metadata['is_folder'] = raw_metadata['.tag'] == 'folder'
        _metadata['is_file'] = raw_metadata['.tag'] == 'file'
        _metadata['name'] = raw_metadata.get('name', None)
        if _metadata['is_file']:
            modified = raw_metadata['server_modified']
            _metadata['modified'] = self._iso8601_to_datetime(modified)
            _metadata['_modified_rfc2822'] = _iso8601_to_rfc2822(modified)  # FIXME: for nasdsync
            _metadata['size'] = int(raw_metadata['size'])

        _metadata['_raw_data'] = raw_metadata
        return _metadata

    def _iso8601_to_datetime(self, iso8601):
        """
        format: '%Y-%m-%dT%H:%M:%SZ' (ISO 8601)
        """
        pattern = r'(?P<year>[0-9]{4})-(?P<month>[0-9]{2})-(?P<day>[0-9]{2})T(?P<hour>[0-9]{2}):(?P<minute>[0-9]{2}):(?P<second>[0-9]{2})Z'
        m = re.match(pattern, iso8601)
        if m:
            year = int(m.group('year'))
            month = int(m.group('month'))
            day = int(m.group('day'))
            hour = int(m.group('hour'))
            minute = int(m.group('minute'))
            second = int(m.group('second'))
            return datetime.datetime(year,
                                     month,
                                     day,
                                     hour,
                                     minute,
                                     second,
                                     tzinfo=timezone.utc)
        else:
            return None

    def _dumps_metadata(self, indent=4):
        md = self.metadata.copy()
        jd = self.__metadata_to_jsondata(md)
        return json.dumps(jd, indent=indent)

    def __metadata_to_jsondata(self, md):
        jd = {}
        for k, v in md.iteritems():
            if isinstance(v, dict):
                jd[k] = self.__metadata_to_jsondata(v)
            elif isinstance(v, bool) or isinstance(v, basestring) or isinstance(v, (int, long, float)):
                jd[k] = v
            else:
                jd[k] = u'%s' % v
        return jd


class DropboxClient(BaseClient):

    _endpoint = {
        'api': 'api.dropboxapi.com',
        'content': 'content.dropboxapi.com',
        'notify': 'notify.dropboxapi.com',

        'only_get_authorize_url': 'www.dropbox.com',
    }

    _max_upload_size = 150 * 1000 * 1000 - 1  # 150MB - 1

    ##########################################################################
    # Special methods

    def __init__(self, client_id, client_secret):
        self._client_id = client_id
        self._client_secret = client_secret

    ##########################################################################
    # Properties

    _access_token = None
    def _set_access_token(self, access_token):
        self._access_token = access_token
    def _get_access_token(self):
        if self._access_token is None:
            pass  # FIXME: self._access_token = xxx
        return self._access_token
    access_token = property(_get_access_token, _set_access_token)

    _get_proxy = None
    def _set_get_proxy(self, get_proxy):
        self._get_proxy = get_proxy
    def _get_get_proxy(self):
        if self._get_proxy is None:
            self._get_proxy = lambda url: None
        return self._get_proxy
    get_proxy = property(_get_get_proxy, _set_get_proxy)

    ##########################################################################
    # Public methods

    def get_authorize_url(self):
        return self._call_oauth2_authorize()

    def obtain_access_token(self, code):
        response = self._call_oauth2_token(code)
        access_token = response.get('access_token')
        return access_token

    # def transition_oauth1_token_to_oauth2_token(self,
    def obtain_oauth2_token_from_oauth1_token(self,
                                              oauth1_token,
                                              oauth1_token_secret):
        response = self._call_auth_token_from_oauth1(oauth1_token,
                                                     oauth1_token_secret)
        access_token = response.get('oauth2_token')
        return access_token

    def revoke_access_token(self):
        self._call_auth_token_revoke()

    def get(self, path):
        return _DropboxResource(self, path=path)

    def get_metadata(self, path):
        response = self._call_files_get_metadata(path, include_deleted=True)
        metadata = response
        return metadata

    def create_folder(self, path):
        response = self._call_files_create_folder(path)
        metadata = response
        return metadata

    def remove_file(self, path):
        response = self._call_files_delete(path)
        return response

    def get_files(self, path, default=_empty):
        try:
            response = self._call_files_list_folder(path)
            entries = response.get('entries', [])
            cursor = response.get('cursor')
            while len(entries):
                for entry in entries:
                    try:
                        yield _DropboxResource(self, raw_metadata=entry)
                    except:
                        continue
                response = self._call_files_list_folder_continue(cursor)
                entries = response.get('entries', [])
                cursor = response.get('cursor')
        except BaseDropboxError:
            if default is not _empty:
                _files = default
                for _file in _files:
                    yield _file
            else:
                raise

    def get_file(self, path):
        response = self._call_files_download(path)
        filedata = response
        return filedata

    def download_file(self, path, filename):
        filedata = self.get_file(path)
        with open(filename, 'w') as f:
            f.write(filedata.read())

    def put_file(self,
                 path,
                 _file,
                 overwrite=False,
                 return_resource_object=False):
        bufsize = self._max_upload_size

        file_metadata = None
        offset = 0
        b1 = _file.read(bufsize)
        b2 = _file.read(bufsize)
        if b2 == '':
            mode = 'overwrite' if overwrite else 'add'
            response = self._call_files_upload(b1, path, mode=mode)
            file_metadata = response
        else:
            response = self._call_files_upload_session_start(b1)
            session_id = response.get('session_id')
            if session_id is None:
                raise InvalidResponseDropboxError('session_id is not exists.')
            while True:
                offset += len(b1)
                b1 = b2
                b2 = _file.read(bufsize)
                if b2 == '':
                    mode = 'overwrite' if overwrite else 'add'
                    response = self._call_files_upload_session_finish(session_id,
                                                                      offset,
                                                                      b1,
                                                                      path,
                                                                      mode=mode)
                    file_metadata = response
                    break
                else:
                    self._call_files_upload_session_append_v2(session_id,
                                                              offset,
                                                              b1)
        if file_metadata:
            if return_resource_object:
                raw_metadata = file_metadata
                raw_metadata['.tag'] = 'file'
                return _DropboxResource(self, raw_metadata=raw_metadata)
            else:
                return file_metadata
        else:
            raise UnknownDropboxError('file_metadata(response) is empty')

    def upload_file(self, filename, path):
        with open(filename, 'rb') as f:
            return self.put_file(path, f, overwrite=True)

    def obtain_account_info(self):
        response = self._call_users_get_current_account()
        return response

    ##########################################################################
    # Private methods

    def _call(self,
              endpoint,
              api,
              body=None,
              headers=None,
              errors=None,
              return_raw_response=False,
              method='POST',
              timeout=None):
        try:
            headers = headers or {}
            body = body or ''

            conn = HTTPSConnection(endpoint, port=443)
            try:
                proxy = self.get_proxy('https://%s%s' % (endpoint, api))
                if proxy:
                    proxy = proxy.split(':')
                    host = proxy[0]
                    port = int(proxy[1]) if len(proxy) > 1 else None
                    conn = HTTPSConnection(host, port=port)
                    # conn.set_tunnel(endpoint, 443)
                    _set_tunnel = getattr(conn, 'set_tunnel', None)
                    if _set_tunnel is None:
                        _set_tunnel = getattr(conn, '_set_tunnel')
                    _set_tunnel(endpoint, 443)
            except:
                pass

            url = self._get_url(endpoint, api)
            conn.request(method, url, body, headers)
            raw_response = conn.getresponse()

            # def _wrap_read(read):
            #     def _read(*args):
            #         try:
            #             return read(*args)
            #         except httplib.IncompleteRead, e:
            #             return e.partial
            #     return _read
            # raw_response.read = _wrap_read(raw_response.read)

            status = raw_response.status
            if status == 200:
                if return_raw_response:
                    return raw_response
                else:
                    response = json.load(raw_response)
                    return response
            elif status == 400:
                raise BadInputParameterDropboxError(raw_response.read())
            elif status == 401:
                raise InvalidAccessTokenDropboxError(self.access_token)
            elif status == 409:
                response = {}
                try:
                    response = json.load(raw_response)
                except:
                    error_message = '\n  status = %s\n  body = %s' % (
                        status,
                        raw_response.read(),
                    )
                    raise UnknownDropboxError(error_message)
                error_summary = response.get('error_summary', '')
                error_summary = error_summary.strip('/.')
                error_class = errors.get(error_summary, UnknownDropboxError)
                error_message = '\n  url = %s\n  status = %s\n  body = %s' % (
                    url,
                    status,
                    json.dumps(response, indent=4),
                )
                raise error_class(error_message)
            elif status == 429:
                retry_after = 3
                try:
                    retry_after = int(raw_response.getheader('Retry-After'))
                except:
                    pass
                raise TooManyRequestsDropboxError(retry_after)
            elif 500 <= status <= 599:
                error_message = '\n  url = %s\n  status = %s\n  body = %s' % (
                    url,
                    status,
                    raw_response.read(),
                )
                raise ServerDropboxError(error_message)
            else:
                error_message = '\n  url = %s\n  status = %s\n  body = %s' % (
                    url,
                    status,
                    raw_response.read(),
                )
                raise UnknownDropboxError(error_message)

        except BaseDropboxError:
            raise

        except httplib.IncompleteRead, e:
            traceback_data = traceback.format_exc()
            raise IncompleteReadDropboxError(traceback_data)

        except (socket.error, socket.sslerror), e:
            raise  # FIXME: for nasdsync

        except:
            traceback_data = traceback.format_exc()
            raise UnknownDropboxError(traceback_data)

    def _call_oauth2_authorize(self,
                               response_type='code',
                               # client_id=_empty,
                               redirect_uri=None,
                               state=None,
                               # FIXME: require_role=?,
                               # FIXME: force_reapprove=?,
                               # FIXME: disable_signup=?,
                               # FIXME: force_reauthentication=?,
                               locale=None):
        endpoint = self._endpoint['only_get_authorize_url']
        api = '/oauth2/authorize'
        parameters = {
            'response_type': response_type,
            'client_id': self._client_id,
        }
        if redirect_uri is not None:
            parameters['redirect_uri'] = redirect_uri
        if state is not None:
            parameters['state'] = state
        if locale is not None:
            parameters['locale'] = locale
        # return 'https://%s%s?%s' % (endpoint, api, self._to_query_string(parameters))
        return self._get_url(endpoint, api, parameters=parameters)

    def _call_oauth2_token(self,
                           code,
                           grant_type='authorization_code',
                           # client_id=_empty,
                           # client_secret=_empty,
                           redirect_uri=None,
                           timeout=None):
        endpoint = self._endpoint['api']
        api = '/oauth2/token'
        headers = {
            'Content-type': 'application/x-www-form-urlencoded',
        }
        body = self._to_query_string({
            'grant_type': grant_type,
            'code': code,
            'client_id': self._client_id,
            'client_secret': self._client_secret,
        })
        errors = {}
        return self._call(endpoint, api, body, headers, errors, timeout=timeout)

    def _call_auth_token_from_oauth1(self,
                                     oauth1_token,
                                     oauth1_token_secret,
                                     timeout=None):
        endpoint = self._endpoint['api']
        api = '/2/auth/token/from_oauth1'
        headers = {
            'Authorization': 'Basic %s' % ('%s:%s' % (self._client_id, self._client_secret)).encode('base64').strip(),
            'Content-type': 'application/json',
        }
        body = json.dumps({
            'oauth1_token': oauth1_token,
            'oauth1_token_secret': oauth1_token_secret,
        })
        errors = {
            'invalid_oauth1_token_info': InvalidOauth1TokenInfoDropboxError,
            'app_id_mismatch': AppIdMismatchDropboxError,
            'other': UnknownDropboxError,
        }
        response = self._call(endpoint, api, body, headers, errors, timeout=timeout)
        return response

    def _call_auth_token_revoke(self, timeout=None):
        endpoint = self._endpoint['api']
        api = '/2/auth/token/revoke'
        headers = {
            'Authorization': 'Bearer %s' % self.access_token,
        }
        body = json.dumps({
            # "No parameters."
        })
        errors = {
            # "No errors."
        }
        response = self._call(endpoint, api, body, headers, errors, timeout=timeout)
        # "No return values."
        return response

    def _call_files_get_metadata(self,
                                 path,
                                 include_media_info=False,
                                 include_deleted=False,
                                 include_has_explicit_shared_members=False,
                                 timeout=None):
        endpoint = self._endpoint['api']
        api = '/2/files/get_metadata'
        headers = {
            'Authorization': 'Bearer %s' % self.access_token,
            'Content-type': 'application/json',
        }
        body = json.dumps({
            'path': path,
            'include_media_info': include_media_info,
            'include_deleted': include_deleted,
            'include_has_explicit_shared_members': include_has_explicit_shared_members,
        })
        errors = {
            'path/not_found': NotFoundDropboxError,
        }
        response = self._call(endpoint, api, body, headers, errors, timeout=timeout)
        return response

    def _call_files_create_folder(self, path, autorename=False, timeout=None):
        endpoint = self._endpoint['api']
        api = '/2/files/create_folder'
        headers = {
            'Authorization': 'Bearer %s' % self.access_token,
            'Content-type': 'application/json',
        }
        body = json.dumps({
            'path': path,
            'autorename': autorename,
        })
        errors = {
            'path/disallowed_name': DisallowedNameDropboxError,
            'path/conflict/folder': ConflictDropboxError,
            'path/malformed_path': MalformedPathDropboxError,
        }
        response = self._call(endpoint, api, body, headers, errors, timeout=timeout)
        return response

    def _call_files_delete(self, path, timeout=None):
        endpoint = self._endpoint['api']
        api = '/2/files/delete'
        headers = {
            'Authorization': 'Bearer %s' % self.access_token,
            'Content-type': 'application/json',
        }
        body = json.dumps({
            'path': path,
        })
        errors = {
            'path_lookup/not_found': NotFoundDropboxError,
        }
        response = self._call(endpoint, api, body, headers, errors, timeout=timeout)
        return response

    def _call_files_download(self, path, timeout=None):
        endpoint = self._endpoint['content']
        api = '/2/files/download'
        headers = {
            'Authorization': 'Bearer %s' % self.access_token,
            'Dropbox-API-Arg': json.dumps({
                'path': path,
            }),
        }
        body = ''
        errors = {
            'path/not_found': NotFoundDropboxError,
        }
        response = self._call(endpoint, api, body, headers, errors, return_raw_response=True, timeout=timeout)
        return response  # file data

    def _call_files_upload(self,
                           data,
                           path,
                           mode='overwrite',
                           autorename=False,
                           mute=False,
                           timeout=None):
        endpoint = self._endpoint['content']
        api = '/2/files/upload'
        headers = {
            'Authorization': 'Bearer %s' % self.access_token,
            'Content-type': 'application/octet-stream',
            'Dropbox-API-Arg': json.dumps({
                'path': path,
                'mode': mode,
                'autorename': autorename,
                'mute': mute,
            }),
        }
        body = data
        errors = {
            'path/disallowed_name': DisallowedNameDropboxError,
            'path/malformed_path': MalformedPathDropboxError,
            'path/insufficient_space': InsufficientSpaceDropboxError,
        }
        response = self._call(endpoint, api, body, headers, errors, timeout=timeout)
        return response

    def _call_files_upload_session_start(self, data, close=False, timeout=None):
        endpoint = self._endpoint['content']
        api = '/2/files/upload_session/start'
        headers = {
            'Authorization': 'Bearer %s' % self.access_token,
            'Content-type': 'application/octet-stream',
            'Dropbox-API-Arg': json.dumps({
                'close': close,
            }),
        }
        body = data
        errors = {}
        response = self._call(endpoint, api, body, headers, errors, timeout=timeout)
        return response

    def _call_files_upload_session_append_v2(self,
                                             session_id,
                                             offset,
                                             data,
                                             close=False,
                                             timeout=None):
        endpoint = self._endpoint['content']
        api = '/2/files/upload_session/append_v2'
        headers = {
            'Authorization': 'Bearer %s' % self.access_token,
            'Content-type': 'application/octet-stream',
            'Dropbox-API-Arg': json.dumps({
                'cursor': {
                    'session_id': session_id,
                    'offset': offset,
                },
                'close': close,
            }),
        }
        body = data
        errors = {}
        response = self._call(endpoint, api, body, headers, errors, timeout=timeout)
        # "No return values."
        return response

    def _call_files_upload_session_finish(self,
                                          session_id,
                                          offset,
                                          data,
                                          path,
                                          mode='overwrite',
                                          autorename=False,
                                          mute=False,
                                          timeout=None):
        endpoint = self._endpoint['content']
        api = '/2/files/upload_session/finish'
        headers = {
            'Authorization': 'Bearer %s' % self.access_token,
            'Content-type': 'application/octet-stream',
            'Dropbox-API-Arg': json.dumps({
                'cursor': {
                    'session_id': session_id,
                    'offset': offset,
                },
                'commit': {
                    'path': path,
                    'mode': mode,
                    'autorename': autorename,
                    'mute': mute,
                },
            }),
        }
        body = data
        errors = {
            'path/malformed_path': MalformedPathDropboxError,  # FIXME
            'path/insufficient_space': InsufficientSpaceDropboxError,
        }
        response = self._call(endpoint, api, body, headers, errors, timeout=timeout)
        return response

    def _call_files_list_folder(self,
                                path,
                                recursive=False,
                                include_media_info=False,
                                include_has_explicit_shared_members=False,
                                timeout=None):
        endpoint = self._endpoint['api']
        api = '/2/files/list_folder'
        headers = {
            'Authorization': 'Bearer %s' % self.access_token,
            'Content-type': 'application/json',
        }
        body = json.dumps({
            'path': path,
            'recursive': recursive,
            'include_media_info': include_media_info,
            'include_has_explicit_shared_members': include_has_explicit_shared_members,
        })
        errors = {
            'path/not_found': NotFoundDropboxError,
        }
        response = self._call(endpoint, api, body, headers, errors, timeout=timeout)
        return response

    def _call_files_list_folder_continue(self, cursor, timeout=None):
        endpoint = self._endpoint['api']
        api = '/2/files/list_folder/continue'
        headers = {
            'Authorization': 'Bearer %s' % self.access_token,
            'Content-type': 'application/json',
        }
        body = json.dumps({
            'cursor': cursor,
        })
        errors = {}
        response = self._call(endpoint, api, body, headers, errors, timeout=timeout)
        return response

    def _call_users_get_current_account(self, timeout=None):
        endpoint = self._endpoint['api']
        api = '/2/users/get_current_account'
        headers = {
            'Authorization': 'Bearer %s' % self.access_token,
        }
        body = json.dumps({
            # "No parameters."
        })
        errors = {}
        response = self._call(endpoint, api, body, headers, errors, timeout=timeout)
        return response

    def _to_query_string(self, parameters):
        q = dict([(k.encode(u'utf-8'), v.encode(u'utf-8')) for k, v in parameters.iteritems()])
        q = urllib.urlencode(q)
        return q

    def _get_url(self, endpoint, api, parameters=None):
        parameters = parameters or {}
        parameters = parameters.copy()
        if parameters:
            query_string = self._to_query_string(parameters)
            return 'https://%s%s?%s' % (endpoint, api, query_string)
        else:
            return 'https://%s%s' % (endpoint, api)


if __name__ == '__main__':
    pass

    import optparse
    op = optparse.OptionParser()
    op.add_option('--config-file',
                  action='store',
                  dest='config_file')
    op.add_option('--client-id',
                  action='store',
                  dest='client_id')
    op.add_option('--client-secret',
                  action='store',
                  dest='client_sercret')
    op.add_option('--access-token',
                  action='store',
                  dest='access_token')
    op.add_option('--get-access-token',
                  action='store_true',
                  dest='call_get_access_token')
    op.add_option('--get-authorize-url',
                  action='store_true',
                  dest='call_get_authorize_url')
    op.add_option('--obtain-access-token',
                  action='store_true',
                  dest='call_obtain_access_token')
    op.add_option('--obtain-oauth2-token-from-oauth1-token',
                  action='store_true',
                  dest='call_obtain_oauth2_token_from_oauth1_token')
    op.add_option('--revoke-access-token',
                  action='store_true',
                  dest='call_revoke_access_token')
    op.add_option('--get-metadata',
                  action='store_true',
                  dest='call_get_metadata')
    op.add_option('--get-files',
                  action='store_true',
                  dest='call_get_files')
    op.add_option('--upload-file',
                  action='store_true',
                  dest='call_upload_file')
    op.add_option('--download-file',
                  action='store_true',
                  dest='call_download_file')
    op.add_option('--remove-file',
                  action='store_true',
                  dest='call_remove_file')
    op.add_option('--create-folder',
                  action='store_true',
                  dest='call_create_folder')
    op.add_option('--obtain-account-info',
                  action='store_true',
                  dest='call_obtain_account_info')



    (options, args) = op.parse_args()

    client_id, client_secret = None, None
    with open(options.config_file, 'r') as f:
        config = json.load(f)
        client_id = config['client_id']
        client_secret = config['client_secret']
    client = DropboxClient(client_id, client_secret)

    if options.call_obtain_oauth2_token_from_oauth1_token:
        (oauth1_token, oauth1_token_secret) = args[:2]
        access_token = client.obtain_oauth2_token_from_oauth1_token(oauth1_token, oauth1_token_secret)
        print(access_token)

    elif options.call_get_authorize_url:
        print(client.get_authorize_url())

    elif options.call_get_access_token:
        code = args[0]
        access_token = client.obtain_access_token(code)
        print(access_token)

    else:
        client.access_token = options.access_token.strip()

        if options.call_get_access_token:
            client.revoke_access_token()

        elif options.call_get_metadata:
            for path in args:
                # print(json.dumps(client.get_metadata(path), indent=4))
                print(client.get(path)._dumps_metadata())

        elif options.call_create_folder:
            path = args[0]
            folder_metadata = client.create_folder(path)
            print(folder_metadata)

        elif options.call_remove_file:
            for path in args:
                client.remove_file(path)

        elif options.call_download_file:
            (path, filename) = args
            client.download_file(path, filename)

        elif options.call_upload_file:
            (filename, path) = args
            file_metadata = client.upload_file(filename, path)
            print(json.dumps(file_metadata, indent=4))

        elif options.call_get_files:
            for path in args:
                for i, f in enumerate(client.get_files(path)):
                    print(f._dumps_metadata(indent=4))

        elif options.call_obtain_account_info:
            account_info = client.obtain_account_info()
            print(json.dumps(account_info, indent=4))

        else:
            pass
