#!/usr/bin/env python
# -*- mode: landisk-python; coding: utf-8; -*-
# vim:ts=4 sw=4 sts=4 ai si et sta

from __future__ import with_statement

from ionas.exception import *
from ionas.fileaccess import (MODE_READ, MODE_WRITE)

import re
import sys
import stat
import traceback
from math import fabs
from sets import Set

DIRS_NAME = "dirs"
FILES_NAME = "files"
DIR_NAME = "dir"
FILE_NAME = "file"
MTIME_NAME = "mtime"
SIZE_NAME = "size"
CHILDREN_NAME = "children"
STATE_NAME = "state"
ERRINFO_NAME = "errinfo"
TYPE_NAME = "type"

STATE_NEW = "new"
STATE_DEL = "del"
STATE_SAME = "same"
ERR_STATE_PREFIX = "err_"

MODE_CH_FILE = (stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR | stat.S_IRGRP |
            stat.S_IWGRP | stat.S_IROTH | stat.S_IWOTH)
MODE_CH_DIR = (stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO)

OK_LOG = "OK"
NG_LOG = "NG"
FILE_TRANSFER_LOG = "File Transfer"
FILE_IGNORE_LOG = "File Transfer Ignored"
FILE_DELETE_LOG = "File Delete"
DIR_CREATE_LOG = "Directory Create"
DIR_DELETE_LOG = "Directory Delete"
FILE_SIZE_OVER_LOG = "File Size Over"
GET_TREE_LOG = "Get Tree"
GET_DELTA_TREE_LOG = "Get Delta Tree"
SYNC_SKIP_LOG = "Sync Skip"
ERR_SKIP_LOG = "Get File/Folder Info"

WRITE_TEMP_FILE_NAME = "__tmp_file_for_Copy_60b725f10c9c85c70d97880dfe8191b3"

NOTICE_LOG_LV = 10
SKIP_ERROR_LOG_LV = 15
ERROR_LOG_LV = 20

TYPE_FILE_TRANSFER_OK = "FileTransferOK"
TYPE_FILE_TRANSFER_NG = "FileTransferNG"
TYPE_FILE_DELETE_OK = "FileDeleteOK"
TYPE_FILE_DELETE_NG = "FileDeleteNG"
TYPE_DIR_DELETE_OK = "DirectoryDeleteOK"
TYPE_DIR_DELETE_NG = "DirectoryDeleteNG"
TYPE_SYNC_SKIP = "SyncSkipOK"
TYPE_SYNC_ERR_SKIP = "SyncErrSkip"

LOG_NAME_TYPE_MAP = \
    {FILE_TRANSFER_LOG: {True: TYPE_FILE_TRANSFER_OK,
                         False: TYPE_FILE_TRANSFER_NG},
     FILE_DELETE_LOG: {True: TYPE_FILE_DELETE_OK,
                       False: TYPE_FILE_DELETE_NG},
     DIR_DELETE_LOG: {True: TYPE_DIR_DELETE_OK,
                      False: TYPE_DIR_DELETE_NG}}

def DEBUG(string):
    pass
    #print "######################## " + string + "\n"
    #open("/tmp/1", "a").write("### in DataSync: " + string + "\n")


class IgnoreTargetFile(BaseAccessException):
    pass

class Log():

    def __init__(self, lv, log, args, relpath, src, dst, exc_type,
                    exc_arg, trace, type=None):

        self.lv = lv
        self.log = log
        self.args = args
        self.relpath = relpath
        self.src = src
        self.dst = dst
        self.exc_type = exc_type
        self.exc_arg = exc_arg
        self.trace = trace
        self.type = type


class Src():
    """Base class for the source file tree."""

    def __init__(self, root, ignored_list=[], log_callback=None, base="",
                 misc_callback=None):
        """Constructer."""

        self.root = root
        self.ignored_list = ignored_list + [WRITE_TEMP_FILE_NAME]
        
        if misc_callback:
            self.log_callback = misc_callback.log_callback
        elif log_callback:
            self.log_callback = log_callback
        else:
            self.log_callback = lambda level, log, args, relpath, src, dst, \
                                    exc_type, exc_arg, trace: True

    def logging(self, log_lv, log="", args="", relpath="", src="", dst="",
                    trace=False, log_type=None):

        exc_type, exc_arg = sys.exc_info()[:2]

        if trace:
            tb = traceback.format_exc()
        else:
            tb = ""

        self.log_callback(Log(log_lv, log, args, relpath, src, dst, exc_type,
                        exc_arg, tb, log_type))

    # COMMENT get_root restrictedで使うがfullではどうつかう?
    def get_root(self):
        """Return the source root."""

        return self.root

    def get_tree(self):
        """Return the all file tree."""

        raise NotImplementedError

    def is_delta_tree_supported(self):
        """Return True if "get_delta_tree" method is suppored."""

        return False

    def get_delta_tree(self):
        """Return the changed file tree after this method is called last."""

        raise NotImplementedError

    def init_tree(self):

        raise NotImplementedError

    def get_ignored_list(self):

        return self.ignored_list


class Dst:
    """Base class for the destination file tree."""

    def __init__(self, root, log_callback=None, tmp_path="", err_skip=True,
                    for_sync=True, err_del=True, misc_callback=None):

        self.root = root

        if misc_callback:
            self.log_callback = misc_callback.log_callback
        elif log_callback:
            self.log_callback = log_callback
        else:
            self.log_callback = lambda log_instance: True
        self.tmp_path = tmp_path
        self.err_skip = err_skip
        self.for_sync = for_sync
        self.err_del = err_del

    def logging(self, log_lv, log="", args="", relpath="", src="", dst="",
                    trace=False, log_type=None):

        exc_type, exc_arg = sys.exc_info()[:2]

        if trace:
            tb = traceback.format_exc()
        else:
            tb = ""

        self.log_callback(Log(log_lv, log, args, relpath, src, dst, exc_type,
                                exc_arg, tb, log_type))

    def get_root(self):
        """Return the destination root."""

        return self.root

    def update(self, src):

        raise NotImplementedError


class SrcFull(Src):
    """Class for the source file tree supporting full access."""

    def __init__(self, path, ignored_list=[],
                 log_callback=None, misc_callback=None):

        self.tree = None
        Src.__init__(self, path, ignored_list, log_callback)

    def __set_update(self, tree, path, name):

        is_updated = False

        abspath = self.sep.join([path, name])
        path_stat = self.stat(abspath)
        if stat.S_ISDIR(path_stat[stat.ST_MODE]):
            if not name in tree[DIRS_NAME]:
                tree[DIRS_NAME][name] = {
                    CHILDREN_NAME: {DIRS_NAME: {}, FILES_NAME: {}},
                    MTIME_NAME: int(path_stat[stat.ST_MTIME]),
                    STATE_NAME: STATE_NEW}
                is_updated = True
            else:
                if tree[DIRS_NAME][name][STATE_NAME].startswith(
                                                    ERR_STATE_PREFIX):
                    tree[DIRS_NAME][name][STATE_NAME] = re.sub(
                                "^" + ERR_STATE_PREFIX, "",
                                tree[DIRS_NAME][name][STATE_NAME])
                    is_updated = True
                elif tree[DIRS_NAME][name][STATE_NAME] == STATE_DEL:
                    tree[DIRS_NAME][name][STATE_NAME] = STATE_SAME
                else:
                    # exact_first時に両方に
                    # ほぼ同時刻のdir"A"があり、
                    # その下のfile,dirに差異がある場合に、
                    # get_sync_dup_tree_distrust_new()ではdir"A"はsameに
                    # なるが、その下はnewになり、
                    # dst.update()内では
                    # dir"A"はsameなのでupdate_delta_infoされず、
                    # その下のfile,dirの転送の際に
                    # update_delta_infoされるので、
                    # そのときupdate_delta_infoの
                    # "mtimeのないdirエントリが
                    # できる"ルーチンを通ることへの対処。
                    # mtimeがないと、
                    # 後のget_sync_dup_tree_distrust_newで
                    # KeyErrorになる
                    try:
                        tree[DIRS_NAME][name][MTIME_NAME]
                    except KeyError:
                        tree[DIRS_NAME][name][MTIME_NAME] = int(
                            path_stat[stat.ST_MTIME])
                        tree[DIRS_NAME][name][STATE_NAME] = STATE_SAME
        else:
            if not name in tree[FILES_NAME]:
                tree[FILES_NAME][name] = {
                MTIME_NAME: int(path_stat[stat.ST_MTIME]),
                SIZE_NAME: path_stat[stat.ST_SIZE],
                STATE_NAME: STATE_NEW}
                is_updated = True
            else:
                last_info = tree[FILES_NAME][name]
                new_info = {
                    MTIME_NAME: int(path_stat[stat.ST_MTIME]),
                    SIZE_NAME: path_stat[stat.ST_SIZE],
                    STATE_NAME: STATE_NEW}
                if last_info[STATE_NAME].startswith(ERR_STATE_PREFIX):
                    last_info[STATE_NAME] = re.sub(
                        "^" + ERR_STATE_PREFIX, "", last_info[STATE_NAME])
                    is_updated = True
                elif last_info[STATE_NAME] == STATE_DEL:
                    last_info[STATE_NAME] == STATE_SAME
                elif ((last_info[SIZE_NAME] != new_info[SIZE_NAME]) or
                    (last_info[MTIME_NAME] != new_info[MTIME_NAME])):

                    last_info[SIZE_NAME] = new_info[SIZE_NAME]
                    last_info[MTIME_NAME] = new_info[MTIME_NAME]
                    last_info[STATE_NAME] = STATE_NEW
                    is_updated = True
        return is_updated

    def __set_delete(self, tree, path):

        is_updated = False

        children = self.listdir(path)

        for file in tree[FILES_NAME].keys():
            if (not file in children and
                tree[FILES_NAME][file][STATE_NAME] != STATE_DEL):
                is_updated = True
                tree[FILES_NAME][file][STATE_NAME] = STATE_DEL

        for dir in tree[DIRS_NAME].keys():
            if (not dir in children and
                tree[DIRS_NAME][dir][STATE_NAME] != STATE_DEL):
                is_updated = True
                tree[DIRS_NAME][dir][STATE_NAME] = STATE_DEL

        return is_updated

    def __update_delta_info(self, tree, path_list, mtime=None, size=None,
                            state=None, delete=False, is_dir=False,
                            update_dict={}, delete_keys=[]):

        path = path_list[0]
        if path in tree[DIRS_NAME].keys():
            if len(path_list) == 1:
                if mtime != None:
                    tree[DIRS_NAME][path][MTIME_NAME] = mtime
                if size != None:
                    tree[DIRS_NAME][path][SIZE_NAME] = size
                if state != None:
                    tree[DIRS_NAME][path][STATE_NAME] = state

                tree[DIRS_NAME][path].update(update_dict)

                for key in delete_keys:
                    try:
                        del tree[DIRS_NAME][path][key]
                    except KeyError:
                        pass

                if delete:
                    del tree[DIRS_NAME][path]
            else:
                self.__update_delta_info(tree[DIRS_NAME][path][CHILDREN_NAME],
                            path_list[1:], mtime, size, state,
                            delete, is_dir, update_dict, delete_keys)
            return

        if path in tree[FILES_NAME].keys():
            if mtime != None:
                tree[FILES_NAME][path][MTIME_NAME] = mtime
            if size != None:
                tree[FILES_NAME][path][SIZE_NAME] = size
            if state != None:
                tree[FILES_NAME][path][STATE_NAME] = state

            tree[FILES_NAME][path].update(update_dict)

            for key in delete_keys:
                try:
                    del tree[FILES_NAME][path][key]
                except KeyError:
                    pass

            if delete:
                del tree[FILES_NAME][path]

            return

        if not delete:
            if len(path_list) > 1:
                # COMMENT ここにくると、
                # dirのmtimeがないツリーができる。
                tree[DIRS_NAME][path] = {
                    CHILDREN_NAME: {DIRS_NAME: {}, FILES_NAME: {}},
                    STATE_NAME: STATE_SAME}
                self.__update_delta_info(tree[DIRS_NAME][path][CHILDREN_NAME],
                    path_list[1:], mtime, size, state,
                    delete, is_dir, update_dict, delete_keys)

            if len(path_list) == 1:
                if is_dir:
                    tree[DIRS_NAME][path] = {
                        MTIME_NAME: mtime,
                        CHILDREN_NAME: {DIRS_NAME: {}, FILES_NAME: {}},
                        STATE_NAME: state}
                    tree[DIRS_NAME][path].update(update_dict)
                else:
                    tree[FILES_NAME][path] = {
                        MTIME_NAME: mtime,
                        SIZE_NAME: size,
                        STATE_NAME: state}
                    tree[FILES_NAME][path].update(update_dict)

    def __update_delta_tree(self, root_tree, update_tree):
        for update_file in update_tree[FILES_NAME]:
            update_info = update_tree[FILES_NAME][update_file]
            if update_file in root_tree[FILES_NAME].keys():
                root_info = root_tree[FILES_NAME][update_file]
                if update_info[STATE_NAME].startswith(ERR_STATE_PREFIX):
                    root_info[STATE_NAME] = re.sub(
                        "^" + ERR_STATE_PREFIX, "", update_info[STATE_NAME])
                else:
                    root_info = update_info
                    root_info[STATE_NAME] = STATE_SAME
            else:
                root_tree[FILES_NAME][update_file] = update_info
                root_tree[FILES_NAME][update_file][STATE_NAME] = STATE_SAME

        for update_dir in update_tree[DIRS_NAME]:
            update_info = update_tree[DIRS_NAME][update_dir]
            if update_dir in root_tree[DIRS_NAME].keys():
                root_info = root_tree[DIRS_NAME][update_dir]
                if update_info[STATE_NAME].startswith(ERR_STATE_PREFIX):
                    root_info[STATE_NAME] = re.sub(
                        "^" + ERR_STATE_PREFIX, "", update_info[STATE_NAME])
                else:
                    root_info[STATE_NAME] = STATE_SAME
            else:
                root_tree[DIRS_NAME][update_dir] = {
                    STATE_NAME: STATE_SAME,
                    CHILDREN_NAME: get_init_tree()}
                root_info = root_tree[DIRS_NAME][update_dir]
            self.__update_delta_tree(
                root_info[CHILDREN_NAME], update_info[CHILDREN_NAME])

    def __get_delta_tree(self, tree, path):

        IS_UPDATED_IDX = 0

        is_updated = False

        for name in self.listdir(path):
            try:
                if name in self.ignored_list:
                    continue
            except:
                raise

            if self.__set_update(tree, path, name):
                is_updated = True

        if self.__set_delete(tree, path):
            is_updated = True

        for dir in tree[DIRS_NAME].keys():
            if tree[DIRS_NAME][dir][STATE_NAME] == STATE_DEL:
                continue
            if self.__get_delta_tree(
                tree[DIRS_NAME][dir][CHILDREN_NAME],
                self.sep.join([path, dir]))[IS_UPDATED_IDX]:
                is_updated = True

        return (is_updated, tree)

    def __get_tree(self, tree=None, path=None):
        """Return the all file tree."""

        for name in self.listdir(path):
            try:
                if name in self.ignored_list:
                    continue
            except:
                raise

            abspath = self.sep.join([path, name])
            path_stat = self.stat(abspath)
            if stat.S_ISDIR(path_stat[stat.ST_MODE]):
                tree[DIRS_NAME][name] = {
                    MTIME_NAME: int(path_stat[stat.ST_MTIME]),
                    CHILDREN_NAME: {DIRS_NAME: {}, FILES_NAME: {}}}
                self.__get_tree(tree[DIRS_NAME][name][CHILDREN_NAME], abspath)
            else:
                tree[FILES_NAME][name] = {
                    MTIME_NAME: int(path_stat[stat.ST_MTIME]),
                    SIZE_NAME: path_stat[stat.ST_SIZE]}
        return tree

    def get_tree(self):

        try:
            tree = get_init_tree()
            return self.__get_tree(tree, self.root)
        except:
            self.logging(ERROR_LOG_LV, GET_TREE_LOG + " " + NG_LOG,
                            src=self, trace=True)
            raise

    def get_delta_tree(self):
        # COMMENT 戻り値:(更新有無, 差分情報ツリー)
        try:
            if not self.tree:
                self.tree = get_new_tree(self.get_tree())
                return (True, self.tree)
            else:
                is_updated, self.tree = \
                    self.__get_delta_tree(self.tree, self.root)
                return (is_updated, self.tree)
        except:
            self.logging(ERROR_LOG_LV, GET_DELTA_TREE_LOG + " " + NG_LOG,
                            src=self, trace=True)
            raise

    def update_delta_tree(self, update_obj):

        if not self.tree:
            self.tree = get_init_tree()

        if callable(update_obj):
            update_obj(self.tree)
            return

        self.__update_delta_tree(self.tree, update_obj)

    def update_delta_info(self, path_list, mtime=None, size=None, state=None,
                          delete=False, is_dir=False,
                          update_dict={}, delete_keys=[]):

        if not self.tree:
            self.tree = get_init_tree()
        return self.__update_delta_info(self.tree, path_list, mtime, size,
                            state, delete, is_dir, update_dict, delete_keys)

    def get_current_tree(self):

        return self.tree

    def listdir(self, path):
        """Return List dir of "path"."""

        raise NotImplementedError

    def isdir(self, entry):  # COMMENT 高速化するなら必要かも
        """Is dir."""

        raise NotImplementedError

    def stat(self, path):
        """Return status of "path"."""

        raise NotImplementedError

    def open(self, path, mode):
        """Return file obj of "path"."""

        raise NotImplementedError

    def logging_for_err_skip(self, relpath, file):

        self.logging(SKIP_ERROR_LOG_LV,
                     ERR_SKIP_LOG, "",
                     self.sep.join(relpath + [file]),
                     None, self,
                     True,
                     TYPE_SYNC_ERR_SKIP)


class DstFull(Dst):

    def __init__(self, root, log_callback=None, tmp_path="", err_skip=True,
                 for_sync=True, err_del=True,
                 is_skip_file_callback=None,
                 misc_callback=None):

        Dst.__init__(self, root, log_callback, tmp_path,
                     err_skip, for_sync, err_del,
                     misc_callback=misc_callback)

        self.OPE_FILE_TRANSFER = "file_transfer"
        self.OPE_FILE_DELETE = "file_delete"
        self.OPE_DIR_CREATE = "dir_create"
        self.OPE_DIR_DELETE = "dir_delete"
        self.METHOD_NAME = "method"
        self.LOG_NAME = "log"
        self.ERR_STATE = "err_state"

        if is_skip_file_callback:
            self.is_skip_file_callback = is_skip_file_callback
        else:
            self.is_skip_file_callback = lambda file_path: False

        self.OPERATION = {
            self.OPE_FILE_TRANSFER: {
                self.METHOD_NAME: self.__exec_file_transfer,
                self.LOG_NAME: FILE_TRANSFER_LOG,
                self.ERR_STATE: ERR_STATE_PREFIX + STATE_NEW},
            self.OPE_FILE_DELETE: {
                self.METHOD_NAME: self.__exec_file_delete,
                self.LOG_NAME: FILE_DELETE_LOG,
                self.ERR_STATE: ERR_STATE_PREFIX + STATE_DEL},
            self.OPE_DIR_CREATE: {
                self.METHOD_NAME: self.__exec_dir_create,
                self.LOG_NAME: DIR_CREATE_LOG,
                self.ERR_STATE: ERR_STATE_PREFIX + STATE_NEW},
            self.OPE_DIR_DELETE: {
                self.METHOD_NAME: self.__exec_dir_delete,
                self.LOG_NAME: DIR_DELETE_LOG,
                self.ERR_STATE: ERR_STATE_PREFIX + STATE_DEL}}

    def init_non_tree_param(self, src):

        self.src = src
        self.for_sync = False
        return

    def __get_log_type(self, log_name, result):
        try:
            return LOG_NAME_TYPE_MAP[log_name][result]
        except:
            return None

    def logging_for_skip(self, relpath, file):

        self.logging(NOTICE_LOG_LV,
                     SYNC_SKIP_LOG, "",
                     self.sep.join(relpath + [file]),
                     self.src, self,
                     False,
                     TYPE_SYNC_SKIP)

    def logging_for_err_skip(self, relpath, file, ):

        self.logging(SKIP_ERROR_LOG_LV,
                     ERR_SKIP_LOG, "",
                     self.sep.join(relpath + [file]),
                     self.src, self,
                     True,
                     TYPE_SYNC_ERR_SKIP)

    # COMMENT サーバ側のutimeできないことの弊害。
    def __get_file_info(self, tree, path_list):

        path = path_list[0]
        if path in tree[DIRS_NAME].keys():
            return self.__get_file_info(tree[DIRS_NAME][path][CHILDREN_NAME],
                path_list[1:])
        if path in tree[FILES_NAME].keys():
            return tree[FILES_NAME][path]

        # COMMENT amazonS3はfileまでのdirが実在しなくても
        # fileを作成可能なので、fileまでのtree構成を作成。
        if len(path_list) > 1:
            tree[DIRS_NAME][path] = {
                CHILDREN_NAME: {DIRS_NAME: {}, FILES_NAME: {}},
                STATE_NAME: STATE_SAME}
            return self.__get_file_info(tree[DIRS_NAME][path][CHILDREN_NAME],
                path_list[1:])
        if len(path_list) == 1:
            tree[FILES_NAME][path] = {
                MTIME_NAME: "",
                SIZE_NAME: "",
                STATE_NAME: STATE_SAME}
            return tree[FILES_NAME][path]

        return None

    def __delete_err_file(self, path):
        # except内で使用
        ins = sys.exc_info()[1]
        tb = sys.exc_info()[2]
        try:
            if self.err_del:
                self.remove(path)
        except:
            pass
        raise ins, None, tb

    def __exec_file_transfer(self, file_relpath, file_info):
        is_executed = False

        if file_info[STATE_NAME] != STATE_NEW:
            return is_executed

        self.pre_file_transfer(file_relpath, file_info)

        src_path = self.src.sep.join([self.src.root] + file_relpath)
        if self.tmp_path:
            dst_path = self.sep.join(self.tmp_path.split(self.sep) + \
                                   [WRITE_TEMP_FILE_NAME])
            real_dst_path = self.sep.join([self.root] + file_relpath)

            try:
                self.remove(dst_path)
            except NoEntryError:
                pass
        else:
            dst_path = self.sep.join([self.root] + file_relpath)

        # 対応外のファイルはエラー扱い
        if self.is_skip_file_callback(file_relpath):
            raise IgnoreTargetFile(path=dst_path)

        try:
            with self.open(dst_path, MODE_WRITE) as dst_file:
                with self.src.open(src_path, MODE_READ) as src_file:
                    try:
                        dst_file.write_by_path(src_file)
                    except NotImplementedError:
                        try:
                            src_file.read_by_path(dst_file)
                        # COMMENT smbのreaddirectでNoSpaceError
                        # 検出できない件どうするか
                        except NotImplementedError:
                            dst_file.write(src_file)

            if self.tmp_path:
                try:
                    self.move(dst_path, real_dst_path)
                except:
                    self.__delete_err_file(real_dst_path)

        except:
            self.__delete_err_file(dst_path)

        self.post_file_transfer(file_relpath, file_info)

        is_executed = True

        return is_executed

    def __exec_file_delete(self, file_relpath, file_info):
        is_executed = False

        if file_info[STATE_NAME] != STATE_DEL:
            return is_executed

        self.pre_file_delete(file_relpath, file_info)

        dst_path = self.sep.join([self.root] + file_relpath)

        is_executed = True

        try:
            self.remove(dst_path)
        except (NoEntryError, NameTooLongError):
            pass

        self.post_file_delete(file_relpath, file_info)

        return is_executed

    def __exec_dir_create(self, dir_relpath, dir_info):
        is_executed = False

        if dir_info[STATE_NAME] != STATE_NEW:
            return is_executed

        self.pre_dir_create(dir_relpath, dir_info)

        dst_path = self.sep.join([self.root] + dir_relpath)

        is_executed = True

        try:
            self.mkdir(dst_path)
        except ExistsError:
            if stat.S_ISDIR(self.stat(dst_path)[stat.ST_MODE]):
                pass
            else:
                raise

        self.post_dir_create(dir_relpath, dir_info)

        return is_executed

    def __exec_dir_delete(self, dir_relpath, dir_info):
        is_executed = False

        if dir_info[STATE_NAME] != STATE_DEL:
            return is_executed

        self.pre_dir_delete(dir_relpath, dir_info)

        dst_path = self.sep.join([self.root] + dir_relpath)
        is_executed = True
        try:
            self.rmdir(dst_path)
        except (NoEntryError, NameTooLongError):
            pass

        self.post_dir_delete(dir_relpath, dir_info)

        return is_executed

    def is_misc_skip_err(self, exc_type, exc_ins):
        return False

    def is_skip_err(self, exc_type, exc_ins):
        if (exc_type == NoEntryError or
            exc_type == PermissionError or
            exc_type == NameTooLongError or
            exc_type == ExistsError or
            exc_type == SizeTooLargeError or
            exc_type == ModifiedInTransferring or
            exc_type == FileLockError or
            exc_type == NonSupportedFileError or
            exc_type == IgnoreTargetFile or
            exc_type == BusyError or
            self.is_misc_skip_err(exc_type, exc_ins)):
            return True

        return False

    def post_operation_except(self, ope, relpath, file, file_info):
        exc_type, exc_ins = sys.exc_info()[:2]

        last_exc_type = file_info.get(ERRINFO_NAME, {}).\
                                  get(TYPE_NAME, None)
        last_size = file_info.get(ERRINFO_NAME, {}).\
                              get(SIZE_NAME, None)

        if (exc_type == SizeTooLargeError and
            exc_type == last_exc_type and
            file_info.get(SIZE_NAME) == last_size):
            """
            SizeTooLargeErrorが連続する場合,ログは残さない
            """

            self.src.update_delta_info(
                relpath + [file], state=ope[self.ERR_STATE])

            if not self.err_skip:
                raise

        elif self.is_skip_err(exc_type, exc_ins):

            """
            下記のSIZE_NAME: file_info.get(SIZE_NAME, None)}})について
            dirのときはSIZE_NAMEキーはないので
            file_info.get()メソッドで取得している
            """
            self.src.update_delta_info(
                relpath + [file], state=ope[self.ERR_STATE],
                update_dict={ERRINFO_NAME: {
                                 TYPE_NAME: exc_type,
                                 SIZE_NAME: file_info.get(SIZE_NAME, None)}})

            if exc_type == SizeTooLargeError:
                self.logging(
                    SKIP_ERROR_LOG_LV,
                    FILE_SIZE_OVER_LOG, self.MAX_FILE_SIZE,
                    self.sep.join(relpath + [file]),
                    self.src, self)
            elif exc_type == IgnoreTargetFile:
                self.logging(
                    NOTICE_LOG_LV,
                    FILE_IGNORE_LOG, "",
                    self.sep.join(relpath + [file]),
                    self.src, self)
            else:
                self.logging(
                    SKIP_ERROR_LOG_LV,
                    ope[self.LOG_NAME] + " " + NG_LOG, "",
                    self.sep.join(relpath + [file]),
                    self.src, self, True,
                    log_type=self.__get_log_type(ope[self.LOG_NAME], False))

            if not self.err_skip:
                raise

        else:
            self.logging(ERROR_LOG_LV, ope[self.LOG_NAME] + " " + NG_LOG, "",
                self.sep.join(relpath + [file]),
                self.src, self, True,
                log_type=self.__get_log_type(ope[self.LOG_NAME], False))
            """ Abort Sync. """
            raise

    def __try_operation(self, ope, relpath, file, file_info):
        is_executed = False
        try:
            if ope[self.METHOD_NAME](relpath + [file], file_info):
                is_executed = True
                self.logging(NOTICE_LOG_LV,
                    ope[self.LOG_NAME] + " " + OK_LOG, "",
                    self.sep.join(relpath + [file]), self.src, self,
                    log_type=self.__get_log_type(ope[self.LOG_NAME], True))
        except:
            self.post_operation_except(ope, relpath, file, file_info)

        return is_executed

    def __update(self, relpath, tree):
        for file in tree[FILES_NAME].keys():
            file_info = tree[FILES_NAME][file]

            self.__try_operation(self.OPERATION[self.OPE_FILE_TRANSFER],
                relpath, file, file_info)

            if self.__try_operation(self.OPERATION[self.OPE_FILE_DELETE],
                relpath, file, file_info):
                del tree[FILES_NAME][file]

        for dir in tree[DIRS_NAME].keys():
            dir_info = tree[DIRS_NAME][dir]

            self.__try_operation(self.OPERATION[self.OPE_DIR_CREATE],
                relpath, dir, dir_info)
            if self.__try_operation(self.OPERATION[self.OPE_DIR_DELETE],
                relpath, dir, dir_info):
                del tree[DIRS_NAME][dir]

            else:
                self.__update(relpath + [dir],
                    tree[DIRS_NAME][dir][CHILDREN_NAME])

    def __create_dir(self, relpath, dir_name, info):

        self.__try_operation(self.OPERATION[self.OPE_DIR_CREATE],
                             relpath, dir_name, info)

    def __delete_dir(self, relpath, dir_name, info):

        self.__try_operation(self.OPERATION[self.OPE_DIR_DELETE],
                             relpath, dir_name, info)

    def __transfer_file(self, relpath, file_name, info):

        self.__try_operation(self.OPERATION[self.OPE_FILE_TRANSFER],
                             relpath, file_name, info)

    def __delete_file(self, relpath, file_name, info):

        self.__try_operation(self.OPERATION[self.OPE_FILE_DELETE],
                             relpath, file_name, info)

    def create_dirs(self, relpath, dirs_info):

        for dir, info in dirs_info.iteritems():
            self.__create_dir(relpath, dir, info)

    def delete_dirs(self, relpath, dirs_info):

        for dir, info in dirs_info.iteritems():
            self.__delete_dir(relpath, dir, info)

    def transfer_files(self, relpath, files_info):

        for file, info in files_info.iteritems():
            self.__transfer_file(relpath, file, info)

    def delete_files(self, relpath, files_info):

        for file, info in files_info.iteritems():
            self.__delete_file(relpath, file, info)

    def pre_file_transfer(self, file_relpath, file_info):
        pass

    def pre_file_delete(self, file_relpath, file_info):
        pass

    def pre_dir_create(self, dir_relpath, dir_info):
        pass

    def pre_dir_delete(self, dir_relpath, dir_info):
        pass

    def post_file_transfer(self, file_relpath, file_info):
        if self.for_sync:
            self.src.update_delta_info(file_relpath,
                                       state=STATE_SAME,
                                       delete_keys=[ERRINFO_NAME])

    def post_file_delete(self, file_relpath, file_info):
        pass

    def post_dir_create(self, dir_relpath, dir_info):
        if self.for_sync:
            self.src.update_delta_info(dir_relpath,
                                       state=STATE_SAME,
                                       delete_keys=[ERRINFO_NAME])

    def post_dir_delete(self, dir_relpath, dir_info):
        pass

    def update(self, src, tree):
        self.src = src
        self.__update([], tree)

    def mkdir(self, path):
        """Create a directory specified by "path"."""

        raise NotImplementedError

    def stat(self, path):

        raise NotImplementedError

    def chmod(self, path, mode):

        raise NotImplementedError

    def utime(self, path, mtime):

        raise NotImplementedError

    def remove(self, path):

        raise NotImplementedError

    def move(self, path):

        raise NotImplementedError

    def rmdir(self, path):

        raise NotImplementedError

    def open(self, path, mode):

        raise NotImplementedError


class SrcRestricted(Src):
    """Class for the source file tree supporting restricted access."""

    def get_tree(self):
        """Return the all file tree."""

        print "Restricted get tree from " + self.root

        # return path for this sample
        return "sub_dir"

    def get_delta_tree(self):
        """Return the all file tree."""

        print "Restricted get delta tree from " + self.root
        return self.get_tree()

    def read_tree(self, path):
        """Return a object for tree data."""

        raise NotImplemented()


class DstRestricted(Dst):
    """Class for the destination file tree supporting restricted access."""

    def update(self, src):

        # update_tree is file path for this sample
        self.write_tree(src.read_tree())

    def write_tree(self, path, tree_data):
        """Write a tree data."""

        raise NotImplemented()


### ツリー編集関数群
def __get_sync_simp_tree_exists_in_base(base_tree, target_tree):

    for dir in base_tree[DIRS_NAME].keys():
        if dir in target_tree[FILES_NAME]:
            base_tree[FILES_NAME][dir] = {STATE_NAME: STATE_DEL}
        if dir in target_tree[DIRS_NAME]:
            base_tree[DIRS_NAME][dir][STATE_NAME] = STATE_SAME
            __get_sync_simp_tree_exists_in_base(
                base_tree[DIRS_NAME][dir][CHILDREN_NAME],
                target_tree[DIRS_NAME][dir][CHILDREN_NAME])

    for file in base_tree[FILES_NAME].keys():
        if file in target_tree[DIRS_NAME]:
            base_tree[DIRS_NAME][file] = {STATE_NAME: STATE_DEL}
        if file in target_tree[FILES_NAME]:
            base_info = base_tree[FILES_NAME][file]
            target_info = target_tree[FILES_NAME][file]
            if (base_info[MTIME_NAME] == target_info[MTIME_NAME] and
                base_info[SIZE_NAME] == target_info[SIZE_NAME]):
                base_tree[FILES_NAME][file][STATE_NAME] = STATE_SAME
            else:
                base_info[STATE_NAME] = STATE_NEW
        else:
            base_tree[FILES_NAME][file][STATE_NAME] = STATE_NEW

    return (base_tree, target_tree)


def __get_sync_simp_tree_noexists_in_base(base_tree, target_tree):

    for dir in target_tree[DIRS_NAME].keys():
        if not dir in base_tree[DIRS_NAME]:
            base_tree[DIRS_NAME][dir] = {
                STATE_NAME: STATE_DEL}
        else:
            __get_sync_simp_tree_noexists_in_base(
                base_tree[DIRS_NAME][dir][CHILDREN_NAME],
                target_tree[DIRS_NAME][dir][CHILDREN_NAME])

    for file in target_tree[FILES_NAME].keys():
        if not file in base_tree[FILES_NAME]:
            base_tree[FILES_NAME][file] = {
                STATE_NAME: STATE_DEL}

    return (base_tree, target_tree)


def get_sync_simp_tree(src_tree, dst_tree):

    src_tree, dst_tree = __get_sync_simp_tree_exists_in_base(
        src_tree, dst_tree)
    src_tree, dst_tree = __get_sync_simp_tree_noexists_in_base(
        src_tree, dst_tree)

    return src_tree


def __get_sync_dup_tree(base_tree, target_tree):

    for dir in base_tree[DIRS_NAME].keys():
        base_info = base_tree[DIRS_NAME][dir]
        if dir in target_tree[DIRS_NAME]:
            target_info = target_tree[DIRS_NAME][dir]
            if base_info[STATE_NAME] == STATE_DEL:
                if target_info[STATE_NAME] != STATE_NEW:
                    pass
                    #del target_tree[DIRS_NAME][dir]
            else:
                base_info[STATE_NAME] = STATE_SAME
                __get_sync_dup_tree(
                    base_info[CHILDREN_NAME],
                    target_info[CHILDREN_NAME])
        else:
            base_tree[DIRS_NAME][dir][STATE_NAME] = STATE_NEW
            base_tree[DIRS_NAME][dir][CHILDREN_NAME] = \
                get_new_tree(base_tree[DIRS_NAME][dir][CHILDREN_NAME])

        if dir in target_tree[FILES_NAME]:
            """ Give Priority to Directory. """
            if target_tree[FILES_NAME][dir][STATE_NAME] != STATE_DEL:
                base_tree[FILES_NAME][dir] = {
                    MTIME_NAME: "",
                    SIZE_NAME: "",
                    STATE_NAME: STATE_DEL}
                target_tree[FILES_NAME][dir][STATE_NAME] = STATE_SAME

    for file in base_tree[FILES_NAME].keys():
        base_info = base_tree[FILES_NAME][file]
        if file in target_tree[FILES_NAME]:
            target_info = target_tree[FILES_NAME][file]
            if base_info[STATE_NAME] == STATE_NEW:
                if target_info[STATE_NAME] == STATE_NEW:
                    # COMMENT mtime同じでsize違う場合、
                    # 先にset_sync_dup_treeのbase_treeとして
                    # 渡された方が反映される。
                    if base_info[MTIME_NAME] == target_info[MTIME_NAME]:
                        if base_info[SIZE_NAME] == target_info[SIZE_NAME]:
                            base_info[STATE_NAME] = STATE_SAME
                            target_info[STATE_NAME] = STATE_SAME
                        else:
                            base_info[STATE_NAME] = STATE_NEW
                            target_info[STATE_NAME] = STATE_SAME
                    elif base_info[MTIME_NAME] > target_info[MTIME_NAME]:
                        base_info[STATE_NAME] = STATE_NEW
                        target_info[STATE_NAME] = STATE_SAME
                else:
                    target_info[STATE_NAME] = STATE_SAME
            elif base_info[STATE_NAME] == STATE_DEL:
                if target_info[STATE_NAME] != STATE_NEW:
                    pass
                    #del target_tree[FILES_NAME][file]
        else:
            if base_info[STATE_NAME] != STATE_DEL:
                base_info[STATE_NAME] = STATE_NEW

    return (base_tree, target_tree)


# COMMENT NASとamazonの時刻ずれ許容時間(秒)
EXCUSE_TIME = 5


def __get_sync_dup_tree_distrust_new_for_file(
    base_info, target_info, reverse):

    if fabs(base_info[MTIME_NAME] - target_info[MTIME_NAME]) > EXCUSE_TIME:
        if not reverse:
            if base_info[MTIME_NAME] > target_info[MTIME_NAME]:
                base_info[STATE_NAME] = STATE_NEW
                target_info[STATE_NAME] = STATE_SAME
            else:
                base_info[STATE_NAME] = STATE_SAME

    else:
        if base_info[SIZE_NAME] != target_info[SIZE_NAME]:
            if not reverse:
                base_info[STATE_NAME] = STATE_NEW
                target_info[STATE_NAME] = STATE_SAME

        else:
            base_info[STATE_NAME] = STATE_SAME
            target_info[STATE_NAME] = STATE_SAME


def __get_sync_dup_tree_distrust_new_for_dir(
    base_info, target_info, reverse):

    if fabs(base_info[MTIME_NAME] - target_info[MTIME_NAME]) > EXCUSE_TIME:
        if not reverse:
            if base_info[MTIME_NAME] > target_info[MTIME_NAME]:
                base_info[STATE_NAME] = STATE_NEW
                target_info[STATE_NAME] = STATE_SAME
            else:
                base_info[STATE_NAME] = STATE_SAME

    else:
        base_info[STATE_NAME] = STATE_SAME
        target_info[STATE_NAME] = STATE_SAME


def _get_sync_dup_tree_distrust_new(
    base_tree, target_tree, reverse=False):

    for dir in base_tree[DIRS_NAME].keys():
        base_info = base_tree[DIRS_NAME][dir]
        if dir in target_tree[DIRS_NAME]:
            target_info = target_tree[DIRS_NAME][dir]
            if dir in target_tree[FILES_NAME]:
                base_tree[FILES_NAME][dir] = {
                    STATE_NAME: STATE_DEL}
            if base_info[STATE_NAME] != STATE_DEL:
                if target_info[STATE_NAME] != STATE_DEL:
                    __get_sync_dup_tree_distrust_new_for_dir(
                        base_info, target_info, reverse)
                    _get_sync_dup_tree_distrust_new(
                        base_info[CHILDREN_NAME],
                        target_info[CHILDREN_NAME],
                        reverse)
            else:
                if target_info[STATE_NAME] != STATE_NEW:
                    del target_tree[DIRS_NAME][dir]
        else:
            # COMMENT STATE_NEWであるdir以下全てnewにしておき、
            # 相手のメモリツリーに同構造作るのは止める。
            # 相手が次に続けてget_delta_treeしたときに
            # 以前のメモリツリー情報が虚偽となるため。
            base_tree[DIRS_NAME][dir][STATE_NAME] = STATE_NEW
            base_tree[DIRS_NAME][dir][CHILDREN_NAME] = \
                get_new_tree(base_tree[DIRS_NAME][dir][CHILDREN_NAME])

        if dir in target_tree[FILES_NAME]:
            """ Give Priority to Directory. """
            if target_tree[FILES_NAME][dir][STATE_NAME] != STATE_DEL:
                base_tree[FILES_NAME][dir] = {
                    MTIME_NAME: "",
                    SIZE_NAME: "",
                    STATE_NAME: STATE_DEL}
                target_tree[FILES_NAME][dir][STATE_NAME] = STATE_SAME

    for file in base_tree[FILES_NAME].keys():
        base_info = base_tree[FILES_NAME][file]
        if file in target_tree[FILES_NAME]:
            target_info = target_tree[FILES_NAME][file]

            if base_info[STATE_NAME] != STATE_DEL:
                if target_info[STATE_NAME] != STATE_DEL:
                # COMMENT mtime同じでsize違う場合、
                # 後に_get_sync_dup_tree_distrust_newのbase_treeとして
                # 渡された方が反映される。
                    __get_sync_dup_tree_distrust_new_for_file(
                        base_info, target_info, reverse)

            else:
                if target_info[STATE_NAME] != STATE_NEW:
                    del target_tree[FILES_NAME][file]
        else:
            if base_info[STATE_NAME] != STATE_DEL:
                base_info = base_tree[FILES_NAME][file]
                # 相手のメモリツリーに同構造
                # 作るのは止める。
                # 相手が次に続けてget_delta_treeしたときに
                # 以前のメモリツリー情報が虚偽となるため。
                base_info[STATE_NAME] = STATE_NEW

    return (base_tree, target_tree)


def get_new_tree_last_time_later(tree, last_time, is_under_new_dir=False):

    for file in tree[FILES_NAME].keys():
        if not is_under_new_dir:
            if tree[FILES_NAME][file][STATE_NAME] != STATE_DEL:
                if tree[FILES_NAME][file][MTIME_NAME] > last_time:
                    tree[FILES_NAME][file][STATE_NAME] = STATE_NEW
                else:
                    tree[FILES_NAME][file][STATE_NAME] = STATE_SAME
        else:
            tree[FILES_NAME][file][STATE_NAME] = STATE_NEW

    for dir in tree[DIRS_NAME].keys():
        if not is_under_new_dir:
            if tree[DIRS_NAME][dir][STATE_NAME] != STATE_DEL:
                if tree[DIRS_NAME][dir][MTIME_NAME] > last_time:
                    tree[DIRS_NAME][dir][STATE_NAME] = STATE_NEW
                    is_under_new_dir = True
                else:
                    tree[DIRS_NAME][dir][STATE_NAME] = STATE_SAME
        else:
            tree[DIRS_NAME][dir][STATE_NAME] = STATE_NEW
        get_new_tree_last_time_later(tree[DIRS_NAME][dir][CHILDREN_NAME],
                            last_time, is_under_new_dir)
    return tree


def __get_new_tree(tree):

    for file in tree[FILES_NAME].keys():
        tree[FILES_NAME][file][STATE_NAME] = STATE_NEW

    for dir in tree[DIRS_NAME].keys():
        tree[DIRS_NAME][dir][STATE_NAME] = STATE_NEW
        __get_new_tree(tree[DIRS_NAME][dir][CHILDREN_NAME])
    return tree


def __get_same_tree(tree):

    for file in tree[FILES_NAME].keys():
        tree[FILES_NAME][file][STATE_NAME] = STATE_SAME

    for dir in tree[DIRS_NAME].keys():
        tree[DIRS_NAME][dir][STATE_NAME] = STATE_SAME
        __get_same_tree(tree[DIRS_NAME][dir][CHILDREN_NAME])
    return tree


def __set_new_state(tree):

    for file in tree[FILES_NAME].keys():
        tree[FILES_NAME][file][STATE_NAME] = STATE_NEW

    for dir in tree[DIRS_NAME].keys():
        tree[DIRS_NAME][dir][STATE_NAME] = STATE_NEW
        __set_new_state(tree[DIRS_NAME][dir][CHILDREN_NAME])


def __get_files_and_dirs_info(tree, rel_path_elements, ignored_list):
    """Get files's info dict and directories's info which are in
       'rel_path_elements' direcotry.
    """

    dir_path = tree.sep.join([tree.get_root()] + rel_path_elements)
    file_dir_list = list(Set(tree.listdir(dir_path)) - Set(ignored_list))

    dir_info = {}
    file_info = {}
    for el in file_dir_list:
        try:
            el_stat = tree.stat(tree.sep.join([dir_path, el]))
        except BusyError:
            tree.logging_for_err_skip(rel_path_elements, el)
        except PermissionError:
            tree.logging_for_err_skip(rel_path_elements, el)

        if stat.S_ISDIR(el_stat[stat.ST_MODE]):
            dir_info.update({el: {MTIME_NAME: int(el_stat[stat.ST_MTIME])}})
        else:
            file_info.update({el: {MTIME_NAME: int(el_stat[stat.ST_MTIME]),
                                   SIZE_NAME: el_stat[stat.ST_SIZE]}})

    return file_info, dir_info


def __transfer_files(dst, rel_path_elements, src_files_info, dst_files_info):
    """Detect added or modified files in the specified source files.
       And transfer those files to the destination.
    """

    transfer_files_info = {}

    for src_file_name, info in src_files_info.iteritems():

        if src_file_name not in dst_files_info.keys():
            transfer_files_info.update({src_file_name: info})
            transfer_files_info[src_file_name][STATE_NAME] = STATE_NEW
            continue

        if info[MTIME_NAME] != dst_files_info[src_file_name][MTIME_NAME] or \
           info[SIZE_NAME] != dst_files_info[src_file_name][SIZE_NAME]:
            transfer_files_info.update({src_file_name: info})
            transfer_files_info[src_file_name][STATE_NAME] = STATE_NEW
            continue

        else:
            dst.logging_for_skip(rel_path_elements, src_file_name)
            continue

    dst.transfer_files(rel_path_elements, transfer_files_info)
    return


def __create_dirs(dst, rel_path_elements, src_dirs_info, dst_dirs_info):
    """Detect added directories in the specified source directories.
       And create those directories on the destination.
    """
    create_dirs_info = {}

    for src_dir_name, info in src_dirs_info.iteritems():

        if src_dir_name not in dst_dirs_info.keys():
            create_dirs_info.update({src_dir_name: info})
            create_dirs_info[src_dir_name][STATE_NAME] = STATE_NEW
            continue

    dst.create_dirs(rel_path_elements, create_dirs_info)
    return


def __delete_files(dst, rel_path_elements, src_files_info, dst_files_info):
    """Detect deleted files in the specified source files.
       And delete those files in the destination.
    """
    deleted_files = Set(dst_files_info.keys()) - Set(src_files_info.keys())

    delete_files_info = {}
    for file_name in list(deleted_files):
        delete_files_info.update({file_name: dst_files_info[file_name]})
        delete_files_info[file_name][STATE_NAME] = STATE_DEL

    dst.delete_files(rel_path_elements, delete_files_info)
    return


def __delete_dirs(dst, rel_path_elements, src_dirs_info, dst_dirs_info):
    """Detect deleted directories in the specified source directories.
       And delete those directories in the destination.
    """
    deleted_dirs = Set(dst_dirs_info.keys()) - Set(src_dirs_info.keys())

    delete_dirs_info = {}
    for dir_name in list(deleted_dirs):
        delete_dirs_info.update({dir_name: dst_dirs_info[dir_name]})
        delete_dirs_info[dir_name][STATE_NAME] = STATE_DEL

    dst.delete_dirs(rel_path_elements, delete_dirs_info)
    return


def __sync_one_dir_and_get_dirs(src, dst, rel_path_elements):
    """Sync one directory(transfer, create, and delete file or directory).
       The files and directories that are in lower level of the specified
       directory are not applied for this sync.
       And return directries list that are in the specified directory.
    """
    ignored_list = src.get_ignored_list()

    src_files_info, src_dirs_info = \
        __get_files_and_dirs_info(src, rel_path_elements, ignored_list)

    dst_files_info, dst_dirs_info = \
        __get_files_and_dirs_info(dst, rel_path_elements, ignored_list)

    __transfer_files(dst, rel_path_elements, src_files_info, dst_files_info)
    __create_dirs(dst, rel_path_elements, src_dirs_info, dst_dirs_info)
    __delete_files(dst, rel_path_elements, src_files_info, dst_files_info)
    __delete_dirs(dst, rel_path_elements, src_dirs_info, dst_dirs_info)
    return src_dirs_info.keys()


def __copy_diff_one_dir_and_get_dirs(src, dst, rel_path_elements,
                                     is_need_delete=False):

    ignored_list = src.get_ignored_list()

    src_files_info, src_dirs_info = \
        __get_files_and_dirs_info(src, rel_path_elements, ignored_list)

    dst_files_info, dst_dirs_info = \
        __get_files_and_dirs_info(dst, rel_path_elements, ignored_list)

    __transfer_files(dst, rel_path_elements, src_files_info, dst_files_info)
    __create_dirs(dst, rel_path_elements, src_dirs_info, dst_dirs_info)

    if is_need_delete:
        __delete_files(dst, rel_path_elements, src_files_info, dst_files_info)
        __delete_dirs(dst, rel_path_elements, src_dirs_info, dst_dirs_info)

    return src_dirs_info.keys()


def __sync_simp_without_tree(src, dst, rel_path_elements):
    """Sync all files and directories from src to dst"""

    dir_list = __sync_one_dir_and_get_dirs(src, dst, rel_path_elements)
    for dir_name in dir_list:
        try:
            __sync_simp_without_tree(src, dst,
                                     rel_path_elements + [dir_name])
        except NonSupportedFileError, ins:
            dst.logging_for_err_skip([ins.path], "")
        except NoEntryError, ins:
            dst.logging_for_err_skip([ins.path], "")
    return

def __copy_diff_without_tree(src, dst, rel_path_elements,
                             is_need_delete=False):
    """Copy all of diff files and directories from src to dst"""

    dir_list = __copy_diff_one_dir_and_get_dirs(src, dst, rel_path_elements,
                                                is_need_delete)
    for dir_name in dir_list:
        try:
            __copy_diff_without_tree(src, dst,
                                     rel_path_elements + [dir_name],
                                     is_need_delete)
        except NonSupportedFileError, ins:
            dst.logging_for_err_skip([ins.path], "")
        except NoEntryError, ins:
            dst.logging_for_err_skip([ins.path], "")
    return


def __copy_one_dir_and_get_dirs(src, dst, rel_path_elements,
                                is_need_delete=False):
    """Copy one directory.
       And return directries list that are in the specified directory.
    """
    ignored_list = src.get_ignored_list()

    src_files_info, src_dirs_info = \
        __get_files_and_dirs_info(src, rel_path_elements, ignored_list)

    if is_need_delete:
        dst_files_info, dst_dirs_info = \
            __get_files_and_dirs_info(dst, rel_path_elements, ignored_list)

    # Transfer Files
    transfer_files_info = {}
    for src_file_name, info in src_files_info.iteritems():
        transfer_files_info.update({src_file_name: info})
        transfer_files_info[src_file_name][STATE_NAME] = STATE_NEW
    dst.transfer_files(rel_path_elements, transfer_files_info)

    # Create Directorys
    create_dirs_info = {}
    for src_dir_name, info in src_dirs_info.iteritems():
        create_dirs_info.update({src_dir_name: info})
        create_dirs_info[src_dir_name][STATE_NAME] = STATE_NEW
    dst.create_dirs(rel_path_elements, create_dirs_info)

    if is_need_delete:
        __delete_files(dst, rel_path_elements, src_files_info, dst_files_info)
        __delete_dirs(dst, rel_path_elements, src_dirs_info, dst_dirs_info)

    return src_dirs_info.keys()


def __copy_without_tree(src, dst, rel_path_elements, is_need_delete=False):
    """Sync all files and directories from src to dst"""

    dir_list = __copy_one_dir_and_get_dirs(src, dst, rel_path_elements,
                                           is_need_delete=is_need_delete)
    for dir_name in dir_list:
        try:
            __copy_without_tree(src, dst,
                                rel_path_elements + [dir_name],
                                is_need_delete=is_need_delete)
        except NonSupportedFileError, ins:
            dst.logging_for_err_skip([ins.path], "")
        except NoEntryError, ins:
            dst.logging_for_err_skip([ins.path], "")
    return


def get_init_tree():

    return {DIRS_NAME: {}, FILES_NAME: {}}


def get_new_tree(tree):

    return __get_new_tree(tree)


def get_same_tree(tree):

    return __get_same_tree(tree)


def set_copy_tree(src):

    src.tree = src.get_tree()
    __set_new_state(src.tree)


def set_update_copy_tree(src):

    is_updated = False

    if not src.tree:
        is_updated = True
        src.tree = src.get_tree()
        __set_new_state(src.tree)
    else:
        if src.set_delta_tree():
            is_updated = True

    return is_updated


def get_sync_dup_tree(src_tree, dst_tree):
    if not src_tree:
        src_tree = get_init_tree()
    if not dst_tree:
        dst_tree = get_init_tree()
    src_tree, dst_tree = __get_sync_dup_tree(src_tree, dst_tree)
    dst_tree, src_tree = __get_sync_dup_tree(dst_tree, src_tree)
    return (src_tree, dst_tree)


def get_sync_dup_tree_distrust_new(src_tree, dst_tree):
    if not src_tree:
        src_tree = get_init_tree()
    if not dst_tree:
        dst_tree = get_init_tree()
    src_tree, dst_tree = _get_sync_dup_tree_distrust_new(
        src_tree, dst_tree)
    dst_tree, src_tree = _get_sync_dup_tree_distrust_new(
        dst_tree, src_tree, reverse=True)
    return (src_tree, dst_tree)


def sync_simp(src, dst):
    src_tree = get_new_tree(src.get_tree())
    dst_tree = get_new_tree(dst.get_tree())
    src_tree = get_sync_simp_tree(src_tree, dst_tree)
    dst.update(src, src_tree)


def sync_simp_without_tree(src, dst):
    dst.init_non_tree_param(src)
    __sync_simp_without_tree(src, dst, [])


def copy(src, dst):
    src_tree = get_new_tree(src.get_tree())
    dst.update(src, src_tree)


def copy_without_tree(src, dst, is_need_delete=False):
    dst.init_non_tree_param(src)
    __copy_without_tree(src, dst, [], is_need_delete)


def copy_diff_without_tree(src, dst, is_need_delete=False):
    dst.init_non_tree_param(src)
    __copy_diff_without_tree(src, dst, [], is_need_delete)

