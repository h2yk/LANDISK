#!/usr/bin/env python
# -*- mode: landisk-python; coding: utf-8; -*-
# vim:ts=4 sw=4 sts=4 ai si et sta

from __future__ import with_statement

from ..fileaccess import (MODE_READ, MODE_WRITE, MODE_APPEND,
    ST_MODE_DIR, ST_MODE_FILE, DEFAULT_LOCALE, DEBUG)
from ionas.exception import *
from filelikeobj import FileLikeObj


import os
import sys
import stat
import shutil
import errno
import locale

BUF_SIZE = 65536

ROOT_UID = 0
ROOT_GID = 0

CHMOD_NORMAL = 1
CHMOD_CREATE_FILE = 2
CHMOD_UPPER_DIR = 3
CHMOD_RECURSIVE = 4
CHMOD_MOVE = 5


def root_perm_retry(func, path, arg):
    try:
        func(path, arg)
    except (IOError, OSError), exc_ins:
        if exc_ins.errno != errno.EACCES and exc_ins.errno != errno.EPERM:
            raise exc_ins
        pre_uid = os.geteuid()
        pre_gid = os.getegid()
        os.setegid(ROOT_GID)
        os.seteuid(ROOT_UID)
        try:
            func(path, arg)
        finally:
            os.setegid(pre_gid)
            os.seteuid(pre_uid)


def copystat(src, dst):
    st = os.stat(src)
    mode = stat.S_IMODE(st.st_mode)

    if hasattr(os, 'utime'):
        root_perm_retry(os.utime, dst, (st.st_atime, st.st_mtime))
    if hasattr(os, 'chmod'):
        root_perm_retry(os.chmod, dst, mode)


"""
shutilのmove内などで使われるcopystatは
dstの所有者がprocessユーザーと異なる場合、
permission errとなるので、
一時的にrootとなり対処するよう
shutilのcopystatをオーバーライドする
"""
shutil.copystat = copystat


def local_except_handler(exc_ins, path):
    if exc_ins.errno == errno.EACCES or exc_ins.errno == errno.EPERM:
        raise PermissionError(exc_ins, path)
    if exc_ins.errno == errno.ENOSPC or exc_ins.errno == errno.EDQUOT:
        raise NoSpaceError(exc_ins, path)
    if exc_ins.errno == errno.ENOENT:
        raise NoEntryError(exc_ins, path)
    if exc_ins.errno == errno.EEXIST:
        raise ExistsError(exc_ins, path)
    if exc_ins.errno == errno.ENAMETOOLONG:
        raise NameTooLongError(exc_ins, path)
    raise exc_ins, None, sys.exc_info()[2]


class LocalFileObj(FileLikeObj):

    # COMMENT boto(Amazon S3)のset_contents_from_file()で必要
    def __len__(self):

        return int(os.fstat(self.file.fileno()).st_size)

    # COMMENT boto(Amazon S3)のset_contents_from_file()で必要
    def tell(self):

        return self.file.tell()

    # COMMENT boto(Amazon S3)のset_contents_from_file()で必要
    def seek(self, offset, whence=os.SEEK_SET):

        self.file.seek(offset, whence)

    def get_path(self):

        return self.path

    def get_size(self):

        return os.fstat(self.file.fileno()).st_size

    def get_stat(self):

        return os.fstat(self.file.fileno())

    def read(self, size):

        try:
            return self.file.read(size)
        except (IOError, OSError), err:
            local_except_handler(err, self.path)

    def write(self, file_like):

        while True:
            buf = file_like.read(BUF_SIZE)
            if not buf:
                break
            try:
                self.file.write(buf)
            except (IOError, OSError), err:
                local_except_handler(err, self.path)

    def close(self):

        try:
            self.file.close()
        except (IOError, OSError), err:
            local_except_handler(err, self.path)


# COMMENT システムにてos.listdir()などで
# とれる文字列はutf-8として限定し,
# 内部ツリーにはutf-8として保持する。
class LocalAccess():

    def __init__(self, encoding="", ctime=True):
        self.sep = "/"

        if encoding:
            self.encoding = encoding
        else:
            self.encoding = locale.getdefaultlocale()[1]
            if not self.encoding:
                self.encoding = DEFAULT_LOCALE

        self.ctime = ctime

    def __chmod_for_before_retry(self, path, arg, chmod_type):

        FULL_ACCESS_FILE_MODE = stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR | \
                                stat.S_IRGRP | stat.S_IWGRP | stat.S_IXGRP | \
                                stat.S_IROTH | stat.S_IWOTH | stat.S_IXOTH

        if chmod_type == CHMOD_NORMAL:
            self.chmod(path, FULL_ACCESS_FILE_MODE)

        if chmod_type == CHMOD_CREATE_FILE:
            if os.path.exists(path):
                self.chmod(os.path.dirname(path), FULL_ACCESS_FILE_MODE)
                self.chmod(path, FULL_ACCESS_FILE_MODE)
            else:
                self.chmod(os.path.dirname(path), FULL_ACCESS_FILE_MODE)

        elif chmod_type == CHMOD_UPPER_DIR:
            self.chmod(os.path.dirname(path), FULL_ACCESS_FILE_MODE)

        elif chmod_type == CHMOD_RECURSIVE:
            self.chmod(path, FULL_ACCESS_FILE_MODE, is_recursive=True)

        elif chmod_type == CHMOD_MOVE:
            self.chmod(path, FULL_ACCESS_FILE_MODE, is_recursive=True)
            if os.path.exists(arg):
                self.chmod(os.path.dirname(arg), FULL_ACCESS_FILE_MODE,
                           is_recursive=True)
                self.chmod(arg, FULL_ACCESS_FILE_MODE, is_recursive=True)
            else:
                self.chmod(os.path.dirname(arg), FULL_ACCESS_FILE_MODE,
                           is_recursive=True)
        return

    def __exec_with_chmod_retry(self, func, path, arg=None,
                                chmod_type=CHMOD_NORMAL):
        try:
            return func(path) if arg is None else func(path, arg)
        except (IOError, OSError), exc_ins:
            if exc_ins.errno != errno.EACCES and exc_ins.errno != errno.EPERM:
                raise exc_ins
            self.__chmod_for_before_retry(path, arg, chmod_type)
            return func(path) if arg is None else func(path, arg)

    def listdir(self, path):
        try:
            return self.__exec_with_chmod_retry(os.listdir, path)
        except (IOError, OSError), err:
            local_except_handler(err, path)

    def __open(self, path, mode):

        if mode == MODE_READ:
            return LocalFileObj(open(path, "r"), path)
        elif mode == MODE_WRITE:
            return LocalFileObj(open(path, "w"), path)
        elif mode == MODE_APPEND:
            return LocalFileObj(open(path, "a"), path)

    def open(self, path, mode):

        try:
            if mode == MODE_READ:
                return self.__exec_with_chmod_retry(self.__open, path, mode)
            else:
                return self.__exec_with_chmod_retry(self.__open, path, mode,
                                                chmod_type=CHMOD_CREATE_FILE)
        except (IOError, OSError), err:
            local_except_handler(err, path)

    def mkdir(self, path):

        try:
            return self.__exec_with_chmod_retry(os.mkdir, path,
                                                chmod_type=CHMOD_UPPER_DIR)

        except (IOError, OSError), err:
            local_except_handler(err, path)

    def __stat(self, path, ctime=None):
        if ctime == None:
            ctime = self.ctime

        try:
            status = os.stat(path)
            # COMMENT
            # CTIMEをMTIMEとして返す。
            # 次回初期同期前にfileやdirをrenameされた場合に
            # rename時刻を取得するため
            if ctime:
                time_stat = status[stat.ST_CTIME]
            else:
                time_stat = status[stat.ST_MTIME]

            return {
                stat.ST_MODE: status[stat.ST_MODE],
                stat.ST_MTIME: time_stat,
                stat.ST_SIZE: status[stat.ST_SIZE]}
        except (IOError, OSError), err:
            local_except_handler(err, path)

    def stat(self, path, ctime=None):

        try:
            return self.__exec_with_chmod_retry(self.__stat, path, ctime)
        except (IOError, OSError), err:
            local_except_handler(err, path)

    def chmod(self, path, mode, is_recursive=False):
        try:
            root_perm_retry(os.chmod, path, mode)

            if is_recursive and os.path.isdir(path):
                for dir_name in os.listdir(path):
                    self.chmod(os.path.join(path, dir_name), mode)

        except (IOError, OSError), err:
            local_except_handler(err, path)

    def utime(self, path, mtime):
        try:
            if not mtime and mtime != 0:
                raise InternalError
            root_perm_retry(os.utime, path, (mtime, mtime))
        except (IOError, OSError), err:
            local_except_handler(err, path)

    def remove(self, path):
        try:
            return self.__exec_with_chmod_retry(os.remove, path)
        except (IOError, OSError), err:
            local_except_handler(err, path)

    def rmdir(self, path):

        try:
            return self.__exec_with_chmod_retry(shutil.rmtree, path,
                                                chmod_type=CHMOD_RECURSIVE)
        except (IOError, OSError), err:
            local_except_handler(err, path)

    def move(self, src, dst):

        try:
            return self.__exec_with_chmod_retry(shutil.move, src, dst,
                                                chmod_type=CHMOD_MOVE)
        except (IOError, OSError), err:
            local_except_handler(err, src)

    def link(self, src, link_name):

        if os.path.isdir(src):
            raise ExistsError(detail=None, path=src)

        try:
            return self.__exec_with_chmod_retry(os.link, src, link_name,
                                                chmod_type=CHMOD_MOVE)
        except (IOError, OSError), err:
            local_except_handler(err, src)

    def makedirs(self, path):

        try:
            return self.__exec_with_chmod_retry(os.makedirs, path,
                                                chmod_type=CHMOD_UPPER_DIR)
        except (IOError, OSError), err:
            local_except_handler(err, path)
