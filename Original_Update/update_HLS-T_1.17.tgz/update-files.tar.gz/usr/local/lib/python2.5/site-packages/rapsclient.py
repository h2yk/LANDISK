#!/usr/bin/env python
# -*- mode: landisk-python; coding: utf-8; -*-
# vim:ts=4 sw=4 sts=4 ai si et sta
from __future__ import with_statement

import httplib
import os
import sys
import codecs
import StringIO
import urllib
import urllib2
import socket
import subprocess
import datetime
import traceback as tb

from xml.etree import cElementTree as ET

header_content_type = "Content-Type"
header_content_length = "Content-Length"

separator = codecs.BOM_BE + "\r\n"

STATUS_OK = 200

defaultencode = 'UTF-8'
defaultdeclare = True

READ_BUF_SIZE = 65536

RESULT_INVALID_SESSION_ID = 6

### for RL3
import touclient
import time

CommHTTPS = touclient.CLibEnum.CommunicationType.CommunicationType_HTTPS
CommHTTP = touclient.CLibEnum.CommunicationType.CommunicationType_HTTP
EncNONE = touclient.CLibEnum.EncryptionScheme.EncryptionScheme_NONE

CB_CHK_INTERVAL = 1
CB_CHK_NUM = 120

TOU_SERVER_ADDR = "127.0.0.1"
CENTER_SERVER_HTTP_PORT = 80
CENTER_SERVER_HTTPS_PORT = 443
CENTER_SERVER_ADDR = "rlcslb.iodata.jp"
STUN_SERVER_ADDR = "rlstun.iodata.jp"
STUN_SERVER_PORT = 3478
INIT_RESULT_CODE = -1
INIT_ERR_CODE = -1

SUCCESS_LIST = [touclient.CLibConstats.CLIB_ST_STANDBY]
INTERNET_OFFLINE_ERR_LIST = [touclient.CLibConstats.CLIB_ERR_STUN,
                             touclient.CLibConstats.CLIB_ERR_BROKER,
                             touclient.CLibConstats.CLIB_ERR_BROKER_GET_ROUTE]
P2P_ERR_LIST = [touclient.CLibConstats.CLIB_ERR_P2P,
                touclient.CLibConstats.CLIB_ERR_BROKER_CONNECT_P2P]
ERR_LIST = INTERNET_OFFLINE_ERR_LIST + P2P_ERR_LIST
RESULT_LIST = SUCCESS_LIST + ERR_LIST

HDL_FIND_CMD = ["/usr/local/bin/HDLFind", "-f"]
HDL_FIND_FILE = "/var/tmp/HDLFind.txt"

PINCODE_CGI_URL_FMT = "http://%s/rl3/pincode.cgi"
CHK_CUR_VAL_BASE = {"command": "check_current", "pincode": ""}

KIND_IDX = 0
OS_IDX = 1
OTHER_IDX = 2
### // for RL3


# lv 0: 出力なし
# lv 1: XML(request/response)出力なし
# lv 2: XML(request/response)出力あり
debug_lv = 0
debug_path = "/mnt/hda5/log/rapsclient_debug"

def set_debug_lv(lv=0):
    global debug_lv
    debug_lv = lv


def set_debug_path(path):
    global debug_path
    debug_path = path


def debug(output_obj):
    if not debug_lv:
        return

    try:
        if debug_lv == 1:
            # XMLは出力しない

            if ET.iselement(output_obj):
                return
            if isinstance(output_obj, str):
                if output_obj.startswith("<"):
                    return

        if ET.iselement(output_obj):
            output_obj = __indent(output_obj)

        with open(debug_path, "a") as debug_file:
            debug_file.write(str(datetime.datetime.now()) + "# ")
            end = "\n"
            if isinstance(output_obj, str):
                if output_obj.endswith("\n"):
                    end = ""
            debug_file.write(str(output_obj) + end)
    except:
        """
        先にdebug_pathのpermを666以上にしておかないと
        debug_pathへのwriteが
        PermissionErrorになる場合があるので注意
        """
        pass


class Accesser:
    # xmlとして受けとった情報を
    # pythonでアクセスしやすくしたもの
    pass

TAG_PRE = "t_"
ATTR_PRE = "a_"
LIST_PRE = "l_"
TEXT_NAME = "text"


def raise_(exc_ins=None):
    exc, val, trace = sys.exc_info()
    if exc_ins:
        exc = exc_ins.__class__
        val = exc_ins
    raise exc, val, trace


def is_dir(file_ac):
    if (hasattr(file_ac, "a_isdir") and
        getattr(file_ac, "a_isdir") == "true"):
        return True
    return False


def xml_to_ac(xml, ac=None):
    if not ac:
        ac = Accesser()

    tag_name = TAG_PRE + xml.tag
    tag_list_name = LIST_PRE + xml.tag
    text = xml.text if xml.text != None else ""

    if not hasattr(ac, tag_list_name):
        setattr(ac, tag_list_name, [])
    tag_list = getattr(ac, tag_list_name)
    tag_list.append(Accesser())

    tag = tag_list[-1]

    setattr(tag, TEXT_NAME, text)
    setattr(ac, tag_name, tag_list[0])

    for attr, val in xml.items():
        attr_name = ATTR_PRE + attr
        setattr(tag, attr_name, val)

    for sub_tag in list(xml):
        xml_to_ac(sub_tag, tag)

    return ac


# separate method
def get_xml(xmlwithdata):
    xml = ''
    rawbuf = StringIO.StringIO(xmlwithdata)
    while True:
        line = rawbuf.readline()
        if not line:
            break
        if line.endswith(separator):
            xml += line.replace(separator, "")
            break
        xml += line
    return xml


def get_data(xmlwithdata):
    data = ''
    rawbuf = StringIO.StringIO(xmlwithdata)
    while True:
        line = rawbuf.readline()
        if not line:
            break
        if line.endswith(separator):
            break
    data = rawbuf.read()
    return data


def find_first_element_by_tag(element, tag):
    if element.tag == tag:
        return element
    for subelement in list(element):
        found = find_first_element_by_tag(subelement, tag)
        if found != None:
            return found
    return None


def get_attrib(element, tag, attrib):
    value = None
    element = find_first_element_by_tag(element, tag)
    if element != None:
        value = element.get(attrib, None)
    if value == None:
        value = ''
    return value


def get_text(xml, tag):
    value = None
    xml = get_xml(xml)
    element = ET.fromstring(xml)
    element = find_first_element_by_tag(element, tag)
    if element != None:
        value = element.text
    if value == None:
        value = ''
    return value


def __request_xmldec(element_xml,
        xmlencode=defaultencode, xmldeclare=defaultdeclare):
    xml = u''
    encoding = xmlencode
    encode = xmlencode
    bom = ''
    if xmlencode == 'UTF-16(LEBOM)':
        encoding = 'UTF-16'
        encode = 'UTF-16LE'
        bom = codecs.BOM_LE
    elif xmlencode == 'UTF-16(BEBOM)':
        encoding = 'UTF-16'
        encode = 'UTF-16BE'
        bom = codecs.BOM_BE
    elif xmlencode == 'UTF-16LE(BOM)':
        encoding = 'UTF-16LE'
        encode = 'UTF-16LE'
        bom = codecs.BOM_LE
    elif xmlencode == 'UTF-16BE(BOM)':
        encoding = 'UTF-16BE'
        encode = 'UTF-16BE'
        bom = codecs.BOM_BE
    if xmldeclare:
        xml += '<?xml version="1.0" encoding="' + encoding + \
            '" standalone="yes"?>\n'
    xml += ET.tostring(element_xml, 'utf-8').decode('utf-8')
    xml = bom + xml.encode(encode)
    return xml


def __indent(elem, level=0):
    i = "\n" + level * "  "
    if len(elem):
        if not elem.text or not elem.text.strip():
            elem.text = i + "  "
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
        for elem in elem:
            __indent(elem, level + 1)
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
    else:
        if level and (not elem.tail or not elem.tail.strip()):
            elem.tail = i
    if level == 0:
        elem.tail = "\n"


# request xml
def _request_getinfo(xmlencode=defaultencode, xmldeclare=defaultdeclare):
    element_request = ET.Element('request')
    element_request.set('type', 'getinfo')
    return __request_xmldec(element_request, xmlencode, xmldeclare)


def _request_auth(name, password, clientid,
                   xmlencode=defaultencode, xmldeclare=defaultdeclare):
    element_request = ET.Element('request')
    element_request.set('type', 'auth')
    element_user = ET.Element('user')
    element_name = ET.Element('name')
    element_name.text = name
    element_user.append(element_name)
    element_password = ET.Element('password')
    element_password.text = password
    element_user.append(element_password)
    element_clientid = ET.Element('clientid')
    element_clientid.text = clientid
    element_user.append(element_clientid)
    element_request.append(element_user)
    return __request_xmldec(element_request, xmlencode, xmldeclare)


def _request_disconnect(session,
                         xmlencode=defaultencode, xmldeclare=defaultdeclare):
    element_request = ET.Element('request')
    element_request.set('type', 'disconnect')
    element_request.set('session', session)
    return __request_xmldec(element_request, xmlencode, xmldeclare)


def _request_getsharelist(session, xmlencode=defaultencode,
                           xmldeclare=defaultdeclare):
    element_request = ET.Element('request')
    element_request.set('type', 'getsharelist')
    element_request.set('session', session)
    return __request_xmldec(element_request, xmlencode, xmldeclare)


def _request_getdir(session, path, index=None,
                     maxnum=None, regex=None, sort=None,
                     item=[], precision=None,
                     xmlencode=defaultencode, xmldeclare=defaultdeclare):
    element_request = ET.Element('request')
    element_request.set('type', 'getdir')
    element_request.set('session', session)
    element_path = ET.Element('path')
    element_path.text = path
    element_request.append(element_path)
    if (index or maxnum or regex or sort or item or precision):
        element_option = ET.Element('option')
        if index:
            element_option.set('index', index)
        if maxnum:
            element_option.set('maxnum', maxnum)
        if regex:
            element_option.set('regex', regex)
        if sort:
            element_option.set('sort', sort)
        if item or precision:
            element_statitemlist = ET.Element('statitemlist')
            if precision:
                element_item = ET.Element('item')
                element_item.set('precision', precision)
                element_item.text = 'mtime'
                element_statitemlist.append(element_item)
            for it in item:
                element_item = ET.Element('item')
                element_item.text = it
                element_statitemlist.append(element_item)
            element_option.append(element_statitemlist)
        element_request.append(element_option)
    return __request_xmldec(element_request, xmlencode, xmldeclare)


def _request_find(session, path, index=None, maxnum=None,
                   regex=None, sort=None,
                   item=[], precision=None,
                   xmlencode=defaultencode, xmldeclare=defaultdeclare):
    element_request = ET.Element('request')
    element_request.set('type', 'find')
    element_request.set('session', session)
    element_path = ET.Element('path')
    element_path.text = path
    element_request.append(element_path)
    if (index or maxnum or regex or sort or item or precision):
        element_option = ET.Element('option')
        if index:
            element_option.set('index', index)
        if maxnum:
            element_option.set('maxnum', maxnum)
        if regex:
            element_option.set('regex', regex)
        if sort:
            element_option.set('sort', sort)
        if item or precision:
            element_statitemlist = ET.Element('statitemlist')
            if precision:
                element_item = ET.Element('item')
                element_item.set('precision', precision)
                element_item.text = 'mtime'
                element_statitemlist.append(element_item)
            for it in item:
                element_item = ET.Element('item')
                element_item.text = it
                element_statitemlist.append(element_item)
            element_option.append(element_statitemlist)
        element_request.append(element_option)
    return __request_xmldec(element_request, xmlencode, xmldeclare)


def _request_mkdir(session, path,
                    xmlencode=defaultencode, xmldeclare=defaultdeclare):
    element_request = ET.Element('request')
    element_request.set('type', 'mkdir')
    element_request.set('session', session)
    element_path = ET.Element('path')
    element_path.text = path
    element_request.append(element_path)
    return __request_xmldec(element_request, xmlencode, xmldeclare)


def _request_getmminfo(session, path,
                        xmlencode=defaultencode, xmldeclare=defaultdeclare):
    element_request = ET.Element('request')
    element_request.set('type', 'getmminfo')
    element_request.set('session', session)
    element_path = ET.Element('path')
    element_path.text = path
    element_request.append(element_path)
    return __request_xmldec(element_request, xmlencode, xmldeclare)


def _request_copy(session, path, path_dest,
                   xmlencode=defaultencode, xmldeclare=defaultdeclare):
    element_request = ET.Element('request')
    element_request.set('type', 'copy')
    element_request.set('session', session)
    element_path = ET.Element('path')
    element_path.text = path
    element_request.append(element_path)
    element_path_dest = ET.Element('path')
    element_path_dest.set('dest', 'true')
    element_path_dest.text = path_dest
    element_request.append(element_path_dest)
    return __request_xmldec(element_request, xmlencode, xmldeclare)


def _request_move(session, path, path_dest,
                   xmlencode=defaultencode, xmldeclare=defaultdeclare):
    element_request = ET.Element('request')
    element_request.set('type', 'move')
    element_request.set('session', session)
    element_path = ET.Element('path')
    element_path.text = path
    element_request.append(element_path)
    element_path_dest = ET.Element('path')
    element_path_dest.set('dest', 'true')
    element_path_dest.text = path_dest
    element_request.append(element_path_dest)
    return __request_xmldec(element_request, xmlencode, xmldeclare)


def _request_delete(session, path,
                     xmlencode=defaultencode, xmldeclare=defaultdeclare):
    element_request = ET.Element('request')
    element_request.set('type', 'delete')
    element_request.set('session', session)
    element_path = ET.Element('path')
    element_path.text = path
    element_request.append(element_path)
    return __request_xmldec(element_request, xmlencode, xmldeclare)


def _request_download(session, path, offset=None, maxsize=None,
                       xmlencode=defaultencode, xmldeclare=defaultdeclare):
    element_request = ET.Element('request')
    element_request.set('type', 'download')
    element_request.set('session', session)
    element_path = ET.Element('path')
    element_path.text = path
    element_request.append(element_path)
    if offset or maxsize:
        element_option = ET.Element('option')
        if offset:
            element_option.set('offset', str(offset))
        if maxsize:
            element_option.set('maxsize', str(maxsize))
        element_request.append(element_option)
    return __request_xmldec(element_request, xmlencode, xmldeclare)


def _request_upload(session, path, addlen,
                     offset=None, mtime=None, overwrite=None,
                     xmlencode=defaultencode, xmldeclare=defaultdeclare):
    element_request = ET.Element('request')
    element_request.set('type', 'upload')
    element_request.set('session', session)
    element_request.set('addlen', str(addlen))
    element_path = ET.Element('path')
    element_path.text = path
    element_request.append(element_path)
    if offset or mtime or overwrite:
        element_option = ET.Element('option')
        if offset:
            element_option.set('offset', str(offset))
        if mtime:
            element_option.set('mtime', mtime)
        if overwrite:
            element_option.set('overwrite', str(overwrite))
        element_request.append(element_option)
    return __request_xmldec(element_request, xmlencode, xmldeclare)


def _request_geturl(session, path, protocol=None, expire=None,
                     xmlencode=defaultencode, xmldeclare=defaultdeclare):
    element_request = ET.Element('request')
    element_request.set('type', 'geturl')
    element_request.set('session', session)
    element_path = ET.Element('path')
    element_path.text = path
    element_request.append(element_path)
    if protocol or expire:
        element_option = ET.Element('option')
        if protocol:
            element_option.set('protocol', protocol)
        if expire:
            element_option.set('expire', expire)
        element_request.append(element_option)
    return __request_xmldec(element_request, xmlencode, xmldeclare)


def _request_disableurl(session, url,
                         xmlencode=defaultencode, xmldeclare=defaultdeclare):
    element_request = ET.Element('request')
    element_request.set('type', 'disableurl')
    element_request.set('session', session)
    element_url = ET.Element('url')
    element_url.text = url
    element_request.append(element_url)
    return __request_xmldec(element_request, xmlencode, xmldeclare)


class RapsError(Exception):

    def __init__(self, status=None, http_status=None, invalid_response=False):
        self.status = status
        self.http_status = http_status
        self.invalid_response = invalid_response
        super(RapsError, self).__init__(", ".join([str(status),
                                                   str(http_status),
                                                   str(invalid_response)]))


class TouError(Exception):

    def __init__(self, result_code=INIT_RESULT_CODE, err_code=INIT_ERR_CODE):
        self.result_code = result_code
        self.err_code = err_code
        super(TouError, self).__init__(", ".join([str(result_code),
                                                  str(err_code)]))


class TouTimeOutError(Exception):

    pass


class TouAllRoutesError(Exception):

    pass


class CheckCurrentPincodeError(Exception):
    pass


class NothingHDLFindInfo(Exception):
    pass


class RapsClient:
    pin = None
    host = None
    port = None
    ssl = True
    user = None
    password = None
    session = None
    term_info = ("", "", "")  # kind, os, other
    xmlencode = defaultencode
    xmldeclare = defaultdeclare
    rl3_enabled = True
    rl3_route = None
    rl3_connected = False
    raps_connected = False
    do_manage_connect = True

    tou = None
    cb = None
    param = None

    http_conn = None

    """
    2015/02/26
    global関数をRapsClientのメソッド化。
    各メソッドの引数とselfのメンバの扱いを
    きれいに整えられていないが、取り急ぎconnインスタンスを
    使いまわすことによる速度UPを実装
    """

    # connect
    def __connect(self, host, port, ssl=True):
        if self.http_conn:
            if self.http_conn.sock:
                # P2Pでは、tcpのkeep-aliveについて
                # 2015/3/5時点でToU仕様上で考慮されていないため
                # tcpのkeep-aliveタイムアウト時の動作に
                # 問題があるので、tcp connectionについては
                # P2Pなら毎回closeしP2P以外なら使いまわす
                if self.rl3_route == "P2P":
                    self.http_conn.close()
                else:
                    return

        if ssl:
            self.http_conn = httplib.HTTPSConnection(host, port)
        else:
            self.http_conn = httplib.HTTPConnection(host, port)

    # request
    def __request(self, host, port, ssl, xml, data=None, datalen=None):
        contentlength = len(xml)
        if datalen:
            contentlength += (len(separator) + datalen)
        method = "POST"
        uri = "/raps/api.cgi"
        header = {header_content_type: "text/html",
                  header_content_length: contentlength}
        self.__connect(host, port, ssl)
        try:
            self.http_conn.request(method, uri, xml, header)
            debug(xml)
            if data:
                self.http_conn.send(separator)
                if hasattr(data, 'read'):
                    sendbuffersize = 65536
                    senddatalen = 0
                    while senddatalen < datalen:
                        remainingdatalen = datalen - senddatalen
                        if remainingdatalen < sendbuffersize:
                            sendbuffersize = remainingdatalen
                        sendbuffer = data.read(sendbuffersize)
                        self.http_conn.send(sendbuffer)
                        senddatalen += sendbuffersize
                else:
                    self.http_conn.send(data)
            return self.http_conn
        except:
            self.http_conn.close()
            raise_()
    
    # request api
    def request_getinfo(self, host, port, ssl,
            xmlencode=defaultencode, xmldeclare=defaultdeclare):
        xml = _request_getinfo(xmlencode, xmldeclare)
        return self.__request(host, port, ssl, xml)
    
    def request_auth(self, host, port, ssl, user, password, clientid,
            xmlencode=defaultencode, xmldeclare=defaultdeclare):
        xml = _request_auth(user, password, clientid, xmlencode, xmldeclare)
        return self.__request(host, port, ssl, xml)
    
    def request_disconnect(self, host, port, ssl, session,
            xmlencode=defaultencode, xmldeclare=defaultdeclare):
        xml = _request_disconnect(session, xmlencode, xmldeclare)
        return self.__request(host, port, ssl, xml)
    
    def request_getsharelist(self, host, port, ssl, session,
            xmlencode=defaultencode, xmldeclare=defaultdeclare):
        xml = _request_getsharelist(session, xmlencode, xmldeclare)
        return self.__request(host, port, ssl, xml)
    
    def request_getdir(self, host, port, ssl, session, path,
                       index=None, maxnum=None, regex=None,
            sort=None, item=[], precision=None,
            xmlencode=defaultencode, xmldeclare=defaultdeclare):
        xml = _request_getdir(session, path, index, maxnum,
                               regex, sort, item, precision,
                      xmlencode, xmldeclare)
        return self.__request(host, port, ssl, xml)
    
    def request_find(self, host, port, ssl, session, path,
                     index=None, maxnum=None, regex=None,
            sort=None, item=[], precision=None,
            xmlencode=defaultencode, xmldeclare=defaultdeclare):
        xml = _request_find(session, path, index, maxnum,
                             regex, sort, item, precision,
                  xmlencode, xmldeclare)
        return self.__request(host, port, ssl, xml)
    
    def request_mkdir(self, host, port, ssl, session, path,
            xmlencode=defaultencode, xmldeclare=defaultdeclare):
        xml = _request_mkdir(session, path, xmlencode, xmldeclare)
        return self.__request(host, port, ssl, xml)
    
    def request_getmminfo(self, host, port, ssl, session, path,
            xmlencode=defaultencode, xmldeclare=defaultdeclare):
        xml = _request_getmminfo(session, path, xmlencode, xmldeclare)
        return self.__request(host, port, ssl, xml)
    
    def request_copy(self, host, port, ssl, session, path, path_dest,
            xmlencode=defaultencode, xmldeclare=defaultdeclare):
        xml = _request_copy(session, path, path_dest, xmlencode, xmldeclare)
        return self.__request(host, port, ssl, xml)
    
    def request_move(self, host, port, ssl, session, path, path_dest,
            xmlencode=defaultencode, xmldeclare=defaultdeclare):
        xml = _request_move(session, path, path_dest, xmlencode, xmldeclare)
        return self.__request(host, port, ssl, xml)
    
    def request_delete(self, host, port, ssl, session, path,
            xmlencode=defaultencode, xmldeclare=defaultdeclare):
        xml = _request_delete(session, path, xmlencode, xmldeclare)
        return self.__request(host, port, ssl, xml)
    
    def request_download(self, host, port, ssl, session, path, offset=None, maxsize=None,
            xmlencode=defaultencode, xmldeclare=defaultdeclare):
        xml = _request_download(session, path, offset,
                                 maxsize, xmlencode, xmldeclare)
        return self.__request(host, port, ssl, xml)
    
    def request_upload(self, host, port, ssl, session, path, data, addlen, offset=None,
            mtime=None, overwrite=None,
            xmlencode=defaultencode, xmldeclare=defaultdeclare):
        xml = _request_upload(session, path, addlen, offset, mtime, overwrite,
                  xmlencode, xmldeclare)
        return self.__request(host, port, ssl, xml, data, addlen)
    
    def request_geturl(self, host, port, ssl, session, path, protocol=None, expire=None,
            xmlencode=defaultencode, xmldeclare=defaultdeclare):
        xml = _request_geturl(session, path, protocol,
                               expire, xmlencode, xmldeclare)
        return self.__request(host, port, ssl, xml)
    
    def request_disableurl(self, host, port, ssl, session, url,
            xmlencode=defaultencode, xmldeclare=defaultdeclare):
        xml = _request_disableurl(session, url, xmlencode, xmldeclare)
        return self.__request(host, port, ssl, xml)

    def __response_read(self, response, download_file=None):
        xmlwithdata = ''
        if not download_file:
            return response.read()

        # getmminfoやdownloadの際、
        # body内部でxmlとdataが分かれている。
        # response.read毎にget_data()を
        # 実行しているのが非効率だが、
        # getmminfoやdownloadの際の
        # xml部分は小さいのでOK
        while True:
            readbuffer = response.read(READ_BUF_SIZE)
            if not readbuffer:
                break
            xmlwithdata += readbuffer
            readdata = get_data(xmlwithdata)
            if len(readdata):
                break

        xml = get_xml(xmlwithdata)

        download_file.write(readdata)
        while True:
            readbuffer = response.read(READ_BUF_SIZE)
            if not readbuffer:
                break
            download_file.write(readbuffer)

        return xml

    def __check_response(self, element):
        response_result = get_attrib(element, 'response', 'result')
        if not response_result:
            raise RapsError(None, None, True)
        result = int(response_result)
        if result != 0:
            raise RapsError(result)

    def __manage_response(self, conn, file_=None):
        response = conn.getresponse()
        if response.status != STATUS_OK:
            raise RapsError(None, response.status, True)
        xml = self.__response_read(response, file_)
        debug(xml)
        element = ET.fromstring(xml)
        self.__check_response(element)
        return xml_to_ac(element)

    def __del_rl3_obj(self):
        try:
            del self.cb
        except:
            pass
        self.cb = None

        try:
            del self.param
        except:
            pass
        self.param = None

        try:
            del self.tou
        except:
            pass
        self.tou = None

    def __get_cb_result(self):
        for num in range(CB_CHK_NUM):
            result_code = self.cb.getResultCode()
            if result_code in RESULT_LIST:
                return result_code
            time.sleep(CB_CHK_INTERVAL)
        self.rl3_disconnect()
        self.__del_rl3_obj()
        raise TouTimeOutError()

    def __hdl_find(self):
        with open(os.devnull, "wb") as null:
            subprocess.check_call(HDL_FIND_CMD,
                                  stdout=null,
                                  stderr=null)
        return open(HDL_FIND_FILE).readlines()

    def __urlopen(self, url, post_data):
        # py2.5ではurlopenにtimeout引数ないので
        # defaulttimeoutを暫定変更する
        default_timeout_bkup = socket.getdefaulttimeout()
        socket.setdefaulttimeout(10)
        res = urllib2.urlopen(url, post_data)
        socket.setdefaulttimeout(default_timeout_bkup)
        return res

    def __get_port_list(self, ip):
        url = PINCODE_CGI_URL_FMT % ip

        chk_cur_val = CHK_CUR_VAL_BASE.copy()
        chk_cur_val["pincode"] = self.pin
        post_data = urllib.urlencode(chk_cur_val)

        res = self.__urlopen(url, post_data)

        ac = xml_to_ac(ET.fromstring(res.read()))

        if ac.t_response.a_result != "0":
            raise CheckCurrentPincodeError()

        port_list = touclient.intVector()
        port_list.append(int(ac.t_response.a_port_http))
        port_list.append(int(ac.t_response.a_port_https))

        return port_list

    def __internet_offline_process(self):
        debug("internet_offline_process start")

        for find_line in self.__hdl_find():
            ip = find_line.split("\t")[0]
            try:
                port_list = self.__get_port_list(ip)
            except:
                debug("internet_offline_process list err -- ip = %s, tb = %s"\
                      % (ip, tb.format_exc()))
                continue
            else:
                break
        else:
            raise NothingHDLFindInfo()

        debug("ip = %s, port_list = %s" % (
              ip, str([port_list[0], port_list[1]])))

        self.tou.connect(self.pin, ip, port_list)

        result = self.__get_cb_result()

        debug("result = " + str(result))
        debug("err_code = " + str(self.cb.getErrCode()))

        if result in SUCCESS_LIST:
            self.__set_port()
            debug("internet_offline_process ok")
            return True

        debug("internet_offline_process ng")
        self.rl3_disconnect()
        return False

    def __is_directable(self):
        if "DIRECT" in self.routes:
            return True
        return False

    def __try_direct(self):
        debug("try_direct")

        if self.__is_directable():
            debug("is_directable")
            try:
                self.__internet_offline_process()
            except:
                debug("try_direct ng: " + tb.format_exc())
                return False
            return True
        debug("is_not_directable")
        return False

    def __set_port(self):
        if self.ssl:
            self.port = self.cb.getHttpsPort()
        else:
            self.port = self.cb.getHttpPort()

    def __try_getinfo(self):
        debug("try_getinfo start")
        try:
            self.getinfo()
        except:
            debug("try_getinfo ng: " + tb.format_exc())
            return False
        debug("try_getinfo ok")
        return True

    def __do_rl3_connect(self):
        debug("do_rl3_connect start")

        priority = 1

        while True:
            debug("priority = " + str(priority))
            self.cb = touclient.ClientLibCallback()
            self.param.setCallback(self.cb)
            self.param.setPriority(priority)
            self.tou.initialize(self.param)
            self.tou.connect(self.pin)

            result = self.__get_cb_result()
            err = self.cb.getErrCode()

            self.routes = self.cb.getRoutes()

            debug("result = " + str(result))
            debug("err = " + str(err))

            if result in INTERNET_OFFLINE_ERR_LIST:
                debug("connect ng: internet offline")

                self.rl3_disconnect()

                try:
                    self.__internet_offline_process()
                except:
                    raise TouError(result, err)

                self.rl3_route = "DIRECT"
                return

            elif result in P2P_ERR_LIST:
                debug("connect ng: p2p err")
                debug("routes = %s, priority = %s" % (
                      str([route for route in self.routes]),
                      str(priority)))

                self.rl3_disconnect()

                if self.__try_direct():
                    self.rl3_route = "DIRECT"
                    return

                raise TouError(result, err)

            elif result in SUCCESS_LIST:
                debug("connect ok")
                debug("routes = %s, priority = %s" % (
                      str([route for route in self.routes]),
                      str(priority)))

                self.__set_port()

                if self.__try_getinfo():
                    self.rl3_route = self.routes[priority - 1]
                    return

                self.rl3_disconnect()

                if len(self.routes) > priority:
                    debug("try next priority")
                    priority += 1
                    continue

                debug("not try next priority")
                if self.__try_direct():
                    self.rl3_route = "DIRECT"
                    return

                raise TouAllRoutesError()

    def rl3_connect(self):
        if not self.rl3_enabled:
            return

        debug("rl3_connect start")

        if self.ssl:
            comm_type = CommHTTPS
            cs_port = CENTER_SERVER_HTTPS_PORT
        else:
            comm_type = CommHTTP
            cs_port = CENTER_SERVER_HTTP_PORT

        if not self.tou:
            debug("rl3_connect tou obj create")
            self.param = touclient.CLibInitParam()
            self.param.setCenterServerAddr(CENTER_SERVER_ADDR)
            self.param.setCommunicationType(comm_type)
            self.param.setCenterServerPort(cs_port)
            self.param.setStunServerAddr(STUN_SERVER_ADDR)
            self.param.setStunServerPort(STUN_SERVER_PORT)
            self.param.setEncryptionScheme(EncNONE)
            self.param.setTermInfoKind(self.term_info[KIND_IDX])
            self.param.setTermInfoOs(self.term_info[OS_IDX])
            self.param.setTermInfoOther(self.term_info[OTHER_IDX])

            self.tou = touclient.TouClientLibrary()

        self.__do_rl3_connect()

        self.rl3_connected = True

        debug("rl3_connect ok")

    def rl3_disconnect(self):
        if not self.rl3_enabled:
            return

        if self.http_conn:
            self.http_conn.close()

        self.rl3_route = None

        if not self.tou or not self.pin:
            debug("rl3_disconnect no exist objs")
            return

        debug("rl3_disconnect start")

        # touのclose直後のdisconnect時、
        # closeのログがサーバ側のシリアルコンソールに出ない。
        # disconnectでnasdsyncが死ぬ問題と
        # 関係ありそうなので暫定対処として1秒sleep
        time.sleep(1)

        self.tou.disconnect(self.pin)

        # touライブラリ(libtouclient.so)の仕様として
        # disconnect後のconnectまでには3秒待機が必要
        time.sleep(5)

        debug("rl3_disconnect ok")
        self.rl3_connected = False

    def set_rl3(self, pin, ssl=True):
        self.rl3_enabled = True
        self.pin = pin
        self.host = TOU_SERVER_ADDR
        self.port = None
        self.ssl = ssl

    def set_host(self, host, port, ssl=True):
        self.rl3_enabled = False
        self.pin = None
        self.host = host
        self.port = port
        self.ssl = ssl

    def set_auth(self, user, password, clientid):
        self.user = user
        self.password = password
        self.clientid = clientid

    def set_term_info(self, term_info):
        self.term_info = term_info

    def set_xmlencode(self, xmlencode, xmldeclare):
        self.xmlencode = xmlencode
        self.xmldeclare = xmldeclare

    def set_do_manage_connect(self, do_manage_connect):
        self.do_manage_connect = do_manage_connect

    def _is_rl3_session_exc(self, exc):
        if isinstance(exc, (socket.error, socket.sslerror)):
            debug("is_rl3_session_exc")
            return True
        return False

    def _is_raps_session_exc(self, exc):
        if isinstance(exc, RapsError):
            if exc.status == RESULT_INVALID_SESSION_ID:
                debug("is_raps_session_exc")
                return True
        return False

    def set_do_not_manage_connect(self, exc):
        try:
            exc.do_not_manage_connect = True
            debug("set do not manage connect success")
        except:
            pass
        return exc

    def reconnect(self):
        if self.rl3_connected:
            self.rl3_disconnect()
            self.rl3_connect()

        if self.raps_connected:
            try:
                self.raps_disconnect()
            except Exception, exc:
                # 2重raps_disconnectは許す
                if not self._is_raps_session_exc(exc):
                    raise_()
            self.raps_connect()

    # 例外発生時、RL3の経路情報を
    # 例外情報に追加するデコレータメソッド
    def add_rl3_route_to_exc(orig_func):
        def modified_func(self, *args, **kwargs):
            try:
                return orig_func(self, *args, **kwargs)
            except Exception, exc:
                try:
                    exc.rl3_route = self.rl3_route
                except:
                    pass
                raise_(exc)               
        return modified_func

    # アクセス毎にsession, bandleが切れていたら
    # 接続を復旧するデコレータメソッド
    def manage_connect(orig_func):

        def managed_func(self, *args, **kwargs):
            if not self.do_manage_connect:
                return orig_func(self, *args, **kwargs)
            if not self.rl3_connected:
                self.rl3_connect()
            if not self.raps_connected:
                self.raps_connect()

            try:
                return orig_func(self, *args, **kwargs)
            except Exception, exc:
                if hasattr(exc, "do_not_manage_connect"):
                    if exc.do_not_manage_connect:
                        debug("do not manage connect")
                        raise_()

                debug("orig_func exc -- " + tb.format_exc())
                if self._is_raps_session_exc(exc):
                    if self.raps_connected == False:
                        # raps_connectedがFalseで
                        # raps_session例外の場合は、
                        # raps_connectしようとして
                        # できなかったということなので
                        # raiseする
                        raise_()
                    self.raps_connect()
                    return orig_func(self, *args, **kwargs)

                elif self._is_rl3_session_exc(exc):
                    if self.rl3_connected == False:
                        # rl3_connectedがFalseで
                        # rl3_session例外の場合は、
                        # rl3_connectしようとして
                        # できなかったということなので
                        # raiseする
                        raise_()
                    self.reconnect()
                    return orig_func(self, *args, **kwargs)

                else:
                    raise_()

        return managed_func

    @add_rl3_route_to_exc
    def raps_connect(self):
        debug("raps_connect start")

        res = self.__manage_response(
                  self.request_auth(self.host, self.port, self.ssl,
                                    self.user, self.password, self.clientid,
                                    self.xmlencode, self.xmldeclare))
        self.set_auth(self.user, self.password, self.clientid)
        self.session = res.t_response.a_session
        self.raps_connected = True

        debug("raps_connect ok")

        return res

    @add_rl3_route_to_exc
    def raps_disconnect(self):
        if not self.session:
            # self.sessionがNoneの場合Noneを返す
            return None

        res = self.__manage_response(
                   self.request_disconnect(self.host, self.port, self.ssl,
                                           self.session,
                                           self.xmlencode, self.xmldeclare))
        self.raps_connected = False
        return res

    def connect(self):
        # do_manage_connect == Trueの場合は
        # 自動でconnectするので当メソッド使用不要
        self.rl3_connect()
        self.raps_connect()

    def disconnect(self):
        try:
            self.raps_disconnect()
        finally:
            self.rl3_disconnect()

    # getinfoはraps_connect不要なので
    # manage_connectしない
    @add_rl3_route_to_exc
    def getinfo(self):
        return self.__manage_response(
                   self.request_getinfo(self.host, self.port, self.ssl,
                                        self.xmlencode, self.xmldeclare))

    @add_rl3_route_to_exc
    @manage_connect
    def getsharelist(self):
        return self.__manage_response(
                   self.request_getsharelist(self.host, self.port, self.ssl,
                                             self.session,
                                             self.xmlencode, self.xmldeclare))

    @add_rl3_route_to_exc
    @manage_connect
    def getdir(self, path, index=None, maxnum=None,
               regex=None, sort=None, item=[],
               precision=None):
        return self.__manage_response(
                   self.request_getdir(self.host, self.port, self.ssl,
                                       self.session, path, index, maxnum,
                                       regex, sort, item, precision,
                                       self.xmlencode, self.xmldeclare))

    @add_rl3_route_to_exc
    @manage_connect
    def find(self, path, index=None, maxnum=None,
             regex=None, sort=None, item=[], precision=None):
        return self.__manage_response(
                   self.request_find(self.host, self.port, self.ssl,
                                     self.session, path, index, maxnum,
                                     regex, sort, item, precision,
                                     self.xmlencode, self.xmldeclare))

    @add_rl3_route_to_exc
    @manage_connect
    def mkdir(self, path):
        return self.__manage_response(
                   self.request_mkdir(self.host, self.port, self.ssl,
                                      self.session, path,
                                      self.xmlencode, self.xmldeclare))

    @add_rl3_route_to_exc
    @manage_connect
    def getmminfo(self, path, file_):
        return self.__manage_response(
                   self.request_getmminfo(self.host, self.port, self.ssl,
                                          self.session, path,
                                          self.xmlencode, self.xmldeclare),
                   file_)

    @add_rl3_route_to_exc
    @manage_connect
    def copy(self, path, path_dest):
        return self.__manage_response(
                   self.request_copy(self.host, self.port, self.ssl,
                                     self.session, path, path_dest,
                                     self.xmlencode, self.xmldeclare))

    @add_rl3_route_to_exc
    @manage_connect
    def move(self, path, path_dest):
        return self.__manage_response(
                   self.request_move(self.host, self.port, self.ssl,
                                     self.session, path, path_dest,
                                     self.xmlencode, self.xmldeclare))

    @add_rl3_route_to_exc
    @manage_connect
    def delete(self, path):
        return self.__manage_response(
                   self.request_delete(self.host, self.port,
                                       self.ssl, self.session, path,
                                       self.xmlencode, self.xmldeclare))

    @add_rl3_route_to_exc
    @manage_connect
    def download(self, path, file_, offset=None, maxsize=None):

        bkup_pos = None
        if hasattr(file_, "tell"):
            bkup_pos = file_.tell()

        try:
            return self.__manage_response(
                       self.request_download(self.host, self.port, self.ssl,
                                             self.session, path, offset, maxsize,
                                             self.xmlencode, self.xmldeclare),
                       file_)

        except Exception, exc:
            if bkup_pos == None:
                raise_(self.set_do_not_manage_connect(exc))
            try:
                file_.seek(bkup_pos)
                debug("seek bkup position")
            except:
                raise_(self.set_do_not_manage_connect(exc))
            raise_(exc)

    @add_rl3_route_to_exc
    @manage_connect
    def upload(self, path, data, addlen,
               offset=None, mtime=None, overwrite=None):

        bkup_pos = None
        if hasattr(data, "tell"):
            bkup_pos = data.tell()

        try:
            return self.__manage_response(
                       self.request_upload(self.host, self.port, self.ssl,
                                           self.session, path, data, addlen,
                                           offset, mtime, overwrite,
                                           self.xmlencode, self.xmldeclare))
        except Exception, exc:
            if bkup_pos == None:
                raise_(self.set_do_not_manage_connect(exc))
            try:
                data.seek(bkup_pos)
                debug("seek bkup position")
            except:
                raise_(self.set_do_not_manage_connect(exc))
            raise_(exc)

    @add_rl3_route_to_exc
    @manage_connect
    def geturl(self, path, protocol=None, expire=None):
        return self.__manage_response(
               self.request_geturl(self.host, self.port, self.ssl,
                                   self.session, path, protocol, expire,
                                   self.xmlencode, self.xmldeclare))

    @add_rl3_route_to_exc
    @manage_connect
    def disableurl(self, url):
        return self.__manage_response(
                   self.request_disableurl(self.host, self.port, self.ssl,
                                           self.session, url,
                                           self.xmlencode, self.xmldeclare))
