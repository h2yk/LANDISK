#!/usr/bin/env python
# -*- mode: landisk-python; coding: utf-8; -*-
# vim:ts=4 sw=4 sts=4 ai si et sta
import os
import sys
import signal
import rapscomm
import errno

# initalize
c_comm   = rapscomm.rapscomm()
n_result = c_comm.RESULT.RESULT_NO_ERROR

# output exit code
def exitout():
    sys.stdout.write(str(n_result))
    sys.stdout.write("\n")
    sys.exit(0)

# set signal function
def sigfunc(num, frame):
    n_result = c_comm.RESULT.RESULT_ERROR
    exitout()

signal.signal( signal.SIGTERM, sigfunc)

# make directory 
def makedirs(name, mode, uid, gid ):
    # exist check. 
    if os.path.exists(name) == True:
        return
    head, tail = os.path.split(name)
    try:
        if os.path.exists(head) == False:
            makedirs(head, mode, uid, gid)

        # make dir
        os.mkdir( name )
        os.chmod( name, mode )
        try:
            os.chown( name, uid, gid )
        except (IOError, OSError), e:
            if e.errno == errno.EPERM:
                # May be FAT volume Ignore error
                pass
            else:
                raise

    except:
        raise

# parameter check
if len(sys.argv) < 4:
    n_result = c_comm.RESULT.RESULT_INVALID_OPTION
    exitout()

# get parameter
i_uid  = int(sys.argv[1])
i_gid  = int(sys.argv[2])
s_path = sys.argv[3]

# read config
if c_comm.readConfig() == False:
    n_result = c_comm.RESULT.RESULT_ERROR
    exitout()

# mkdir
try:
    # make directory
    makedirs( s_path, c_comm.CONFIG.DIRPERMISS, i_uid, i_gid )

except (IOError, OSError), e:
    if  e.errno == errno.ENOENT:
        n_result = c_comm.RESULT.RESULT_NOT_FOUND
    elif e.errno == errno.EACCES:
        n_result = c_comm.RESULT.RESULT_ERR_PERMISSION
    else:
        n_result = c_comm.RESULT.RESULT_ERR_WRITE

except Exception ,e:
    n_result = c_comm.RESULT.RESULT_ERR_WRITE

exitout()

