# -*- mode: landisk-python; coding: utf-8; -*-
# vim:ts=4 sw=4 sts=4 ai si et sta
import os
import sys
import stat
import xml.dom.minidom
import codecs
import errno
import time
import hashlib
import traceback as tb
import subprocess as sp
import re
import mmap

import rapscomm
import rapsexcept
import rapsrequest
import rapssession
import rapssharelist
import rapslink
import rapsmminfo
import rapsresponse
import ionas.request as request

from iobase.xmldata import (XmlConfNode,)
from iobase.exception import (NotFoundError,)

from product_conf import SUDO_CMD
from fal_info import (FAL_USERS_PATH, FAL_REMOTEACCESS_PATH, FAL_CONTENTS_PATH,
                      FAL_USERS_REQ_BASE_XML, FAL_REMOTEACCESSS_REQ_BASE_XML,
                      FAL_CONTENTS_REQ_BASE_XML)
# FIXME
#from ionas.request import (AUTH_TYPE, INFO_TYPE, SHARE_TYPE, THUMB_TYPE)
AUTH_TYPE = "auth"
AUTH_TIMELIMIT_TYPE = "auth_timelimit"
REGISTER_CLIENTLIMIT_TYPE = "register_clientlimit"
GET_TIMELIMIT_TYPE = "get_timelimit"
MODIFY_TIMELIMIT_TYPE = "modify_timelimit"
INFO_TYPE = "getserverinfo"
SHARE_TYPE = "getsharelist"
THUMB_TYPE = "thumbnail"
# FIXME
#from ionas.resultcode import OK
OK = "0"

FULL_PERM = (stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO)

NOT_PROGRESS_TIME_LIMIT = 30

LOG_CMD = "/usr/local/bin/HDL_log"

ID_TABLE = {"auth": "MSG_RAPS_REQUEST_AUTH"}

REMOTEACCESS_NAME = "remoteaccess"
ACCESSMAX_NAME = "accessmax"
ACCESSCOUNT_ATTR = "accesscount"


def _log(id, arg):
    sp.call(["sudo", LOG_CMD, "--message_id=%s" % ID_TABLE[id], arg])


class rapsmain:
    '''
    rapsmain
    '''
    # Global Variable.
    BLOCK_SIZE  = 65536

    # object initialize
    c_comm  = rapscomm.rapscomm()
    c_sess  = rapssession.rapssession(c_comm)
    c_share = rapssharelist.rapssharelist(c_comm)

    def _subst_timelimit_share(self, req_path, timelimit_path):
        '''
        Return a new path which is substited the directory path of
        "timelimit_path" for the timelimit share of "req_path".
        '''

        timelimit_share_dir = os.path.dirname(timelimit_path)

        req_path = req_path.rstrip("/")
        sub_dir_sep_idx = req_path.find("/", 1)
        if sub_dir_sep_idx < 0:
            return timelimit_share_dir

        return timelimit_share_dir + req_path[sub_dir_sep_idx:]

    def _get_timelimit(self, key):
        '''
        Return timelimit XML data corresponding "key".
        '''

        entry = request.Entry(GET_TIMELIMIT_TYPE,
                FAL_REMOTEACCESSS_REQ_BASE_XML[GET_TIMELIMIT_TYPE])
        entry.get().get_node("timelimit/key").set_text(key)
        response_entry = self._call_fal_command(entry, FAL_REMOTEACCESS_PATH)
        if response_entry == None:
                return None
        else:
            if response_entry.get_result() != OK:
                return None

        return response_entry.get().get_node("timelimit")

        
    def _get_timelimit_path_list(self, key):
        '''
        Return timelimit path list corresponding "key".
        '''

        timelimit = self._get_timelimit(key)
        if timelimit == None:
            return []

        path_list = []
        for path in timelimit.get_node_list("pathlist/path"):
            try:
                timelimit_path = path.get_text()
                if timelimit_path:
                    if not timelimit_path.startswith("/"):
                        timelimit_path = "/" + timelimit_path
                    path_list.append(timelimit_path)
            except:
                pass
        return path_list

    def _is_timelimit_path_or_descendant(self, access_path, path_list):
        '''Check if "access_path" is timelimit path or descendant.'''

        ancestor = ""
        for path in path_list:
            try:
                timelimit_path = path.get_text().rstrip("/")
                if not timelimit_path:
                    continue
                if access_path == timelimit_path:
                    return True

                if access_path.startswith(timelimit_path + "/"):
                    if len(ancestor) < len(timelimit_path):
                        ancestor = timelimit_path
            except:
                pass

        if ancestor:
            return True
        return False

    def _check_and_update_access_count(self, timelimit, access_path,
            do_update_access_count):
        '''
        Check the access count of "access_path".
        If "do_update_access_count" is True, then increase a access count.
        '''

        try:
            accessinfo = timelimit.get_node("accessinfo")
        except NotFoundError:
            accessinfo = XmlConfNode("accessinfo")
            timelimit.append_child(accessinfo)

        try:
            pathlist = accessinfo.get_node("pathlist")
        except NotFoundError:
            pathlist = XmlConfNode("pathlist")
            accessinfo.append_child(pathlist)

        found_path = None
        for path in pathlist.get_node_list("path"):
            if path.get_text() == access_path:
                found_path = path
                break

        if found_path == None:
            found_path = XmlConfNode("path")
            found_path.set_text(access_path)
            pathlist.append_child(found_path)

        access_max = int(timelimit.get_value(ACCESSMAX_NAME, "0"))
        access_count = int(found_path.get_attr_value(ACCESSCOUNT_ATTR, "0"))
        if access_max:
            if access_max <= access_count:
                return None

        if not do_update_access_count:
            return access_path

        access_count += 1
        found_path.set_attrs({ACCESSCOUNT_ATTR: str(access_count)})

        req_body = XmlConfNode(REMOTEACCESS_NAME)
        req_body.append_child(timelimit)
        response_entry = self._call_fal_command(
                        request.Entry(MODIFY_TIMELIMIT_TYPE, req_body),
                        FAL_REMOTEACCESS_PATH)
        if response_entry == None:
            return None
        else:
            if response_entry.get_result() != OK:
                return None
        return access_path

    def _get_timelimit_access_path(self, key, req_path,
            do_update_access_count=False):
        '''
        Return path corresponding "key" and "req_path" for timelimit access.
        If "do_update_access_count" is True, increase access count.
        None is returned if path is not found, "req_path"  is directory
        or access count reaches the limited count.
        '''

        timelimit = self._get_timelimit(key)
        if timelimit == None:
            return None

        found_path = None
        path_list = timelimit.get_node_list("pathlist/path")
        access_path = self._subst_timelimit_share(req_path,
                                                path_list[0].get_text())
        if not self._is_timelimit_path_or_descendant(access_path, path_list):
            return None

        if os.path.isdir(self._path_share_join(req_path)):
            return None

        access_path = self._check_and_update_access_count(timelimit,
                                        access_path, do_update_access_count)
        return access_path

    def __init__(self):
        '''
        Constructor
        '''

    def main(self):
        '''
        main
        '''
        try:
            self._main()
        except Exception, e:
            self.c_comm.logout("*** Error TraceBack ***")
            self.c_comm.logout(tb.format_exc())
            raise e

    def _main(self):
        '''
        mainAUTH_TYPE
        '''
        d_req   = None
        c_requ  = rapsrequest.rapsrequest(self.c_comm)
        c_resp  = rapsresponse.rapsresponse(self.c_comm)
        
        # initalize
        n_result  = self.c_comm.RESULT.RESULT_NO_ERROR
        s_type    = ""
        s_encode  = ""
        s_session = ""
        s_content = ""
        s_data    = ""
        s_path    = ""
        s_bom     = ""
        s_thumb   = ""
        n_offset  = 0
        n_maxsize = 0
        n_addlen = -1
        
        # read config
        if self.c_comm.readConfig() == False:
            n_result = self.c_comm.RESULT.RESULT_ERROR
            c_resp.output("", "", "", "", n_result, "", "")
            return

        # set config value
        self.c_sess.setConfig()

        # parse request
        try:
            d_req = c_requ.parse()

        except rapsexcept.ParseError ,e:
            # debug
            self.c_comm.logout("*** Parse Error ***")
            self.c_comm.logout(str(e))
            n_result = self.c_comm.RESULT.RESULT_NON_XML
            c_resp.output( s_encode, s_bom, s_type, s_session, n_result, "", "")
            return

        except IndexError:
            if d_req != None:
                s_type   = c_requ.getvalue(d_req, "type")
            n_result = self.c_comm.RESULT.RESULT_INVALID_OPTION
            c_resp.output( s_encode, s_bom, s_type, s_session, n_result, "", "")
            return

        except LookupError:
            if d_req != None:
                s_type   = c_requ.getvalue(d_req, "type")
            n_result = self.c_comm.RESULT.RESULT_INVALID_ENCODING
            c_resp.output( s_encode, s_bom, s_type, s_session, n_result, "", "")
            return

        except Exception ,e:
            # debug
            self.c_comm.logout("*** Parse Error ***")
            self.c_comm.logout(str(e))
            if d_req != None:
                s_type   = c_requ.getvalue(d_req, "type")
            n_result = self.c_comm.RESULT.RESULT_INVALID_XML
            c_resp.output( s_encode, s_bom, s_type, s_session, n_result, "", "")
            return

        s_type    = c_requ.getvalue(d_req, "type")
        s_encode  = c_requ.getvalue(d_req, "encode")
        s_bom     = c_requ.getdata (d_req, "bom")
        s_session = c_requ.getvalue(d_req, "session")

        # path check
        s_check = c_requ.getvalue(d_req, "path")
        if len(s_check) > 0:
            if s_check.startswith("/") == False:
                n_result = self.c_comm.RESULT.RESULT_INVALID_XML
                c_resp.output( s_encode, s_bom, s_type, s_session, n_result, "", "")
                return
        s_check = c_requ.getvalue(d_req, "dest")
        if len(s_check) > 0:
            if s_check.startswith("/") == False:
                n_result = self.c_comm.RESULT.RESULT_INVALID_XML
                c_resp.output( s_encode, s_bom, s_type, s_session, n_result, "", "")
                return

        # The call according to processing type.
        if s_type == "getinfo":
            # Acquisition of server information 
            n_result, s_content = self.getinfo()

        elif s_type == "auth":
            # Establishment of a session.
            s_name = c_requ.getvalue(d_req, "name")
            s_client_id = c_requ.getvalue(d_req, "clientid")
            s_key = c_requ.getvalue(d_req, "key")

            _log(s_type, s_name)

            if s_name and s_client_id:
                s_password = c_requ.getvalue(d_req, "password")
                s_domain = c_requ.getvalue(d_req, "domain")
                n_result, s_content, s_session = \
                        self.auth(s_name, s_password, s_domain,
                                    s_client_id, s_key)
            elif s_key and s_client_id:
                n_result, s_content, s_session = \
                        self.auth("", "", "", s_client_id, s_key)
            else:
                n_result = self.c_comm.RESULT.RESULT_INVALID_OPTION
            
        elif s_type == "disconnect":
            # Cancellation of a session. 
            n_result, s_content = self.disconnect(s_session)
            
        elif s_type == "getsharelist":
            # List acquisition of a shared folder.
            n_result, s_content = self.getsharelist(s_session)
            
        elif s_type == "getdir":
            # List acquisition of a shared folder.
            s_path = c_requ.getvalue(d_req, "path")
            if s_path != "":
                n_index  = c_requ.getnum  (d_req, "index")
                n_maxnum = c_requ.getnum  (d_req, "maxnum")
                s_regex  = c_requ.getvalue(d_req, "regex")
                s_sort   = c_requ.getvalue(d_req, "sort")
                b_order  = False
                s_order  = c_requ.getvalue(d_req, "reverse")
                if s_order.lower() == "true":
                    b_order = True
                l_stat   = c_requ.getdata (d_req, "statitemlist")
                n_prec   = c_requ.getnum  (d_req, "precision")
                n_result, s_content = self.getdir(s_session, n_index, n_maxnum, s_path, s_regex, s_sort, b_order, l_stat, n_prec)
            else:
                n_result = self.c_comm.RESULT.RESULT_INVALID_OPTION
            
        elif s_type == "find":
            # The specified file is searched. 
            s_path = c_requ.getvalue(d_req, "path")
            if s_path != "":
                n_index  = c_requ.getnum  (d_req, "index")
                n_maxnum = c_requ.getnum  (d_req, "maxnum")
                s_regex  = c_requ.getvalue(d_req, "regex")
                s_sort   = c_requ.getvalue(d_req, "sort")
                b_order  = False
                s_order  = c_requ.getvalue(d_req, "reverse")
                if s_order.lower() == "true":
                    b_order = True
                l_stat   = c_requ.getdata (d_req, "statitemlist")
                n_prec   = c_requ.getnum  (d_req, "precision")
                n_result, s_content = self.find(s_session, n_index, n_maxnum, s_path, s_regex, s_sort, b_order, l_stat, n_prec)
            else:
                n_result = self.c_comm.RESULT.RESULT_INVALID_OPTION
            
        elif s_type == "mkdir":
            # Creation of the appointed directory.
            s_path = c_requ.getvalue(d_req, "path")
            if s_path != "":
                n_result, s_content = self.mkdir(s_session, s_path)
            else:
                n_result = self.c_comm.RESULT.RESULT_INVALID_OPTION
            
        elif s_type == "getmminfo":
            # Information acquisition of a multimedia system file. 
            s_path = c_requ.getvalue(d_req, "path")
            if s_path != "":
                n_result, s_content, s_thumb = self.getmminfo(s_session, s_path)
                try:
                    n_addlen = os.path.getsize( s_thumb )
                except:
                    pass
            else:
                n_result = self.c_comm.RESULT.RESULT_INVALID_OPTION

        elif s_type == "getresizedimage":
            s_path = c_requ.getvalue(d_req, "path")
            n_width = c_requ.getnum(d_req, "width")
            n_height = c_requ.getnum(d_req, "height")
            if s_path != "" and n_width > 0 and n_height > 0:
                n_result, s_content, s_resizedimage = self.getresizedimage(s_session, s_path, n_width, n_height)
                try:
                    n_addlen = os.path.getsize( s_resizedimage )
                except:
                    pass
            else:
                n_result = self.c_comm.RESULT.RESULT_INVALID_OPTION

        elif s_type == "move":
            # Renaming of a specification path 
            s_path   = c_requ.getvalue(d_req, "path")
            s_dest   = c_requ.getvalue(d_req, "dest")
            if s_path != "" and s_dest != "":
                n_result, s_content = self.move(s_session, s_path, s_dest)
            else:
                n_result = self.c_comm.RESULT.RESULT_INVALID_OPTION

        elif s_type == "copy":
            # Renaming of a specification path 
            s_path   = c_requ.getvalue(d_req, "path")
            s_dest   = c_requ.getvalue(d_req, "dest")
            if s_path != "" and s_dest != "":
                n_result, s_content = self.copy(s_session, s_path, s_dest)
            else:
                n_result = self.c_comm.RESULT.RESULT_INVALID_OPTION

        elif s_type == "delete":
            # Deletion of a specification path. 
            s_path   = c_requ.getvalue(d_req, "path")
            if s_path != "":
                n_result, s_content = self.delete(s_session, s_path)
            else:
                n_result = self.c_comm.RESULT.RESULT_INVALID_OPTION

        elif s_type == "download":
            # Acquisition of specification file data.
            s_path = c_requ.getvalue(d_req, "path")
            if s_path != "":
                n_offset = c_requ.getnum  (d_req, "offset")
                n_maxsize = c_requ.getnum  (d_req, "maxsize")
                s_data = self._path_share_join( s_path )
                n_result, s_content = self.download( s_session, s_path, n_offset, n_maxsize )
                if n_result == self.c_comm.RESULT.RESULT_NO_ERROR:
                    # size check
                    n_addlen = os.path.getsize( s_data )
                    n_addlen -= n_offset
                    if n_maxsize != 0 :
                        if n_addlen > n_maxsize:
                            n_addlen = n_maxsize
                    if n_addlen < 0:
                        n_addlen = 0
                    if n_addlen > self.c_comm.CONFIG.MAX_DOWNLOAD:
                        n_addlen = 0
                        n_result = self.c_comm.RESULT.RESULT_ERR_TOO_LARGE_FILE
            else:
                n_result = self.c_comm.RESULT.RESULT_INVALID_OPTION

        elif s_type == "upload":
            # Transmission of specification file data.
            s_path    = c_requ.getvalue(d_req, "path")
            s_addlen = c_requ.getvalue(d_req, "addlen")
            if s_path != "" and s_addlen != "":
                n_offset  = c_requ.getnum  (d_req, "offset")
                s_mtime   = c_requ.getvalue(d_req, "mtime")
                s_overw   = c_requ.getvalue(d_req, "overwrite")
                i_addlen  = c_requ.getnum  (d_req, "addlen")
                s_data    = self._path_share_join( s_path )
                n_result, s_content = self.upload(s_session, s_path, n_offset, s_mtime, s_overw, i_addlen)
            else:
                n_result = self.c_comm.RESULT.RESULT_INVALID_OPTION

        elif s_type == "geturl":
            # Acquisition of URL in which temporary access to a specification file is possible. 
            s_path     = c_requ.getvalue(d_req, "path")
            if s_path != "":
                s_protocol = c_requ.getvalue(d_req, "protocol")
                if s_protocol == "":
                    s_protocol = "http"
                n_expire   = c_requ.getnum(d_req, "expire")
                if n_expire == 0:
                    n_expire = 86400
                n_result, s_content = self.geturl( s_session, s_path, s_protocol, n_expire )
            else:
                n_result = self.c_comm.RESULT.RESULT_INVALID_OPTION

        elif s_type == "disableurl":
            # URL which can be accessed temporary is repealed. 
            s_url = c_requ.getvalue(d_req, "url")
            if s_url != "":
                n_result, s_content = self.disableurl( s_session, s_url )
            else:
                n_result = self.c_comm.RESULT.RESULT_INVALID_OPTION

        else:
            n_result  = self.c_comm.RESULT.RESULT_INVALID_REQUEST
            s_content = ""

        # set response
        c_resp.output( s_encode, s_bom, s_type, s_session, n_result, s_content, n_addlen )

        # output data
        if n_result == self.c_comm.RESULT.RESULT_NO_ERROR:
            # file download
            if s_type == "download":
                self.download_file( s_data, n_offset, n_maxsize )
    
            elif s_type == "getmminfo":
                # thumbnail file download
                if s_thumb != "":
                    self.download_file( s_thumb )
            elif s_type == "getresizedimage":
                # thumbnail file download
                if s_resizedimage != "":
                    self.download_file( s_resizedimage )
        else:
            if s_type == "upload":
                # For close PIPE to/from apache
                for fd in range(0, 3):
                    try:
                        os.close(fd)
                    except:
                        pass

        # update session file time 
        self.c_sess.update(s_session)
        
        # update thumbs if new path created.
        if s_type == "upload" or s_type == "copy" or s_type == "move":
            self.c_comm.logout("update_thumbs")
            if n_result == self.c_comm.RESULT.RESULT_NO_ERROR:
                Thumbnail = rapsmminfo.Thumbnail(self, self.c_comm)
                Thumbnail.update_thumbs()

        return

    def getinfo(self):
        #
        # Acquisition of server information.
        #
        n_result  = self.c_comm.RESULT.RESULT_NO_ERROR
        s_content = ""

        # call getinfo
        entry = request.Entry(INFO_TYPE, FAL_REMOTEACCESSS_REQ_BASE_XML[INFO_TYPE])
        response_entry = self._call_fal_command( entry, FAL_REMOTEACCESS_PATH )
        if response_entry != None:
            if response_entry.get_result() != OK:
                n_result = self.c_comm.RESULT.RESULT_ERROR
            else:
                try:
                    resxml = response_entry.get().to_str()
                    dom = xml.dom.minidom.parseString(resxml)
                    rsp = dom.getElementsByTagName("serverinfo")[0]
                    if rsp != None:
                        s_content = rsp.toxml()
                    else:
                        n_result = self.c_comm.RESULT.RESULT_INVALID_XML
                except:
                    n_result = self.c_comm.RESULT.RESULT_INVALID_XML
        else:
            n_result = self.c_comm.RESULT.RESULT_ERROR
        
        return n_result, s_content

    def auth(self, name, password, domain, clientid, key=""):
        #
        # Establishment of a session.
        #
        n_result  = self.c_comm.RESULT.RESULT_NO_ERROR
        s_content = ""
        s_session = ""

        # remove session file
        self.c_sess.remove()

        # call authorize
        if name:
            entry = request.Entry(AUTH_TYPE, FAL_USERS_REQ_BASE_XML[AUTH_TYPE])
            entry.get().get_node("user/name").set_text(name)
            entry.get().get_node("user/passwd").set_text(password)
            if domain != "": 
                entry.get().get_node("user").set_attrs({ "domain": domain })
            response_entry = self._call_fal_command(entry, FAL_USERS_PATH)
            if response_entry != None:
                if response_entry.get_result() != OK:
                    n_result = self.c_comm.RESULT.RESULT_ERR_AUTH
            if key and n_result == self.c_comm.RESULT.RESULT_NO_ERROR:
                entry = request.Entry(REGISTER_CLIENTLIMIT_TYPE,
                    FAL_REMOTEACCESSS_REQ_BASE_XML[REGISTER_CLIENTLIMIT_TYPE])
                entry.get().get_node("clientlimit/clientid").set_text(clientid)
                entry.get().get_node("clientlimit/key").set_text(key)
                entry.get().get_node(
                        "clientlimit/registerinfo/username").set_text(name)
                response_entry = self._call_fal_command(entry,
                                                        FAL_REMOTEACCESS_PATH)
                if response_entry != None:
                    if response_entry.get_result() != OK:
                        n_result = self.c_comm.RESULT.RESULT_ERR_PERMISSION
        elif key:
            entry = request.Entry(AUTH_TIMELIMIT_TYPE,
                FAL_REMOTEACCESSS_REQ_BASE_XML[AUTH_TIMELIMIT_TYPE])
            entry.get().get_node("timelimit/key").set_text(key)
            entry.get().get_node("timelimit/clientid").set_text(clientid)
            response_entry = self._call_fal_command(entry,
                                                    FAL_REMOTEACCESS_PATH)
            if response_entry != None:
                if response_entry.get_result() != OK:
                    n_result = self.c_comm.RESULT.RESULT_ERR_PERMISSION

            self.c_share.set_timelimit_key(key)
        else:
            n_result = self.c_comm.RESULT.RESULT_ERROR

        if n_result == self.c_comm.RESULT.RESULT_NO_ERROR:
            if self.c_sess.isCount() >= self.c_comm.CONFIG.MAX_SESSION:
                # check session count
                n_result = self.c_comm.RESULT.RESULT_ERR_EXCEED_SESSION_LIMIT
            else:
                # get session id
                s_session = self.c_sess.getSeesionid()
                # get share list
                n_result, s_sharelist = \
                        self._getsharelist(name, domain, clientid, key)
                if n_result == self.c_comm.RESULT.RESULT_NO_ERROR:
                    # make session data
                    self.c_share.parse(s_sharelist)
                    self.c_share.setpassword(password)
                    self.c_share.set_clientid(clientid)
                    s_sessdata = self.c_share.makeSession()
                    # create session file
                    n_result = self.c_sess.create(s_session, s_sessdata)
        
        if n_result != self.c_comm.RESULT.RESULT_NO_ERROR:
            s_session = ""

        return n_result, s_content, s_session

    def _getsharelist(self, name, domain, clientid, key):
        #
        # List acquisition of a shared folder.
        #
        n_result  = self.c_comm.RESULT.RESULT_NO_ERROR
        s_content = ""
        
        # call getsharelist
        entry = request.Entry(SHARE_TYPE, FAL_REMOTEACCESSS_REQ_BASE_XML[SHARE_TYPE])
        entry.get().get_node("user/name").set_text(name)
        entry.get().get_node("clientid").set_text(clientid)
        entry.get().get_node("key").set_text(key)
        if domain != "":
            entry.get().get_node("user").set_attrs({ "domain": domain })
        response_entry = self._call_fal_command( entry, FAL_REMOTEACCESS_PATH )
        if response_entry != None:
            if response_entry.get_result() != OK:
                n_result = self.c_comm.RESULT.RESULT_ERROR
            else:
                try:
                    s_content = response_entry.get().to_str()
                except:
                    n_result = self.c_comm.RESULT.RESULT_INVALID_XML
        else:
            n_result = self.c_comm.RESULT.RESULT_ERROR
        
        return n_result, s_content

    def disconnect(self, session):
        #
        # Cancellation of a session.s_session
        #
        n_result  = self.c_comm.RESULT.RESULT_NO_ERROR
        s_content = ""

        # session check
        if self.c_sess.check(session) == False:
            n_result = self.c_comm.RESULT.RESULT_INVALID_SESSION_ID
            return n_result, s_content

        # Cancellation of a session.
        n_result = self.c_sess.delete(session)

        return n_result, s_content

    def getsharelist(self, session):
        #
        # List acquisition of a shared folder.
        #
        n_result  = self.c_comm.RESULT.RESULT_NO_ERROR
        s_content = ""
        
        # session check
        if self.c_sess.check(session) == False:
            n_result = self.c_comm.RESULT.RESULT_INVALID_SESSION_ID
            return n_result, s_content

        # read session data
        self.c_share.parse(self.c_sess.getSessionData(session))

        # read session data
        s_content = self.c_share.makeContent()
        
        return n_result, s_content


    def _createheader(self, total, getdir, path, regex, sort, order, size, mtime, precision):
        return "\t".join([str(total), str(getdir), str(path), str(regex), str(sort), str(order), str(size), str(mtime), str(precision)])
        
    def _gettotal(self, header, getdir, path, regex, sort, order, size, mtime, precision):
        (header_total, header_getdir, header_path, header_regex, header_sort, header_order, header_size, header_mtime, header_precision) = header.split("\t")
        if str(getdir) != header_getdir:
            raise rapsexcept.ListError
        if str(path) != header_path:
            raise rapsexcept.ListError
        if str(regex) != header_regex:
            raise rapsexcept.ListError
        if str(sort) != header_sort:
            raise rapsexcept.ListError
        if str(order) != header_order:
            raise rapsexcept.ListError
        if str(size) != header_size:
            raise rapsexcept.ListError
        if str(mtime) != header_mtime:
            raise rapsexcept.ListError
        if str(precision) != header_precision:
            raise rapsexcept.ListError
        return int(header_total)

    def escape_posix_basic(self, path):
        return re.sub(r'([\^\.\*\[\$\\])', r'\\\1', path)

    def escape_posix_extended(self, path):
        return re.sub(r'([\^\.\[\$\(\)\|\*\+\?\{\\])', r'\\\1', path)

    def escape_posix_raps(self, path):
        return re.sub(r'([\.\*\+\[\]\\\^\$\?\|\(\)\{\}])', r'\\\1', path)

    def _create_filelist_cache(self, cache_path, getdir, path, regex, sort, order, size, mtime, precision):
        workaround_for_rlf100 = True
        workaround_for_rlf200 = True
        FILE_DATA_INDEX_TYPE = 0
        FILE_DATA_INDEX_SIZE = 1
        FILE_DATA_INDEX_MTIME = 2
        FILE_DATA_INDEX_MTIME_EXT = 3
        FILE_DATA_INDEX_DIR = 4
        FILE_DATA_INDEX_NAME = 5
        self.c_comm.logout("*** create file list cache ***")
        find_opt_getdir = [ "-maxdepth", "1" ]
        find_opt_output = [ "-printf", "%y\t%s\t%T@\t0\t%h\t%f\n" ]
        find_path = self._path_share_join(path)
        cmd = [ "find", find_path, "-mindepth", "1" ]
        if getdir == True:
            cmd += find_opt_getdir
        if regex != ".*":
            find_opt_regex = "-regex"
            str_regex = regex
            if workaround_for_rlf100:
                str_regex = str_regex.strip()
                if str_regex.startswith("^"):
                    str_regex = str_regex[1:]
                if str_regex.endswith("$"):
                    if not str_regex.endswith(r"\$"):
                        str_regex = str_regex[:-1]
            if workaround_for_rlf200:
                if str_regex.startswith("(?i)"):
                    find_opt_regex = "-iregex"
                    str_regex = str_regex[4:]
            cmd += ["-regextype", "posix-extended"]
            escaped_find_path = self.escape_posix_raps(find_path.rstrip("/"))
            cmd += [find_opt_regex, escaped_find_path + ".*/" + str_regex]
        cmd += find_opt_output
        self.c_comm.logout(str(cmd))
        p = sp.Popen(cmd, stdout=sp.PIPE)
        stdoutdata, stderrdata = p.communicate()
        resultcode = p.wait()
        if resultcode != 0:
            self.c_comm.logout("find command failed")
            raise rapsexcept.ListError

        lines = stdoutdata.split("\n")
        last_line = lines.pop()
        if last_line != "":
            raise rapsexcept.ListError
        if regex != ".*":
            regex_lines = []
            recompile = re.compile(str_regex)
            if workaround_for_rlf200:
                if find_opt_regex == "-iregex":
                    recompile = re.compile(str_regex, re.IGNORECASE)
            for line in lines:
                str_file_data = line.rstrip()
                file_data = str_file_data.split("\t")
                if recompile.match(file_data[FILE_DATA_INDEX_NAME]):
                    regex_lines.append(line)
            lines = regex_lines
            stdoutdata = "\n".join(lines)
        total = len(lines)

        cache_file = open(cache_path, "w")
        cache_file.write(self._createheader(total, getdir, path, regex, sort, order, size, mtime, precision) + "\n")
        if sort == "none" and precision == 0:
            cache_file.write(stdoutdata)
        elif sort == "none":
            for line in lines:
                if not line:
                    break
                str_file_data = line.rstrip()
                file_data = str_file_data.split("\t")
                if precision > 0:
                    file_path = file_data[FILE_DATA_INDEX_DIR].rstrip("/") + "/" + file_data[FILE_DATA_INDEX_NAME]
                    file_data[FILE_DATA_INDEX_MTIME_EXT] = repr(os.path.getmtime(file_path)).split(".")[1]
                str_file_data = "\t".join(file_data)
                cache_file.write(str_file_data + "\n")
        else:
            file_list = []
            sortdic = {}
            for line in lines:
                if not line:
                    break
                str_file_data = line.rstrip()
                file_data = str_file_data.split("\t")
                if precision > 0 or sort == "mtime":
                    file_path = file_data[FILE_DATA_INDEX_DIR].rstrip("/") + "/" + file_data[FILE_DATA_INDEX_NAME]
                    file_data[FILE_DATA_INDEX_MTIME_EXT] = repr(os.path.getmtime(file_path)).split(".")[1]
                str_file_data = "\t".join(file_data)
                sortstr_name = file_data[FILE_DATA_INDEX_NAME] + file_data[FILE_DATA_INDEX_DIR]
                if sort == "name":
                    sortstr = sortstr_name
                elif sort == "dir" and getdir != True:
                    sortstr = file_data[FILE_DATA_INDEX_DIR] + sortstr_name
                elif sort == "mtime":
                    sortstr = file_data[FILE_DATA_INDEX_MTIME] + file_data[FILE_DATA_INDEX_MTIME_EXT] + "_" + sortstr_name
                elif sort == "size":
                    sortstr = "%019u" % int(file_data[FILE_DATA_INDEX_SIZE]) + "_" + sortstr_name
                else:
                    self.c_comm.logout("invalid sort option")
                    raise rapsexcept.ListError
                sortdic[sortstr] = str_file_data
            if order:
                for key, value in sorted(sortdic.items()):
                    file_list.insert(0,value)
            else:
                for key, value in sorted(sortdic.items()):
                    file_list.append(value)
            for str_file_data in file_list:
                cache_file.write(str_file_data + "\n")
        cache_file.close()

    def _getfilelist(self, getdir, session, index, maxnum, path, regex, sort, order, b_size, b_mtime, precision):
        FILE_DATA_INDEX_TYPE = 0
        FILE_DATA_INDEX_SIZE = 1
        FILE_DATA_INDEX_MTIME = 2
        FILE_DATA_INDEX_MTIME_EXT = 3
        FILE_DATA_INDEX_DIR = 4
        FILE_DATA_INDEX_NAME = 5
        cache_path = self.c_sess._getlstname(session)
        if index == 0 or not os.path.exists(cache_path):
            self._create_filelist_cache(cache_path, getdir, path, regex, sort, order, b_size, b_mtime, precision)
        else:
            self.c_comm.logout("*** skip create file list cache ***")

        cache_file = open(cache_path, "r")
        m = mmap.mmap(cache_file.fileno(), 0, prot=mmap.PROT_READ)
        try:
            total = self._gettotal(m.readline().strip(), getdir, path, regex, sort, order, b_size, b_mtime, precision)
        except:
            self.c_comm.logout("*** correct file list cache not found ***")
            m.close()
            cache_file.close()
            self._create_filelist_cache(cache_path, getdir, path, regex, sort, order, b_size, b_mtime, precision)
            cache_file = open(cache_path, "r")
            m = mmap.mmap(cache_file.fileno(), 0, prot=mmap.PROT_READ)
            total = self._gettotal(m.readline().strip(), getdir, path, regex, sort, order, b_size, b_mtime, precision)

        self.c_comm.logout("*** create <filelist> ***")
        root_path = self._get_share_root(path).rstrip('/')
        s_filelist = "<filelist total=\"%d\" index=\"%d\">\n" % (total, index)
        file_index = 0
        file_count = 0
        while True:
            line = m.readline()
            if not line:
                break
            if file_index < index:
                file_index += 1
                continue
            if maxnum != 0 and file_count >= maxnum:
                break
            file_count += 1
            line = line.rstrip()
            file_data = line.split("\t")
            s_file = "<file"
            if file_data[FILE_DATA_INDEX_TYPE] == "d":
                s_file += " isdir=\"true\""
            if b_size == True:
                s_file += " size=\"%s\"" % file_data[FILE_DATA_INDEX_SIZE]
            if b_mtime == True:
                str_mtime = time.strftime("%Y%m%d%H%M%S",time.gmtime(int(file_data[FILE_DATA_INDEX_MTIME])))
                if precision > 0:
                    str_mtime_ext = file_data[FILE_DATA_INDEX_MTIME_EXT][:precision]
                    len_mtime_ext = len(str_mtime_ext)
                    if len_mtime_ext < precision:
                        str_mtime_ext += "0" * (precision - len_mtime_ext)
                    str_mtime += str_mtime_ext
                s_file += " mtime=\"%s\"" % str_mtime
            s_file += ">"
            s_name = "<name>" + self.c_comm.Escape(file_data[FILE_DATA_INDEX_NAME]) + "</name>"
            s_file += s_name
            if getdir != True:
                s_directory = "<directory>" + self.c_comm.Escape(re.sub(r"^" + root_path, "", file_data[FILE_DATA_INDEX_DIR].rstrip("/"))) + "</directory>"
                s_file += s_directory
            s_file += "</file>\n"
            s_filelist += s_file
        s_filelist += "</filelist>"
        m.close()
        cache_file.close()
        return s_filelist

    def getdir(self, session, index, maxnum, path, regex, sort, order, statitemlist, precision, file_name_list=[]):
        #
        # List acquisition in the appointed directory. 
        #
        n_result  = self.c_comm.RESULT.RESULT_NO_ERROR
        s_content = ""
        b_size    = "size" in statitemlist
        b_mtime   = "mtime" in statitemlist
        if regex == "":
            regex = ".*"
        if sort == "":
            sort = "none"

        # session check
        if self.c_sess.check(session) == False:
            n_result = self.c_comm.RESULT.RESULT_INVALID_SESSION_ID
            return n_result, s_content

        # read session data
        self.c_share.parse(self.c_sess.getSessionData(session))

        target_file_list = []
        key = self.c_share.get_timelimit_key()
        if key:
            path_list = self._get_timelimit_path_list(key)
            if path_list == None or len(path_list) <= 0:
                n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
                return n_result, s_content


            path = self._subst_timelimit_share(path, path_list[0])
            if path == os.path.dirname(path_list[0]):
                for file_path in path_list:
                    target_file_list.append(os.path.basename(file_path))

        # appointed directory.
        find_path = self._path_share_join(path)
        if self._is_symlink(find_path) == True:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content

        if os.path.exists(find_path) == True:
            if os.path.isdir(find_path) == False:
                n_result = self.c_comm.RESULT.RESULT_ERR_NOT_DIR
                return n_result, s_content
        else:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content

        if self._path_share_check(find_path) == False:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content

        c_path = self._path_share_current(find_path)
        if not key and self.c_share.isFound(c_path) == False:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content

        if self._path_share_count(find_path) < 1:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content

        try:
            s_content = self._getfilelist(True, session, index, maxnum, path, regex, sort, order, b_size, b_mtime, precision)
        except:
            self.c_comm.logout(tb.format_exc())
            n_result = self.c_comm.RESULT.RESULT_ERROR
            return n_result, s_content
        
        return n_result, s_content

    def find(self, session, index, maxnum, path, regex, sort, order, statitemlist, precision):
        #
        # The specified file is searched. 
        #
        n_result  = self.c_comm.RESULT.RESULT_NO_ERROR
        s_content = ""
        b_size    = "size" in statitemlist
        b_mtime   = "mtime" in statitemlist
        if regex == "":
            regex = ".*"
        if sort == "":
            sort = "none"

        # session check
        if self.c_sess.check(session) == False:
            n_result = self.c_comm.RESULT.RESULT_INVALID_SESSION_ID
            return n_result, s_content

        # read session data
        self.c_share.parse(self.c_sess.getSessionData(session))

        # appointed directory.
        find_path = self._path_share_join(path)
        if self._is_symlink(find_path) == True:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content

        if os.path.exists(find_path) == True:
            if os.path.isdir(find_path) == False:
                n_result = self.c_comm.RESULT.RESULT_ERR_NOT_DIR
                return n_result, s_content
        else:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content

        if self._path_share_check(find_path) == False:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content

        c_path = self._path_share_current(find_path)
        if self.c_share.isFound(c_path) == False:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content

        if self._path_share_count(find_path) < 1:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content

        try:
            s_content = self._getfilelist(False, session, index, maxnum, path, regex, sort, order, b_size, b_mtime, precision)
        except:
            self.c_comm.logout(tb.format_exc())
            n_result = self.c_comm.RESULT.RESULT_ERROR
            return n_result, s_content

        return n_result, s_content

    def mkdir(self, session, path):
        #
        # Creation of the appointed directory.
        #
        n_result  = self.c_comm.RESULT.RESULT_NO_ERROR
        s_content = ""

        # session check
        if self.c_sess.check(session) == False:
            n_result = self.c_comm.RESULT.RESULT_INVALID_SESSION_ID
            return n_result, s_content
        
        # read session data
        self.c_share.parse(self.c_sess.getSessionData(session))
        
        # appointed directory.
        s_path = self._path_share_join(path)
        if self._is_symlink( s_path ) == True:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content

        # check already exists. 
        _exist, _dir = self.c_comm.IsExistNoCase_ckdir(s_path)
        if _exist == True:
            if _dir == False:
                n_result = self.c_comm.RESULT.RESULT_ERR_EXIST
            return n_result, s_content

        if self._path_share_check(s_path) == False:
            n_result = self.c_comm.RESULT.RESULT_ERR_INVALID_FILE
            return n_result, s_content

        c_path = self._path_share_current(s_path)
        if self.c_share.isFound(c_path) == False:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content
        if self.c_share.isWrite(c_path) == False:
            n_result = self.c_comm.RESULT.RESULT_ERR_PERMISSION
            return n_result, s_content
        s_uid = str(self.c_share.getuid(c_path))
        s_gid = str(self.c_share.getgid(c_path))

        _path_count = self._path_share_count(s_path)
        if _path_count == 1:
            n_result = self.c_comm.RESULT.RESULT_ERR_INVALID_FILE
            return n_result, s_content
        else:
            if _path_count <= 0:
                n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
                return n_result, s_content
        
        # call mkdir command
        s_cmd = self._path_rapslibpath_join("rapsmkdir.py")
        try:
            n_result = self.c_comm.sudo([ s_cmd, s_uid, s_gid, s_path ])
        except:
            n_result = self.c_comm.RESULT.RESULT_ERR_INTERNAL

        return n_result, s_content

    def getmminfo(self, session, path):
        #
        # Information acquisition of a multimedia system file.
        #
        ExifInfo  = rapsmminfo.ExifInfo(self.c_comm)
        Thumbnail = rapsmminfo.Thumbnail(self, self.c_comm)
        n_result  = self.c_comm.RESULT.RESULT_NO_ERROR
        s_content = ""
        s_thumb   = ""

        # session check
        if self.c_sess.check(session) == False:
            n_result = self.c_comm.RESULT.RESULT_INVALID_SESSION_ID
            return n_result, s_content, s_thumb

        # read session data
        self.c_share.parse(self.c_sess.getSessionData(session))

        key = self.c_share.get_timelimit_key()
        if key:
            path = self._get_timelimit_access_path(key, path)
            if not path:
                n_result = self.c_comm.RESULT.RESULT_ERR_PERMISSION
                return n_result, s_content

        # appointed directory.
        srcpath = self._path_share_join(path)
        dstpath = path
        
        # check exists. 
        if os.path.exists( srcpath ) == False:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content, s_thumb

        if self._path_share_check(srcpath) == False:
            n_result = self.c_comm.RESULT.RESULT_ERR_INVALID_FILE
            return n_result, s_content, s_thumb

        c_path = self._path_share_current(srcpath)
        if not key and self.c_share.isFound(c_path) == False:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content, s_thumb
        
        if self._path_share_count(srcpath) < 2:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content, s_thumb

        # make content
        s_content  = "<file>"
        s_content += "<mminfo>"

        # Acquisition of Exif information
        if self.c_comm.CONFIG.EXIF_ENABLE != 0:
            s_content += ExifInfo.GetContent(srcpath)
        
        # make thumbnail
        s_thumb = Thumbnail.create( srcpath )
        if s_thumb != "":
            b_retCode, n_size = self.getthumbnail(s_thumb)
            if b_retCode == True:
                s_content += "<thumbnail size=\"" + str(n_size) + "\"/>"
        
        s_content += "</mminfo>"
        s_content += "</file>"
        
        return n_result, s_content, s_thumb

    def getresizedimage(self, session, path, width, height):
        Thumbnail = rapsmminfo.Thumbnail(self, self.c_comm)
        n_result  = self.c_comm.RESULT.RESULT_NO_ERROR
        s_content = ""
        s_resizedimage = ""

        # session check
        if self.c_sess.check(session) == False:
            n_result = self.c_comm.RESULT.RESULT_INVALID_SESSION_ID
            return n_result, s_content, s_resizedimage

        # read session data
        self.c_share.parse(self.c_sess.getSessionData(session))

        key = self.c_share.get_timelimit_key()
        if key:
            path = self._get_timelimit_access_path(key, path)
            if not path:
                n_result = self.c_comm.RESULT.RESULT_ERR_PERMISSION
                return n_result, s_content, s_resizedimage

        # appointed directory.
        srcpath = self._path_share_join(path)
        
        # check exists. 
        if os.path.exists( srcpath ) == False:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content, s_resizedimage

        if self._path_share_check(srcpath) == False:
            n_result = self.c_comm.RESULT.RESULT_ERR_INVALID_FILE
            return n_result, s_content, s_resizedimage

        c_path = self._path_share_current(srcpath)
        if not key and self.c_share.isFound(c_path) == False:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content, s_resizedimage
        
        if self._path_share_count(srcpath) < 2:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content, s_resizedimage

        s_resizedimage = Thumbnail.create( srcpath, width, height )
        
        return n_result, s_content, s_resizedimage

    def _makethumbnail(self, srcpath, dstpath):
        #
        # parse of a shared folder.
        #
        n_result  = self.c_comm.RESULT.RESULT_NO_ERROR
        # make moview thumbnail
        try:
            entry = request.Entry(THUMB_TYPE, FAL_CONTENTS_REQ_BASE_XML[THUMB_TYPE])
            entry.get().get_node("file/path").set_text(srcpath)
            entry.get().get_node("file/mminfo/thumbnail/path").set_text(dstpath)
        except Exception ,e: 
            # debug
            self.c_comm.logout("*** set movie thumbnail param ***")
            self.c_comm.logout(FAL_CONTENTS_REQ_BASE_XML[THUMB_TYPE])
            self.c_comm.logout(str(e))
            return n_result

        response_entry = self._call_fal_command( entry, FAL_CONTENTS_PATH )
        if response_entry != None:
            if response_entry.get_result() != OK:
                n_result = self.c_comm.RESULT.RESULT_ERROR
        else:
            n_result = self.c_comm.RESULT.RESULT_ERROR

        return n_result

    def getthumbnail(self, path):
        #
        # sending thumbnail
        #
        b_retCode = False
        n_retSize = 0

        # check exists. 
        try:
            if os.path.exists( path ) == True:
                b_retCode = True
                n_retSize = os.path.getsize(path)
        except:
            pass

        return b_retCode, n_retSize

    def move(self, session, src, dest):
        #
        # move file and directory.
        #
        n_result  = self.c_comm.RESULT.RESULT_NO_ERROR
        s_content = ""

        # session check
        if self.c_sess.check(session) == False:
            n_result = self.c_comm.RESULT.RESULT_INVALID_SESSION_ID
            return n_result, s_content

        # read session data
        self.c_share.parse(self.c_sess.getSessionData(session))
        
        # appointed directory.
        s_src  = self._path_share_join( src )
        s_dest = self._path_share_join( dest )

        # check exists. 
        s_src = self.c_comm.GetNameNoCase(s_src)
        s_dest = self.c_comm.GetNameNoCase(s_dest)
        if self._is_symlink( s_src ) == True:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content
        if self._is_symlink( s_dest ) == True:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content

        if os.path.exists( s_src ) == False:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content

        if self._path_share_check(s_src) == False:
            n_result = self.c_comm.RESULT.RESULT_ERR_INVALID_FILE
            return n_result, s_content
        if self._path_share_check(s_dest) == False:
            n_result = self.c_comm.RESULT.RESULT_ERR_INVALID_FILE
            return n_result, s_content

        c_path = self._path_share_current(s_src)
        if self.c_share.isFound(c_path) == False:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content

        c_path = self._path_share_current(s_dest)
        if self.c_share.isFound(c_path) == False:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content
        if self.c_share.isWrite(c_path) == False:
            n_result = self.c_comm.RESULT.RESULT_ERR_PERMISSION
            return n_result, s_content
        s_uid = str(self.c_share.getuid(c_path))
        s_gid = str(self.c_share.getgid(c_path))
        
        if self._path_share_count(s_src) < 1:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content
        if self._path_share_count(s_dest) < 1:
            n_result = self.c_comm.RESULT.RESULT_ERR_INVALID_FILE
            return n_result, s_content

        # check file type
        if os.path.isdir( s_src ) and os.path.isfile( s_dest ):
            n_result = self.c_comm.RESULT.RESULT_ERR_NOT_DIR
            return n_result, s_content

        # call move command
        s_cmd = self._path_rapslibpath_join("rapsmove.py")
        try:
            n_result = self.c_comm.sudo([ s_cmd, s_uid, s_gid, s_src, s_dest ])
        except:
            n_result = self.c_comm.RESULT.RESULT_ERR_INTERNAL

        return n_result, s_content

    def copy(self, session, src, dest):
        #
        # move file and directory.
        #
        n_result  = self.c_comm.RESULT.RESULT_NO_ERROR
        s_content = ""

        # session check
        if self.c_sess.check(session) == False:
            n_result = self.c_comm.RESULT.RESULT_INVALID_SESSION_ID
            return n_result, s_content

        # read session data
        self.c_share.parse(self.c_sess.getSessionData(session))
        
        # appointed directory.
        s_src  = self._path_share_join( src )
        s_dest = self._path_share_join( dest )

        # check exists. 
        s_src = self.c_comm.GetNameNoCase(s_src)
        s_dest = self.c_comm.GetNameNoCase(s_dest)
        if self._is_symlink( s_src ) == True:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content
        if self._is_symlink( s_dest ) == True:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content

        if os.path.exists( s_src ) == False:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content

        if self._path_share_check(s_src) == False:
            n_result = self.c_comm.RESULT.RESULT_ERR_INVALID_FILE
            return n_result, s_content

        if self._path_share_check(s_dest) == False:
            n_result = self.c_comm.RESULT.RESULT_ERR_INVALID_FILE
            return n_result, s_content

        c_path = self._path_share_current(s_src)
        if self.c_share.isFound(c_path) == False:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content

        c_path = self._path_share_current(s_dest)
        if self.c_share.isFound(c_path) == False:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content
        if self.c_share.isWrite(c_path) == False:
            n_result = self.c_comm.RESULT.RESULT_ERR_PERMISSION
            return n_result, s_content
        s_uid = str(self.c_share.getuid(c_path))
        s_gid = str(self.c_share.getgid(c_path))

        if self._path_share_count(s_src) < 1:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content
        if self._path_share_count(s_dest) < 1:
            n_result = self.c_comm.RESULT.RESULT_ERR_INVALID_FILE
            return n_result, s_content

        # check file type
        if os.path.isdir( s_src ) and os.path.isfile( s_dest ):
            n_result = self.c_comm.RESULT.RESULT_ERR_NOT_DIR
            return n_result, s_content

        # call move command
        s_cmd = self._path_rapslibpath_join("rapscopy.py")
        try:
            n_result = self.c_comm.sudo([ s_cmd, s_uid, s_gid, s_src, s_dest ])
        except:
            n_result = self.c_comm.RESULT.RESULT_ERR_INTERNAL

        return n_result, s_content

    def delete(self, session, path):
        #
        # Deletion of a specification path.
        #
        n_result  = self.c_comm.RESULT.RESULT_NO_ERROR
        s_content = ""

        # session check
        if self.c_sess.check(session) == False:
            n_result = self.c_comm.RESULT.RESULT_INVALID_SESSION_ID
            return n_result, s_content

        # read session data
        self.c_share.parse(self.c_sess.getSessionData(session))

        # appointed directory.
        s_src = self._path_share_join( path )

        if self._is_symlink( s_src ) == True:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content

        # check exists. 
        if os.path.exists( s_src ) == False:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content

        if self._path_share_check(s_src) == False:
            n_result = self.c_comm.RESULT.RESULT_ERR_INVALID_FILE
            return n_result, s_content

        c_path = self._path_share_current(s_src)
        if self.c_share.isFound(c_path) == False:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content
        if self.c_share.isWrite(c_path) == False:
            n_result = self.c_comm.RESULT.RESULT_ERR_PERMISSION
            return n_result, s_content
        s_uid = str(self.c_share.getuid(c_path))
        s_gid = str(self.c_share.getgid(c_path))

        if self._path_share_count(s_src) == 1:
            n_result = self.c_comm.RESULT.RESULT_ERR_INVALID_FILE
            return n_result, s_content
        if self._path_share_count(s_src) < 1:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content

        # call delete command
        s_cmd = self._path_rapslibpath_join("rapsdelete.py")
        try:
            n_result = self.c_comm.sudo([ s_cmd, s_uid, s_gid, s_src ])
        except:
            n_result = self.c_comm.RESULT.RESULT_ERR_INTERNAL
        
        # delete thumbnail 
        # It is not processed in recursive deletion processing. 
        if n_result == self.c_comm.RESULT.RESULT_NO_ERROR:
            try:
                rapsmminfo.Thumbnail(self, self.c_comm).delete(path)
            except:
                pass

        return n_result, s_content

    def download(self, session, path, offset, maxsize):
        #
        # Transmission of specification file data.
        #
        n_result  = self.c_comm.RESULT.RESULT_NO_ERROR
        s_content = ""

        # session check
        if self.c_sess.check(session) == False:
            n_result = self.c_comm.RESULT.RESULT_INVALID_SESSION_ID
            return n_result, s_content

        # read session data
        self.c_share.parse(self.c_sess.getSessionData(session))

        key = self.c_share.get_timelimit_key()
        if key:
            path = self._get_timelimit_access_path(key, path, True)
            if not path:
                n_result = self.c_comm.RESULT.RESULT_ERR_PERMISSION
                return n_result, s_content

        # appointed directory.
        s_src = self._path_share_join( path )

        if self._is_symlink( s_src ) == True:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content

        # check exists. 
        if os.path.exists( s_src ) == False:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content

        if self._path_share_check(s_src) == False:
            n_result = self.c_comm.RESULT.RESULT_ERR_INVALID_FILE
            return n_result, s_content

        c_path = self._path_share_current(s_src)
        if self.c_share.isFound(c_path) == False:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content
        
        if self._path_share_count(s_src) < 2:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content

        # check dirs. 
        if os.path.isdir( s_src ) == True:
            n_result = self.c_comm.RESULT.RESULT_ERR_IS_DIR
            return n_result, s_content

        return n_result, s_content

    def download_file(self, path, offset = 0, maxsize = 0):
        #
        # Transmission of specification file data.
        #

        # download proc
        try:
            fp = open( path , "rb") 
            sys.stdout.write( codecs.BOM_BE + "\r\n" )
            if maxsize == 0:
                maxsize = os.path.getsize( path )
                maxsize -= offset
            fp.seek(offset)

            remainingsize = maxsize
            readsize = self.BLOCK_SIZE
            while True:
                if remainingsize < readsize:
                    readsize = remainingsize
                buff = fp.read( readsize )
                if not buff:
                    break
                sys.stdout.write(buff)
                remainingsize -= readsize

            fp.close()

        except:
            self.c_comm.logout(tb.format_exc())
            return False

        return True

    def _utime(self, s_uid, s_gid, mtime, s_path):
        if mtime != "":
           s_cmd = self._path_rapslibpath_join("rapsutime.py")
           try:
               self.c_comm.sudo([ s_cmd, s_uid, s_gid, mtime, s_path ])
           except:
               pass
 
    def upload(self, session, path, offset, mtime, overwrite, datalen ):
        #
        # Acquisition of specification file data.
        #
        n_result  = self.c_comm.RESULT.RESULT_NO_ERROR
        s_content = ""
        b_overwrite = False
        n_size = 0
        
        if overwrite.lower() == "true":
            b_overwrite = True

        # session check
        if self.c_sess.check(session) == False:
            n_result = self.c_comm.RESULT.RESULT_INVALID_SESSION_ID
            return n_result, s_content

        # read session data
        self.c_share.parse(self.c_sess.getSessionData(session))

        # set upload tmp path
        s_tmp_path = self._get_upload_tmp_path( session, path )

        # appointed directory.
        s_path = self._path_share_join( path )

        if self._is_symlink( s_path ) == True:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content

        # file exists check
        b_exist = self.c_comm.IsExistNoCase( s_path )
        if b_overwrite == False and b_exist == True:
            n_result = self.c_comm.RESULT.RESULT_ERR_EXIST
            return n_result, s_content
        if b_exist == True:
            s_path = self.c_comm.GetNameNoCase(s_path)
        if self._path_share_check(s_path) == False:
            n_result = self.c_comm.RESULT.RESULT_ERR_INVALID_FILE
            return n_result, s_content

        c_path = self._path_share_current(s_path)
        if self.c_share.isFound(c_path) == False:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content
        if self.c_share.isWrite(c_path) == False:
            n_result = self.c_comm.RESULT.RESULT_ERR_PERMISSION
            return n_result, s_content
        s_uid = str(self.c_share.getuid(c_path))
        s_gid = str(self.c_share.getgid(c_path))
        
        if self._path_share_count(s_path) < 2:
            n_result = self.c_comm.RESULT.RESULT_ERR_INVALID_FILE
            return n_result, s_content

        # file size check
        if datalen != 0:
            if (offset + datalen) > self.c_comm.CONFIG.MAX_UPLOAD:
                n_result = self.c_comm.RESULT.RESULT_ERR_TOO_LARGE_FILE
                return n_result, s_content
       
        # file create and set permisson
        s_cmd = self._path_rapslibpath_join("rapscreate.py")
        try:
            n_result = self.c_comm.sudo([ s_cmd, s_uid, s_gid, s_tmp_path ])
            if n_result != self.c_comm.RESULT.RESULT_NO_ERROR:
                return n_result, s_content
        except:
            n_result = self.c_comm.RESULT.RESULT_ERR_INTERNAL
            return n_result, s_content

        # upload proc
        try:
            # tmp path upload
            fp = open( s_tmp_path , "r+b" ) 

            if datalen != 0:
                aftersize = datalen
                if aftersize > self.BLOCK_SIZE:
                    readsize = self.BLOCK_SIZE;
                else:
                    readsize = datalen;
                buff = sys.stdin.read( readsize )
                while buff != "":
                    # size check
                    n_size += len(buff)
                    if n_size > self.c_comm.CONFIG.MAX_UPLOAD:
                        n_result = self.c_comm.RESULT.RESULT_ERR_TOO_LARGE_FILE
                        break
                    fp.write(buff)
                    aftersize -= readsize
                    if aftersize <= 0:
                        break
                    if aftersize > self.BLOCK_SIZE:
                        readsize = self.BLOCK_SIZE;
                    else:
                        readsize = aftersize;
                    buff = sys.stdin.read( readsize )
                if readsize-n_size > 0 or aftersize > 0:
                    n_result = self.c_comm.RESULT.RESULT_INVALID_OPTION

            fp.close()

            if n_result != self.c_comm.RESULT.RESULT_NO_ERROR:
                os.unlink(s_tmp_path)

            elif offset != 0: 
                # tmp path data to real path
                tmp_path_fp = open( s_tmp_path , "rb" ) 
                path_fp = open( s_path , "r+b" ) 

                path_fp.seek(offset)

                buff = tmp_path_fp.read( 65536 )
                while buff:
                    path_fp.write(buff)
                    buff = tmp_path_fp.read( 65536 )

                tmp_path_fp.close()
                path_fp.close()

                os.unlink(s_tmp_path)

                self._utime(s_uid, s_gid, mtime, s_path)

            else:
                self._utime(s_uid, s_gid, mtime, s_tmp_path)

                # tmp path move to real path
                os.rename(s_tmp_path, s_path)

        except (IOError, OSError), e:
            try:
                os.unlink(s_tmp_path)
            except:
                pass

            if  e.errno == errno.ENOENT:
                n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            elif e.errno == errno.ENOSPC or e.errno == errno.EDQUOT:
                n_result = self.c_comm.RESULT.RESULT_ERR_FILESYSTEM_FULL
            elif e.errno == errno.EACCES:
                n_result = self.c_comm.RESULT.RESULT_ERR_PERMISSION
            else:
                n_result = self.c_comm.RESULT.RESULT_ERR_WRITE
        
        except Exception ,e:
            try:
                os.unlink(s_tmp_path)
            except:
                pass

            n_result = self.c_comm.RESULT.RESULT_ERR_WRITE

        return n_result, s_content

    def geturl(self, session, path, protocol, expire):
        #
        # Acquisition of URL in which temporary
        # access to a specification file is possible. 
        #
        n_result  = self.c_comm.RESULT.RESULT_NO_ERROR
        s_content = ""
        c_link    = rapslink.rapslink(self.c_comm)
        s_addr    = ""

        # session check
        if self.c_sess.check(session) == False:
            n_result = self.c_comm.RESULT.RESULT_INVALID_SESSION_ID
            return n_result, s_content

        # read session data
        self.c_share.parse(self.c_sess.getSessionData(session))

        key = self.c_share.get_timelimit_key()
        if key:
            path = self._get_timelimit_access_path(key, path, True)
            if not path:
                n_result = self.c_comm.RESULT.RESULT_ERR_PERMISSION
                return n_result, s_content

        # appointed directory.
        s_path = self._path_share_join( path )

        if self._is_symlink( s_path ) == True:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content

        # check exists. 
        if os.path.exists( s_path ) == False:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content

        if self._path_share_check(s_path) == False:
            n_result = self.c_comm.RESULT.RESULT_ERR_INVALID_FILE
            return n_result, s_content

        c_path = self._path_share_current(s_path)
        if not key and self.c_share.isFound(c_path) == False:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content
        
        if self._path_share_count(s_path) < 2:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_content

        # check file type
        if os.path.isdir( s_path ) == True:
            n_result = self.c_comm.RESULT.RESULT_ERR_IS_DIR
            return n_result, s_content
        if os.path.isfile( s_path ) == False:
            n_result = self.c_comm.RESULT.RESULT_ERR_INVALID_FILE
            return n_result, s_content

        # call getinfo
        entry = request.Entry(INFO_TYPE, FAL_REMOTEACCESSS_REQ_BASE_XML[INFO_TYPE])
        response_entry = self._call_fal_command( entry, FAL_REMOTEACCESS_PATH )
        if response_entry != None:
            if response_entry.get_result() != OK:
                n_result = self.c_comm.RESULT.RESULT_ERROR
            else:
                try:
                    resxml = response_entry.get().to_str()
                    dom = xml.dom.minidom.parseString(resxml)
                    ct_nd = dom.getElementsByTagName("connectinfo")
                    if ct_nd != None:
                        for node in ct_nd:
                            _protocol = node.getAttribute("protocol")
                            if protocol.lower() == _protocol.lower():
                                host_nd = node.getElementsByTagName("hostname")
                                if host_nd.length > 0:
                                    s_addr = host_nd[0].childNodes[0].data
                                port_nd = node.getElementsByTagName("port")
                                try:
                                    if port_nd.length > 0:
                                        s_port = port_nd[0].childNodes[0].data
                                        if s_port != "":
                                            s_addr += ":"
                                            s_addr += s_port
                                except:
                                    pass

                    else:
                        n_result = self.c_comm.RESULT.RESULT_INVALID_XML

                except:
                    n_result = self.c_comm.RESULT.RESULT_INVALID_XML

        else:
            n_result = self.c_comm.RESULT.RESULT_ERROR

        if len(s_addr) == 0:
            self.c_comm.logout("*** call fal_remoteaccess(no protocol) ***")
            self.c_comm.logout("no protocol=" + protocol)
            n_result = self.c_comm.RESULT.RESULT_ERROR

        if n_result == self.c_comm.RESULT.RESULT_NO_ERROR:
            # create link file
            n_result, s_url = c_link.create(s_path, protocol, s_addr, expire)
            if n_result == self.c_comm.RESULT.RESULT_NO_ERROR:
                s_content  = "<file>"
                s_content += "<url>" + s_url + "</url>"
                s_content += "</file>"

        return n_result, s_content

    def disableurl( self, session, url ):
        #
        # URL which can be accessed temporary is repealed.
        #
        n_result  = self.c_comm.RESULT.RESULT_NO_ERROR
        s_content = ""
        c_link    = rapslink.rapslink(self.c_comm)

        # session check
        if self.c_sess.check(session) == False:
            n_result = self.c_comm.RESULT.RESULT_INVALID_SESSION_ID
            return n_result, s_content

        # disable link file
        n_result = c_link.disable(url)
        
        return n_result, s_content

    def _call_fal_command(self, request_entry, command, sudo=True):
        #
        # call fal command 
        #
        response_entry = None
        try:
            self.c_comm.logout("command = " + command)
            self.c_comm.logout("request_entry = " + str(request_entry))
            response_entry = request.Request(command, filter_cmd=SUDO_CMD if sudo else '').request(request_entry).get_entry()
            self.c_comm.logout("response_entry = " + str(response_entry))
        except Exception ,exc:
            self.c_comm.logout(tb.format_exc())
            raise exc

        return response_entry
    
    def _get_share_root(self, path):
        #
        # Return share root of a path 
        #
        share_name = self._path_to_share_name(path)
        share_root = self.c_comm.CONFIG.SHARE_PATH
        if share_name in self.c_comm.CONFIG.EXT_SHARE_LIST:
            share_root = self.c_comm.CONFIG.EXT_SHARE_PATH
        return share_root

    def _get_share_root_by_full_path(self, full_path):
        #
        # Return share path of a full_path 
        #
        share_root = self.c_comm.CONFIG.SHARE_PATH.rstrip("/")
        if full_path.startswith(share_root) == True:
            return share_root
        share_root = self.c_comm.CONFIG.EXT_SHARE_PATH
        for ext_share in self.c_comm.CONFIG.EXT_SHARE_LIST:
            ext_share_path = os.path.join(share_root, ext_share)
            if full_path.startswith(ext_share_path) == True:
                return share_root
        return ""

    def _path_share_join(self, path):
        #
        # Combination of a path 
        #
        if path[0:1] == "/":
            path = path[1:]
        try:
            path = os.path.join(self._get_share_root(path), path)
            path = os.path.abspath(path)
        except:
            pass

        return path

    def _path_share_check(self, path):
        #
        # share path check 
        #
        if self._get_share_root_by_full_path(path):
            return True
        return False

    def _path_share_current(self, path):
        #
        # get share current path 
        #
        share_path = self._get_share_root_by_full_path(path)
        if share_path:
            return path[len(share_path.rstrip("/"))+1:]
        return ""

    def _path_share_count(self, path):
        #
        # Combination of a path 
        #
        _Count = 0
        path = path.strip("/")
        share_path = self._get_share_root_by_full_path(path)
        try:
            _Count  = len(path.split("/"))
            _Count -= len(share_path.strip("/").split("/"))
        except:
            pass
        return _Count

    def _path_share_size(self, path):
        #
        # Combination of a share path length 
        #
        share_root = self._get_share_root(path)
        return len(share_root.rstrip("/"))

    def _path_thumb_join(self, path):
        #
        # Combination of a path 
        #
        if path[0:1] == "/":
            path = path[1:]
        try:
            path = os.path.join(self.c_comm.CONFIG.CACHE_PATH, path)
        except:
            pass

        return path

    def _path_current_join(self, path):
        #
        # Combination of a current path 
        #
        if path[0:1] == "/":
            path = path[1:]
        s_current = self.c_comm.GetCurrent() 
        try:
            path = os.path.join(s_current, path)
        except:
            pass

        return path

    def _path_rapslibpath_join(self, path):
        #
        # Combination of a rapslib path 
        #
        if path[0:1] == "/":
            path = path[1:]
        rapslibpath = self.c_comm.GetRapsLibPath() 
        rapslibpath_join = os.path.join(rapslibpath, path)
        return rapslibpath_join

    def _is_symlink(self, path):
        #
        # Is symlink.
        #
        while path:
            path = path.rstrip(os.sep)
            if os.path.islink(path):
                return True

            path = os.path.split(path)[0]

        return False

    def _path_to_share_name(self, path):
        #
        # Path to share name.
        #
        return path.strip("/").split("/")[0]

    def _get_unique_str(self, text):
        #
        # Get unique str.
        #
        return hashlib.md5(text + str(time.time())).hexdigest()

    def _get_upload_tmp_path(self, session, path):
        #
        # Get upload tmp path.
        #
        share_name = self._path_to_share_name(path)

        if share_name in self.c_comm.CONFIG.EXT_SHARE_LIST:
            dir_path = os.path.join(self.c_comm.CONFIG.EXT_SHARE_PATH,
                                        share_name)
        else:
            dir_path = self.c_comm.CONFIG.UPLOAD_TMP_DIR
            if not os.path.exists(dir_path):
                os.makedirs(dir_path)
                os.chmod(dir_path, FULL_PERM)

        file_name = ".".join([self.c_comm.CONFIG.UPLOAD_TMP_NAME,
                              self._get_unique_str(session)])

        return os.path.join(dir_path, file_name)
 
