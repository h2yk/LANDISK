# -*- mode: landisk-python; coding: utf-8; -*-
# vim:ts=4 sw=4 sts=4 ai si et sta

"""Module to manage mapping between the path and its ID."""


from collections import deque


DEFAULT_MAX_PATHS = 2
PATH_SEPARATOR = "/"


class PathIdTree:
    """Class to manage a tree of the path and its ID pair."""

    class _Entry:
        """Class corresponding to each entry in a directory."""

        def __init__(self, name, parent, id=None):
            """Constructor."""

            self.name = name
            self.id = id
            self.parent = parent
            self.children = {}

        def set_name(self, name):
            """Set name to "name"."""

            self.name = name
            return self.name

        def set_id(self, id):
            """Set ID to "id"."""

            self.id = id
            return self.id

        def get_name(self):
            """Return name."""

            return self.name

        def get_id(self):
            """Return ID."""

            return self.id

        def get_parent(self):
            """return a parent."""

            return self.parent

        def append(self, child):
            """Append a child."""

            self.children[child.get_name()] = child
            return self

        def get_child(self, name):
            """return a child whose name is "name"."""

            return self.children[name]

        def get_child_names(self, name):
            """return the child name iterator."""

            return self.children.iterkeys()

        def get_children(self):
            """Return the child entry iterator."""

            return self.children.itervalues()

        def delete_child(self, name):
            """return a child whose name is "name"."""

            child = self.children[name]
            del self.children[name]
            return child

    #
    # Member Method
    #
    def _split_path(self, path):
        """Return the list of name splited from "path"."""

        name_list = []
        if path.startswith(self.separator):
            name_list.append(self.separator)
            path = path[len(self.separator):]

        for name in path.split(self.separator):
            if not name:
                # Ignore a series of the separator.
                continue

            name_list.append(name)

        return name_list

    def _join_path(self, name_list):
        """Return the path joined each name in "name_list" to."""

        if name_list[0] != self.separator:
            return self.separator.join(name_list)

        return self.separator + \
                self.separator.join(name_list[1:])

    def _find_entry(self, path):
        """Return the "_Entry" class instance corresponding to "path"."""

        cur_entry = self.top_entry
        for name in self._split_path(path):
            try:
                cur_entry = cur_entry.get_child(name)
            except:
                raise LookupError(path)

        if cur_entry == self.top_entry:
            raise LookupError(path)
        return cur_entry

    def _update_child_ids(self, entry, other_entry):
        """Update each child entry's ID by ID in the "other_entry"."""

        for child in entry.get_children():
            try:
                other = other_entry.get_child(child.get_name())
                child.set_id(other.get_id())
                self._update_child_ids(child, other)
            except:
                continue

    def __init__(self, separator):
        """Constructor."""

        self.separator = separator
        self.top_entry = self._Entry("", None)

    def get_id(self, path):
        """Return a ID mapped to "path"."""

        return self._find_entry(path).get_id()

    def set_id(self, path, id):
        """Set a ID corresponding to "path" to "id"."""

        self._find_entry(path).set_id(id)
        return id

    def update_ids(self, path_id_tree):
        """Update each entry's ID by ID in the "path_id_tree"."""

        self._update_child_ids(self.top_entry, path_id_tree.top_entry)

    def append_path(self, path, id=None):
        """Set the path to "path"."""

        cur_entry = self.top_entry
        for name in self._split_path(path):
            try:
                cur_entry = cur_entry.get_child(name)
            except:
                cur_entry = self._Entry(name, cur_entry)
                cur_entry.get_parent().append(cur_entry)

        if cur_entry != self.top_entry and id != None:
            cur_entry.set_id(id)
        return self

    def get_ancestor_set_id(self, path):
        """Return the ancestor of "path" whose ID is set."""

        path_split_list = self._split_path(path)
        cur_entry = self._find_entry(path)
        while cur_entry != None:
            if len(path_split_list):
                path_split_list.pop()
            cur_entry = cur_entry.get_parent()
            if cur_entry != None and cur_entry.get_id() != None:
                return self._join_path(path_split_list)

        raise LookupError(path)

    def delete_path(self, path):
        """Set the path to "path"."""

        entry = self._find_entry(path)
        entry.get_parent().delete_child(entry.get_name())


class PathIdMap(PathIdTree):
    """Class to manage mapping between path and its ID."""

    def _is_ancestor_or_same(self, path, full_path):
        """Check if "path" is ancestor of "full_path" or same."""

        if path == full_path:
            return True

        if not path.endswith(self.separator):
            path += self.separator

        return full_path.startswith(path)

    def _should_path_be_uncached(self, path):
        """Check if "path" should be uncached."""

        for cached_path in self.path_list:
            if self._is_ancestor_or_same(path, cached_path):
                return False

        return True

    def _try_uncache(self, old_path):
        """Try uncache old path "old_path" from path tree."""

        if not old_path:
            return

        cur_entry = self.top_entry
        path = ""
        for name in self._split_path(old_path):
            try:
                cur_entry = cur_entry.get_child(name)
                if not path or path == self.separator:
                    path += name
                else:
                    path += self.separator + name

                if self._should_path_be_uncached(path):
                    self.delete_path(path)
                    return
            except:
                return

    def __init__(self, max_paths=DEFAULT_MAX_PATHS,
            separator=PATH_SEPARATOR):
        """Constructor."""

        self.max_paths = max_paths
        self.path_list = deque(maxlen=max_paths)
        PathIdTree.__init__(self, separator)

    def append_directory(self, path, id=None):
        """Append the directory "path" into a tree and a internal list and
           try uncache the old directory entry.
        """

        if path in self.path_list:
            return self

        PathIdTree.append_path(self, path, id)
        old_path = ""
        if len(self.path_list):
            old_path = self.path_list[0]
        self.path_list.append(path)
        self._try_uncache(old_path)
        return self
