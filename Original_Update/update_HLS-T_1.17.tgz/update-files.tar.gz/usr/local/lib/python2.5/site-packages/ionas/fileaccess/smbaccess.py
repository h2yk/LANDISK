#!/usr/bin/env python
# -*- mode: landisk-python; coding: utf-8; -*-
# vim:ts=4 sw=4 sts=4 ai si et sta

from __future__ import with_statement

from ..fileaccess import (MODE_READ, MODE_WRITE, MODE_APPEND,
    ST_MODE_DIR, ST_MODE_FILE, DEFAULT_LOCALE, DEBUG)
from ionas.exception import *
from filelikeobj import FileLikeObj


import os
import sys
import stat
import errno
import locale
import smbc

SMBC_TYPE_DIR = 7
BUF_SIZE = 65536

IS_A_DIRECTORY_ERROR = 21

RETRY_COUNT = 3

SMB_PREFIX = "smb://"

NON_SUPPORTED_CHARACTERS = [':', '*', '?', '"', '<', '>', '|']


def is_include_non_supp_character(path):

    if path.startswith(SMB_PREFIX):
        _path = path[len(SMB_PREFIX):]
    else:
        _path = path

    for character in NON_SUPPORTED_CHARACTERS:
        if character in _path:
            return True
    return False


def smbc_except_handler(path):
    exc_ins = sys.exc_info()[1]
    if isinstance(exc_ins, smbc.PermissionError):
        raise PermissionError(exc_ins, path)
    if isinstance(exc_ins, smbc.NoSpaceError):
        raise NoSpaceError(exc_ins, path)
    if isinstance(exc_ins, smbc.NoEntryError):
        raise NoEntryError(exc_ins, path)
    if isinstance(exc_ins, smbc.ExistsError):
        raise ExistsError(exc_ins, path)
    if isinstance(exc_ins, RuntimeError):
        if exc_ins.args:
            if exc_ins.args[0] == IS_A_DIRECTORY_ERROR:
                raise ExistsError(exc_ins, path)
            if exc_ins.args[0] == errno.EINVAL or errno.ENOTDIR:
                if is_include_non_supp_character(path):
                    raise NonSupportedFileError(exc_ins, path)
            if exc_ins.args[0] == errno.EBUSY:
                raise BusyError(exc_ins, path)
    if isinstance(exc_ins, smbc.TimedOutError):
        raise TimedOutError(exc_ins, path)
    raise


class SmbFileObj(FileLikeObj):

    
    def __renew_file(self):

        count = 0
        while True:
            try:
                self.file = self.accessor.get_renewed_fileobj(
                                self.path, self.mode)
                return
            except:
                try:
                    smbc_except_handler(self.path)
                except RuntimeError:
                    if count >= RETRY_COUNT:
                        raise
                count += 1

    def __call_and_retry_with_renew(self, func, file_like=None):
        count = 0
        while True:
            try:
                return func()
            except:
                try:
                    smbc_except_handler(self.path)
                except RuntimeError:
                    if count >= RETRY_COUNT:
                        raise

                    self.__renew_file()
                    if hasattr(file_like, "seek"):
                        file_like.seek(0)

                    count += 1

    def __init__(self, file, path, mode, accessor):

        FileLikeObj.__init__(self, file, path)
        self.mode = mode
        self.accessor = accessor

    def __len__(self):

        # FIXME len()はint型をかえす必要あり。巨大size大丈夫か
        return int(self.file.fstat()[stat.ST_SIZE])

    def tell(self):

        # FIXME amazon用。
        # read完了しても0にならないが問題あるか?
        # とりあえずNotImplement
        #return self.point
        raise NotImplementedError

    def seek(self, offset, whence=os.SEEK_SET):

        # FIXME エラー処理どうする
        # writeの場合のpointはサポートしないがよいか
        # とりあえずNotImplement
        #if whence == os.SEEK_SET:
        #    self.point = offset
        #elif whence == os.SEEK_CUR:
        #    self.point += offset
        #elif whence == os.SEEK_END:
        #    self.point = len(self) - offset
        raise NotImplementedError

    def get_path(self):

        # FIXME get_pathがNotImpleであることによって
        # writedirect,readdirectをつかえないことになっている
        # このような実装でよいのか
        raise NotImplementedError

    def __read(self, size):

        self.point += size
        return self.file.read(size)

    def __write(self, file_like):

        while True:
            buf = file_like.read(BUF_SIZE)
            if not buf:
                break
            try:
                self.file.write(buf)
            except:
                smbc_except_handler(self.path)

    def __read_by_path(self, file_like):

        try:
            # FIXME 一度に書いて大丈夫か?
            self.file.readdirect(file_like.get_path())
        except:
            smbc_except_handler(self.path)

    def __write_by_path(self, file_like):

        try:
            # FIXME 一度に書いて大丈夫か?
            self.file.writedirect(file_like.get_path())
        except:
            smbc_except_handler(self.path)

    def __close(self):

        try:
            self.file.close()
        except:
            smbc_except_handler(self.path)

    def read(self, size):

        func = lambda: self.__read(size)
        return self.__call_and_retry_with_renew(func)

    def write(self, file_like):

        func = lambda: self.__write(file_like)
        return self.__call_and_retry_with_renew(func, file_like)

    def write_by_path(self, file_like):

        func = lambda: self.__write_by_path(file_like)
        return self.__call_and_retry_with_renew(func, file_like)

    def read_by_path(self, file_like):

        func = lambda: self.__read_by_path(file_like)
        return self.__call_and_retry_with_renew(func, file_like)

    def close(self):

        func = lambda: self.__close()
        return self.__call_and_retry_with_renew(func)


class SmbAccess():

    def __call_and_retry(self, func, path):
        count = 0
        while True:
            try:
                return func()
            except:
                try:
                    smbc_except_handler(path)
                except RuntimeError:
                    if count >= RETRY_COUNT:
                        raise

                    # Retry
                    count += 1

    def __conv_percent(self, path):
        """smbd operates a file after percent-decoding file name.
           So if a file path has %, we must encode % to %25.
        """
        return path.replace("%", "%25")

    def get_renewed_fileobj(self, path, mode):
        """Renew file obj and return it"""

        del self.__ctx
        self.__ctx = smbc.Context(auth_fn=self.auth_fn)
        return self.__ctx.open(self.__conv_percent(path),
                               self.__to_open_flag(mode))

    def __listdir(self, path, type_filter):
        list = []
        for entry in self.__ctx.opendir(path).getdents():
            entry_name = entry.name
            if isinstance(entry_name, unicode):
                entry_name = entry_name.encode(self.encoding)

            if entry_name == "." or entry_name == "..":
                continue
            if type_filter:
                if entry.smbc_type in type_filter:
                    list += [entry_name]
            else:
                list += [entry_name]
        return list

    def __to_open_flag(self, mode):
        if mode == MODE_READ:
            return os.O_RDONLY
        if mode == MODE_WRITE:
            return os.O_WRONLY | os.O_CREAT | os.O_TRUNC
        if mode == MODE_APPEND:
            return os.O_APPEND | os.O_WRONLY | os.O_CREAT

    def __rmdir(self, path):
        try:
            self.__ctx.rmdir(path)
        except smbc.NoEntryError:
            raise NoEntryError
        except smbc.NotEmptyError:
            for entry in self.__ctx.opendir(path).getdents():
                if entry.name == "." or entry.name == "..":
                    continue
                entry_path = \
                    self.sep.join([path, self.__conv_percent(entry.name)])
                if entry.smbc_type != SMBC_TYPE_DIR:  # is not Directory
                    self.__ctx.unlink(entry_path)
                else:  # is Directory
                    self.__rmdir(entry_path)
            self.__ctx.rmdir(path)

    def __init__(self, user, passwd, encoding=""):
        self.sep = "/"
        
        if encoding:
            self.encoding = encoding
        else:
            self.encoding = locale.getdefaultlocale()[1]
            if not self.encoding:
                self.encoding = DEFAULT_LOCALE

        self.auth_fn = lambda srv, share, wg, username, pw: (wg, user, passwd)
        self.__ctx = smbc.Context(auth_fn=self.auth_fn)
        self.encoding = locale.getdefaultlocale()[1]
        if not self.encoding:
            self.encoding = DEFAULT_LOCALE
        # FIXME インスタンスコピーの仕組みどうする。
        # 一見Fullには不要そうだが

        self.WORKGROUP_TYPE = smbc.WORKGROUP
        self.SERVER_TYPE = smbc.SERVER
        self.FILE_SHARE_TYPE = smbc.FILE_SHARE
        self.COMMS_SHARE_TYPE = smbc.COMMS_SHARE
        self.IPC_SHARE_TYPE = smbc.IPC_SHARE

    def listdir(self, path, type_filter=[]):
        func = lambda: self.__listdir(self.__conv_percent(path),
                                      type_filter)
        return self.__call_and_retry(func, path)

    def isdir(self, entry):  # FIXME 高速化するなら必要かも
        pass

    def open(self, path, mode):
        func = lambda: SmbFileObj(
                    self.__ctx.open(self.__conv_percent(path),
                                    self.__to_open_flag(mode)),
                    path, mode, accessor=self)
        return self.__call_and_retry(func, path)

    def __stat(self, path):

        stat_data = self.__ctx.stat(path)

        if stat.S_ISDIR(stat_data[stat.ST_MODE]):
            return stat_data

        fh = self.__ctx.open(path, os.O_RDONLY)
        stat_data = fh.fstat()
        fh.close()
        return stat_data

    def stat(self, path):

        func = lambda: self.__stat(self.__conv_percent(path))
        return self.__call_and_retry(func, path)

    def chmod(self, path, mode):
        func = lambda: self.__ctx.chmod(self.__conv_percent(path), mode)
        self.__call_and_retry(func, path)

    def utime(self, path, mtime):
        if not mtime and mtime != 0:
            raise InternalError
        func = lambda: self.__ctx.utime(self.__conv_percent(path),
                                        (mtime, mtime))
        self.__call_and_retry(func, path)

    def remove(self, path):
        func = lambda: self.__ctx.unlink(self.__conv_percent(path))
        self.__call_and_retry(func, path)

    def rmdir(self, path):
        func = lambda: self.__rmdir(self.__conv_percent(path))
        self.__call_and_retry(func, path)

    def mkdir(self, path):
        func = lambda: self.__ctx.mkdir(self.__conv_percent(path))
        self.__call_and_retry(func, path)

    def move(self, src, dst):
        func = lambda: self.__ctx.rename(self.__conv_percent(src),
                                         self.__conv_percent(dst))
        # FIXME 要因がsrc,dstのどちらにあるか判別不可
        self.__call_and_retry(func, dst)
