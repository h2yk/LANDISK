# -*- mode: landisk-python; coding: utf-8; -*-
# vim:ts=4 sw=4 sts=4 ai si et sta

"""XML Data module.

Define classes for processing XML data.
"""


import re
import string

try:
    try:
        import lxml.etree as etree
    except:
        import xml.etree.cElementTree as etree
except ImportError:
    try:
        import cElementTree as etree
    except:
        import elementtree.ElementTree as etree

from iobase.exception import (NotFoundError, InvalidArgError)


ROOT_PATH = "./."
ANY_CHILD_PATH = "*"
ANY_CHILD_NAME = "*"

UNICODE = "unicode"


XML_TAG_START = "<"
UTF8_BOM = "\xef\xbb\xbf"
UTF16LE_BOM = "\xff\xfe"
UTF16BE_BOM = "\xfe\xff"
UTF16LE_XML_TAG_START = "<\x00"
UTF16BE_XML_TAG_START = "\x00<"

UTF8_ENC = "utf-8"
UTF16_ENC = "utf-16"
UTF16LE_ENC = "utf-16le"
UTF16BE_ENC = "utf-16be"
UTF_ENC_LIST = (UTF8_ENC, UTF16_ENC, UTF16LE_ENC, UTF16BE_ENC)
UTF16_ENC_LIST = (UTF16_ENC, UTF16LE_ENC, UTF16BE_ENC)

UTF16_BOM_DICT = {UTF16LE_ENC: UTF16LE_BOM, UTF16BE_ENC: UTF16BE_BOM}


_DESCENDANT_BASE = ".//"


def escape(text):
    return text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')


def xpath_escape(text):
    # Usage:
    #   target_text = """I'm a "super" programmer."""
    #   escaped = "aaa[bbb=%s]" % xpath_escape(target_text)
    #   escaped literal is aaa[bbb=concat('I', "'", 'm a "super" programmer.')]

    NOT_FOUND = -1

    if text.find("'") == NOT_FOUND:
        return "'" + text + "'"

    text_list = []
    for text_part in text.split("'"):
        text_list += ["'" + text_part + "'"]
    return "concat(%s)" % ""","'",""".join(text_list)


if etree.__name__ == "lxml.etree":
    _find_all = lambda node, path: node.xpath(path)
else:

    def _find_all(node, path):
        # Workaroud:
        #   ElementTree's "findall" can't find a child node if unicode
        #   descendant xpath(u".//xxx").
        #   So, try calling "findall" with u"./xxx" and u".//xxxx" and
        #   merge result.

        if not path.startswith(_DESCENDANT_BASE):
            return node.findall(path)

        child_nodes = node.findall(path.replace(_DESCENDANT_BASE, "./", 1))
        descendant_nodes = node.findall(path)
        for node in child_nodes:
            if node in descendant_nodes:
                child_nodes.remove(node)
        return child_nodes + descendant_nodes


def _is_name_string(data):
    """Check if "data" is string for the name.
       Assume "data" is name if it is "unicode" instance.
       Assume "data" is not name if it is not "str" instance or
       starts with '<', 0 or BOM.
    """

    if isinstance(data, unicode):
        data = data.encode(UTF8_ENC)
    elif not isinstance(data, str):
        return False

    if (data[0] == XML_TAG_START or
        data.startswith(UTF16LE_XML_TAG_START) or
        data.startswith(UTF16BE_XML_TAG_START) or
        data.startswith(UTF8_BOM) or
        data.startswith(UTF16LE_BOM) or
        data.startswith(UTF16BE_BOM)):

        return False

    return True


def _get_first_data(source):
    """Return the first bytes from source.
       If source is file (like) object or file name, then 512 bytes are
       retured at the maximum.
    """

    OREAD_FLAG = "rb"
    READ_METHOD_NAME = "read"
    READ_BUF_SIZE = 512

    if isinstance(source, (str, unicode)):
        if not source:
            return ""

        if not _is_name_string(source):
            return source

        source = open(source, OREAD_FLAG)

    if hasattr(source, READ_METHOD_NAME):
        return source.read(READ_BUF_SIZE)

    return ""


def _guess_encoding(data):
    """Guess the encoding of "data" and return it."""

    if isinstance(data, unicode):
        return UNICODE

    try:
        if data.startswith(UTF8_BOM):
            return UTF8_ENC

        if (data.startswith(UTF16LE_BOM) or
            data.startswith(UTF16LE_XML_TAG_START)):

            return UTF16LE_ENC

        if (data.startswith(UTF16BE_BOM) or
            data.startswith(UTF16BE_XML_TAG_START)):

            return UTF16BE_ENC
    except:
        pass

    return UTF8_ENC


def _get_encoding(source):
    """Return the determined encoding for "source"."""

    XML_ENCODING_RE = """<?xml\s+.*\s+encoding\s*=\s*["'](.*)["'].*?>"""

    if isinstance(source, XmlNode) or isinstance(source, XmlData):
        return source.get_encoding()

    data = _get_first_data(source)
    encoding = _guess_encoding(data)
    if encoding != UNICODE and encoding != UTF8_ENC:
        data = data.decode(encoding)

    matchobj = re.search(XML_ENCODING_RE, data)
    if matchobj == None:
        return encoding

    # Force return non Unicode string
    xml_encoding = str(matchobj.group(1))

    if (xml_encoding.lower() == UTF16_ENC and
        encoding in (UTF16LE_ENC, UTF16BE_ENC)):

        return encoding

    return xml_encoding


class XmlNode:
    """XML Node class.  This hide the internal XML implementation"""

    def __cat_text(self, first, next, sep=u" "):
        """Internal method to concatenate text with "sep"."""

        text = u""
        if first:
            text = first
        if next:
            if text:
                text += sep
            text += next
        return text

    def __strip_text(self, text, do_strip):
        """Internal method to strip text according to "do_strip" bool."""

        if not text:
            return u""

        if do_strip:
            return text.strip(string.whitespace)
        return text

    def __get_text(self, node, do_strip=True, do_get_all=False):
        """Internal method to get the text of specified node. """

        text = u""
        if node.text:
            text += self.__strip_text(node.text, do_strip)

        children = node.getchildren()
        if not children:
            return text

        if do_get_all:
            for child in children:
                text = self.__cat_text(text,
                            self.__get_text(child, do_strip, do_get_all))

        return self.__cat_text(text,
                        self.__strip_text(children[-1].tail, do_strip))

    def __get_formatted_text(self, node, do_strip=True, rules={}):
        """Internal method to get the formatted text of specified node. """

        text = u""
        if node.text:
            text += self.__strip_text(node.text, do_strip)

        children = node.getchildren()
        if not children:
            return text

        for child in children:
            if child.text:
                text = self.__cat_text(text,
                            self.__get_formatted_text(child, do_strip, rules),
                            sep=u"")
            else:
                if child.tag in rules:
                    text += self.__decode(rules[self.__encode(child.tag)])

            text = self.__cat_text(text,
                    self.__strip_text(child.tail, do_strip), sep=u"")

        return text

    def __is_attr_match(self, node, attrs={}):
        """Internal method to check node has specified attributes.
           Note: If "attrs" is empty, then return True.
        """

        for attr in attrs:
            value = self.__encode(node.get(self.__decode(attr)))
            if value == None:
                return False

            if attrs[attr] != None and value != attrs[attr]:
                return False

        return True

    def __get_node(self, source):
        """Return node from "source"."""

        if isinstance(source, (str, unicode)):
            if not source:
                raise InvalidArgError("empty string")

            if _is_name_string(source):
                return etree.Element(source)

            if isinstance(source, unicode):
                source = source.encode(UTF8_ENC)

            return etree.fromstring(source)

        if isinstance(source, XmlNode):
            return source.node

        if etree.iselement(source):
            return source

        raise InvalidArgError(source)

    def __decode(self, text):
        """Return "text" decoded as "self.encoding" characters."""

        if self.encoding != UNICODE and isinstance(text, str):
            text = text.decode(self.encoding)

        return text

    def __encode(self, text):
        """Return "text" encoded as "self.encoding" characters."""

        if self.encoding != UNICODE and isinstance(text, unicode):
            text = text.encode(self.encoding)

        return text

    def __decode_attrs(self, attrs):
        """Return a dictionary for attribute which key and value are
           decoded as "self.encoding" characters."""

        decoded_attrs = {}
        for name in attrs:
            decoded_attrs[self.__decode(name)] = self.__decode(attrs[name])

        return decoded_attrs

    def __encode_attrs(self, attrs):
        """Return a dictionary for attribute which key and value are
           encoded as "self.encoding" characters."""

        encoded_attrs = {}
        for name in attrs:
            encoded_attrs[self.__encode(name)] = self.__encode(attrs[name])

        return encoded_attrs

    def __is_same_node(self, base, other, ignore_indent):
        """Check if "base" node is same as other node. Children are ignored."""

        if base.tag != other.tag:
            return False

        if base.attrib != other.attrib:
            return False

        if ignore_indent:
            if (self.__strip_text(base.text, True) !=
                self.__strip_text(other.text, True)):

                return False

            if (self.__strip_text(base.tail, True) !=
                self.__strip_text(other.tail, True)):

                return False
        else:
            if base.text != other.text:
                return False
            if base.tail != other.tail:
                return False

        return True

    def __is_subset(self, tree, other, ignore_indent):
        """Check if "tree" is subset of "other"."""

        try:
            other_clone = other.get_clone()
            if not self.__is_same_node(tree.node, other_clone.node,
                                    ignore_indent):
                return False

            for child in tree.get_node_list(ANY_CHILD_PATH):
                other_children = other_clone.get_node_list(ANY_CHILD_PATH)
                other_children_count = len(other_children)
                if other_children_count <= 0:
                    return False

                index = 0
                for other_child in other_children:
                    if self.__is_subset(child, other_child, ignore_indent):
                        other_clone.delete_child(ANY_CHILD_NAME, index=index)
                        break
                    index += 1

                if index >= len(other_children):
                    return False

            return True
        except:
            return False

    def __compare(self, tree, other, ignore_indent):
        """Compare "tree" with "other"."""

        try:
            if not self.__is_same_node(tree.node, other.node, ignore_indent):
                return 1

            children = tree.get_node_list(ANY_CHILD_PATH)
            other_children = other.get_node_list(ANY_CHILD_PATH)

            if len(children) != len(other_children):
                return 1

            for child, other_child in zip(children, other_children):
                if self.__compare(child, other_child, ignore_indent):
                    return 1

            return 0
        except:
            return 1

    def __update(self, tree, other, override):
        """Update "tree" with "other"."""

        if tree.node.tag != other.node.tag:
            if not override:
                return

            tree.node.tag = other.node.tag

        tree.node.attrib.update(dict(other.node.attrib))
        tree.node.text = other.node.text
        tree.node.tail = other.node.tail

        sibling_name_list = []
        for other_child in other.get_node_list(ANY_CHILD_PATH):
            target_name = other_child.node.tag
            if target_name in sibling_name_list:
                continue

            sibling_name_list.append(target_name)
            tree_child_list = tree.get_node_list(target_name)
            other_child_list = other.get_node_list(target_name)

            if len(tree_child_list) == 1 and len(other_child_list) == 1:
                self.__update(tree_child_list[0], other_child, override)
                continue

            if override:
                tree.delete_children(target_name)

            for child in other_child_list:
                tree.append_child(child.get_clone())

    def __str__(self):
        """Translate XML data to string data and return it."""

        return self.to_str()

    def __eq__(self, other):
        """Check if the XML data is equal to "other"."""

        return self.compare(other) == 0

    def __ne__(self, other):
        """Check if the XML data is not equal to "other"."""

        return self.compare(other) != 0

    def __init__(self, source="", encoding=None):
        """Constructor."""

        self.node = None
        self.encoding = encoding

        try:
            XmlNode.set(self, source, encoding)
        except InvalidArgError:
            pass

    def set(self, source, encoding=None):
        """Set XML data from "source".
           The "source" must be following:
               "XmlNode" instance
               "Element" instance of "ElementTree"
               XML text format

           Note:
               This function don't create the new "Element" instance
               except the case that "source" is XML text format.
        """

        self.node = self.__get_node(source)
        if encoding:
            self.encoding = encoding

        if not self.encoding:
            if _is_name_string(source):
                self.encoding = _guess_encoding(source)
            else:
                self.encoding = _get_encoding(source)

        return self

    def to_str(self, encoding=None):
        """Translate XML data to string data and return it."""

        if not encoding:
            encoding = self.encoding

        if encoding != UNICODE and not encoding.lower() in UTF_ENC_LIST:
            # Leave "etree" library to encode output.
            return etree.tostring(self.node, encoding=encoding)

        xml_str = etree.tostring(self.node, encoding=UTF8_ENC)
        if encoding != UNICODE and encoding.lower() != UTF8_ENC:
            bom = UTF16_BOM_DICT.get(encoding.lower(), "")

            xml_str = bom + xml_str.decode(UTF8_ENC).encode(encoding)

        return xml_str

    def is_subset(self, other, chroot=True, ignore_indent=False):
        """Check if XML data tree is subset of "other"."""

        other_node = XmlNode(other)

        try:
            if self.__is_subset(self, other_node, ignore_indent):
                return True

            if not chroot:
                return False

            name = self.get_node_name()
            target_xpath = _DESCENDANT_BASE + name

            for node in other_node.get_node_list(target_xpath):
                if self.__is_subset(self, node, ignore_indent):
                    return True

            return False
        except:
            return False

    def compare(self, other, ignore_order=False, ignore_indent=False):
        """Compare XML data with "other". If XML data is equal to "other",
           then return 0.  Otherwise return non-0.

           The "other" must be following:
               "XmlNode" instance
               "Element" instance of "ElementTree"
               XML text format
        """

        other_node = XmlNode(other)
        if ignore_order:
            if not self.is_subset(other_node, False, ignore_indent):
                return 1
            if not other_node.is_subset(self, False, ignore_indent):
                return 1
            return 0

        return self.__compare(self, other_node, ignore_indent)

    def get_encoding(self):
        """Return encoding for converting XML data to string."""

        return self.encoding

    def set_encoding(self, encoding):
        """Set a default encoding for converting XML data."""

        self.encoding = encoding
        return self.encoding

    def get_node_name(self):
        """Return node name."""

        return self.__encode(self.node.tag)

    def set_node_name(self, new_name):
        """Set node name to new one."""

        self.node.tag = self.__decode(new_name)
        return new_name

    def get_clone(self, no_child=False):
        """Create the clone node and return it."""

        if no_child or not len(self.get_node_list(ANY_CHILD_PATH)):
            element = etree.Element(self.node.tag, self.node.attrib)
            element.text = self.node.text
            element.tail = self.node.tail
            return self.__class__(element, encoding=self.encoding)

        clone_node = self.__class__(self.to_str(), encoding=self.encoding)

        # Set tail because it is lost when node is transformed to string.
        clone_node.node.tail = self.node.tail
        return clone_node

    def get_node_list(self, path, attrs={}):
        """Return node list which match with specified condition."""

        node_list = []
        for node in _find_all(self.node, self.__decode(path)):
            if self.__is_attr_match(node, attrs):
                node_list.append(self.__class__(node, encoding=self.encoding))

        return node_list

    def get_node(self, path, attrs={}, index=0):
        """Return a node which match with specified condition first."""

        node_list = self.get_node_list(path, attrs)
        if len(node_list) <= index:
            raise NotFoundError(path, attrs, index)

        return node_list[index]

    def append_child(self, node, text=None, attrs={}):
        """Append the "node" as child node.
           If "node" is string, then the new elemnt is created with "text"
           and "attrs". Otherwise "text" and "attrs are ignored.
        """

        if isinstance(node, (str, unicode)):
            node = etree.Element(self.__decode(node),
                                self.__decode_attrs(attrs))
            node.text = self.__decode(text)
        elif isinstance(node, XmlNode):
            node = node.node

        self.node.append(node)

    def insert_child(self, index, node, text=None, attrs={}):
        """Insert the "node" as child node to at given position.
           If "node" is string, then the new elemnt is created with "text"
           and "attrs". Otherwise "text" and "attrs are ignored.
        """

        if isinstance(node, (str, unicode)):
            node = etree.Element(self.__decode(node),
                                self.__decode_attrs(attrs))
            node.text = self.__decode(text)
        elif isinstance(node, XmlNode):
            node = node.node

        self.node.insert(index, node)

    def delete_children(self, name, attrs={}):
        """Delete child nodes which match with specified condition
           and return the deleted node list.
        """

        return self.delete_nodes(ROOT_PATH, name, attrs)

    def delete_child(self, name, attrs={}, index=0):
        """Delete child node match with specified condition first."""

        child_list = []
        for child in self.node.getchildren():
            if ((self.__encode(child.tag) == name or
                        name == ANY_CHILD_NAME) and
                    self.__is_attr_match(child, attrs)):

                child_list.append(child)

        if len(child_list) <= index:
            raise NotFoundError(name, attrs, index)

        self.node.remove(child_list[index])
        return self.__class__(child_list[index], encoding=self.encoding)

    def delete_nodes(self, parent_path, child_path, attrs={}):
        """Delete children which is under "parent_path" and specified by
           "child_path" and "attrs" and return the deleted node list.
        """

        deleted_node_list = []
        for parent in list(self.get_node_list(parent_path)):
            for child in list(parent.get_node_list(child_path, attrs)):
                parent.node.remove(child.node)
                deleted_node_list.append(child)

        return deleted_node_list

    def clear(self):
        """Removes all children and attributes set text to None."""

        self.node.clear()

    def get_text(self, do_strip=True, do_get_all=False):
        """Return a text of a node."""

        return self.__encode(self.__get_text(self.node, do_strip, do_get_all))

    def get_formatted_text(self, do_strip=True, rules={}):
        """Return a formatted text of a node.
           Descendant nodes are transfromed according to "rules".
           Now only the node which has no text is supported.
           (e.g. the empty node)
        """

        return self.__encode(self.__get_formatted_text(self.node,
                                    do_strip, rules))

    def set_text(self, text):
        """Set text to node and return it."""

        self.node.text = self.__decode(text)
        return text

    def delete_text(self, encoding=None):
        """Delete text from node and return it."""

        text = self.__encode(self.node.text)
        self.node.text = u""
        return text

    def get_attrs(self):
        """Return a attribute dictionary of a node"."""

        return self.__encode_attrs(self.node.attrib)

    def set_attrs(self, add_attrs, do_strip=True):
        """Set the node to "add_attrs" attributes."""

        decoded_attrs = self.__decode_attrs(add_attrs)
        for attr in decoded_attrs:
            self.node.set(attr,
                    self.__strip_text(decoded_attrs[attr], do_strip))

    def delete_attrs(self, attr_list):
        """Delete specified attributes from the node and
           return a dictionary of deleted attributes.
        """

        deleted_attrs = {}
        for attr in attr_list:
            try:
                deleted_attrs[attr] = self.node.attrib.pop(self.__decode(attr))
            except:
                pass
        return deleted_attrs

    def get_attr_value(self, name, default=None, do_strip=True):
        """Return a specified attribute value of a node which match
           specified condition first.
        """

        value = self.node.get(self.__decode(name))
        if value == None:
            if default != None:
                return default
            raise NotFoundError(name, do_strip)

        return self.__encode(self.__strip_text(value, do_strip))

    def get_value_list(self, xpath, do_strip=True):
        """Return a list of node's text or attribute's value which is
           specified "xpath".
           Note: "lxml" module must be imported for getting attribute's value.
        """

        value_list = []
        for found in _find_all(self.node, self.__decode(xpath)):
            if isinstance(found, (str, unicode)):
                value_list.append(self.__encode(
                                    self.__strip_text(found, do_strip)))
                continue
            found_node = self.__class__(found, encoding=self.encoding)
            value_list.append(found_node.get_text(do_strip))

        return value_list

    def get_value(self, xpath, default="", index=0, do_strip=True):
        """Return a node's text or attribute's value which is
           specified "xpath".
           Note: "lxml" module must be imported for getting attribute's value.
        """

        value_list = self.get_value_list(xpath, do_strip)
        if len(value_list) <= index:
            return default

        return value_list[index]

    def update(self, other, override=False):
        """Update XML tree data by "other".
           Note:
               If a root node's name in "other" is diffrent "self.node"'s name,
               and "override" is True, then "self.node"'s name is set to
               a root node's name in "other".
               If "override" is False, then "self.node" is not updated.
        """

        other_node = XmlNode(other)
        self.__update(self, other_node, override)
        return self


class XmlData:
    """XML Data class.  This hide the internal XML implementation"""

    def __get_root_node(self, source):
        """Return the root node from "source"."""

        if isinstance(source, (str, unicode)):
            if not source:
                raise InvalidArgError("empty string")

            if _is_name_string(source):
                tree = etree.parse(source)
                return self.node_class(tree.getroot(), _get_encoding(source))

            return self.node_class(source)

        if isinstance(source, XmlData):
            return source.root.get_clone()

        if isinstance(source, self.node_class):
            return source.get_clone()

        if etree.iselement(source):
            return self.node_class(source).get_clone()

        raise InvalidArgError(source)

    def __str__(self):
        """Translate XML data to string data and return it."""

        return str(self.root)

    def __eq__(self, other):
        """Check if the XML data is equal to "other"."""

        return self.compare(other) == 0

    def __ne__(self, other):
        """Check if the XML data is not equal to "other"."""

        return self.compare(other) != 0

    def __init__(self, source="", encoding=None, node_class=XmlNode):
        """Constructor."""

        self.root = None
        self.encoding = encoding
        self.node_class = node_class

        try:
            XmlData.load(self, source, encoding)
        except InvalidArgError:
            pass

    def load(self, source, encoding=None):
        """Load XML data from "source".
           The "source" must be following:
               "XmlData" instance
               instance of the class which is specified "node_class"
               "Element" instance of xml.etree.ElementTree'
                   (This is the node returned by this class's method)
               file name
               file object
               XML text format
        """

        self.root = self.__get_root_node(source)
        if encoding:
            self.encoding = encoding

        if self.encoding:
            self.root.set_encoding(self.encoding)
        else:
            self.encoding = self.root.get_encoding()

    def save(self, file, encoding=None):
        """Save XML data to "file"."""

        OWRITE_FLAG = "wb"

        if encoding == None:
            encoding = self.encoding

        open(file, OWRITE_FLAG).write(self.root.to_str(encoding))

    def get_encoding(self):
        """Return encoding for saving XML data."""

        return self.encoding

    def set_encoding(self, encoding):
        """Set a default encoding for saving XML data."""

        self.encoding = encoding
        self.root.set_encoding(self.encoding)
        return self.encoding

    def is_subset(self, other, chroot=True, ignore_indent=False):
        """Check if XML data tree is subset of "other"."""

        return self.root.is_subset(XmlData(other).root, chroot, ignore_indent)

    def compare(self, other, ignore_order=False, ignore_indent=False):
        """Compare XML data with "other". If XML data is equal to "other",
           then return 0.  Otherwise return non-0.

           The "other" must be following:
               "XmlData" instance
               instance of the class which is specified "node_class"
               "Element" instance of xml.etree.ElementTree'
                   (This is the node returned by this class's method)
               file name
               file object
               XML text format
        """

        return self.root.compare(XmlData(other).root, ignore_order,
                                ignore_indent)

    def get_node_list(self, path, attrs={}):
        """Return node list which match with specified condition."""

        return self.root.get_node_list(path, attrs)

    def get_root_node(self):
        """Return a root node."""

        return self.root

    def get_node(self, path, attrs={}, index=0):
        """Return a node which match with specified condition first."""

        return self.root.get_node(path, attrs, index)

    def get_text_list(self, path, attrs={}, do_strip=True, do_get_all=False):
        """Return text list of text which match with specified condition."""

        text_list = []
        for node in self.root.get_node_list(path, attrs):
            text_list.append(node.get_text(do_strip, do_get_all))
        return text_list


class XmlConfNode(XmlNode):
    """XML Configuration Node class."""

    ENABLE_NAME = "enable"
    TRUE_TEXT = "true"
    FALSE_TEXT = "false"

    def __init__(self, source="", encoding=None):
        """Constructor."""

        XmlNode.__init__(self, source, encoding)

    def is_set_to_true(self, name):
        """Check if the value of specified attribute is "true"."""

        try:
            if self.get_attr_value(name).lower() == self.TRUE_TEXT:
                return True
            return False
        except NotFoundError:
            return False

    def is_enabled(self):
        """Check if the value of "enable" attribute is "true"."""

        return self.is_set_to_true(self.ENABLE_NAME)

    def set_bool_attr(self, name, true=True):
        """Set a attribute to "true" or "false" according to "true"."""

        if true:
            self.set_attrs({name: self.TRUE_TEXT})
        else:
            self.set_attrs({name: self.FALSE_TEXT})

    def enable(self, true=True):
        """Set "enable" attribute to "true" or "false" according to "true"."""

        self.set_bool_attr(self.ENABLE_NAME, true)

    def set_data_list(self, name, data_list):
        """Create node which name is "name" for each item in "data_list" and
           append it as_child node.
           The item in "data_list" is transformed to string and is set
           the text of each created node to respectively.
        """

        for item in data_list:
            self.append_child(name, str(item))


class XmlConf(XmlData):
    """XML Configuration class."""

    def __init__(self, source="", encoding=None):
        """Constructor."""

        XmlData.__init__(self, source, encoding, XmlConfNode)
