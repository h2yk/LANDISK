# -*- mode: landisk-python; coding: utf-8; -*-
# vim:ts=4 sw=4 sts=4 ai si et sta

"""File utility module.

Define functions for file and directories.
"""


from __future__ import with_statement

import os
import fcntl
import signal


class FLock:
    """Class for locking file with fcntl."""

    __OPEN_MODE = "w"

    def __get_operation(self, exclusive, timeout):
        """Return operation for "flock"."""

        operation = fcntl.LOCK_SH
        if exclusive == None:
            exclusive = self.exclusive

        if exclusive:
            operation = fcntl.LOCK_EX

        if timeout == 0:
            operation |= fcntl.LOCK_NB
        return operation

    def __lock(self, lock_path, operation):
        """Open a "lock_path" file and lock it."""

        _lock_file = open(lock_path, self.__OPEN_MODE)
        fcntl.flock(_lock_file.fileno(), operation)
        self.lock_file = _lock_file

    def __timeout_lock(self, lock_path, exclusive, timeout):
        """Try locking file until "timeout" later."""

        # Using alarm for timeout
        saved_handler = signal.signal(signal.SIGALRM,
                                    lambda signum, frame: None)

        try:
            signal.alarm(timeout)
            self.__lock(lock_path, self.__get_operation(exclusive, timeout))
            signal.alarm(0)
        except:
            signal.alarm(0)
            signal.signal(signal.SIGALRM, saved_handler)
            raise

    def __init__(self, lock_dir, lock_name, exclusive=None, timeout=None,
            suffix=".lock"):
        """Constructor."""

        self.lock_dir = lock_dir
        self.lock_name = lock_name
        self.exclusive = exclusive
        self.timeout = timeout
        self.suffix = suffix
        self.lock_file = None

        if not os.path.exists(lock_dir):
            os.makedirs(lock_dir)

    def __del__(self):
        """Destructor."""

        self.unlock()

    def __enter__(self):
        """Enter context for locking a file."""

        self.lock()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Exit context for locking a file."""

        self.unlock()
        if exc_type != None:
            return False
        return True

    def lock(self, exclusive=None, timeout=None):
        """Open a file for locking and lock it."""

        if self.lock_file:
            return

        if timeout == None:
            timeout = self.timeout

        lock_path = os.path.join(self.lock_dir, self.lock_name) + self.suffix

        if not timeout:
            self.__lock(lock_path, self.__get_operation(exclusive, timeout))
            return

        self.__timeout_lock(lock_path, exclusive, timeout)

    def unlock(self):
        """Unlock a locked file."""

        if self.lock_file != None:
            self.lock_file.close()
            self.lock_file = None
