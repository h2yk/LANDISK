#!/usr/bin/env python
# -*- mode: landisk-python; coding: utf-8; -*-
# vim:ts=4 sw=4 sts=4 ai si et sta

from __future__ import with_statement

from basefilesync import (SrcFull, DstFull, SIZE_NAME, STATE_SAME, DEBUG)
from ionas.exception import *
from ..fileaccess import DropboxAccess

import stat

from dropbox import rest

STATUS_BAD_INPUT_PARAM = 400


class DropboxFileTree(SrcFull, DstFull):

    def __init__(self, session, path="", ignored_list=[],
        log_callback=None, encoding="", for_sync=True):
        self.dropbox_access = DropboxAccess(session, encoding)
        SrcFull.__init__(self, path,
                         ignored_list, log_callback)
        DstFull.__init__(self, path,
                         log_callback, for_sync=for_sync, err_del=False)

        self.MAX_FILE_SIZE = 300 * 1024 * 1024

        self.sep = self.dropbox_access.sep

    def listdir(self, path):
        return self.dropbox_access.listdir(path)

    def open(self, path, mode):
        return self.dropbox_access.open(path, mode)

    def mkdir(self, path):
        self.dropbox_access.mkdir(path)

    def stat(self, path):
        return self.dropbox_access.stat(path)

    def remove(self, path):
        self.dropbox_access.remove(path)

    def rmdir(self, path):
        self.dropbox_access.rmdir(path)

    def pre_file_transfer(self, file_relpath, file_info):
        if self.MAX_FILE_SIZE:
            if file_info[SIZE_NAME] >= self.MAX_FILE_SIZE:
                raise SizeTooLargeError

    def post_file_transfer(self, file_relpath, file_info):
        if self.for_sync:
            dst_file_stat = self.stat(self.sep.join(
                [self.root] + file_relpath))
            dst_mtime = dst_file_stat[stat.ST_MTIME]
            dst_size = dst_file_stat[stat.ST_SIZE]
            self.update_delta_info(
                file_relpath, mtime=dst_mtime, size=dst_size, state=STATE_SAME)

            self.src.utime(self.src.sep.join(
                [self.src.root] + file_relpath), dst_mtime)
            src_file_stat = self.src.stat(
                self.src.sep.join([self.src.root] + file_relpath))
            src_mtime = src_file_stat[stat.ST_MTIME]
            src_size = src_file_stat[stat.ST_SIZE]

            self.src.update_delta_info(
                file_relpath, mtime=src_mtime, size=src_size, state=STATE_SAME)
        else:
            self.src.update_delta_info(
                file_relpath, state=STATE_SAME)

    def post_dir_create(self, dir_relpath, dir_info):
        if self.for_sync:
            dst_dir_stat = self.stat(self.sep.join([self.root] + dir_relpath))
            dst_mtime = dst_dir_stat[stat.ST_MTIME]
            self.update_delta_info(
                dir_relpath, mtime=dst_mtime, state=STATE_SAME, is_dir=True)

            self.src.utime(self.src.sep.join(
                [self.src.root] + dir_relpath), dst_mtime)
            src_dir_stat = self.src.stat(
                self.src.sep.join([self.src.root] + dir_relpath))
            src_mtime = src_dir_stat[stat.ST_MTIME]
            self.src.update_delta_info(
                dir_relpath, mtime=src_mtime, state=STATE_SAME)

        else:
            self.src.update_delta_info(dir_relpath, state=STATE_SAME)

    def post_file_delete(self, file_relpath, file_info):
        if self.for_sync:
            self.update_delta_info(file_relpath, delete=True)

    def post_dir_delete(self, dir_relpath, dir_info):
        if self.for_sync:
            self.update_delta_info(dir_relpath, delete=True)

    def is_misc_skip_err(self, exc_type, exc_ins):
        
        if isinstance(exc_ins, rest.ErrorResponse):
            # unicode名ファイルなどでは
            # ファイル名によってHTTP STATUS 400が
            # 返るものがある
            if exc_ins.status == STATUS_BAD_INPUT_PARAM:
                return True
