# -*- mode: landisk-python; coding: utf-8; -*-
# vim:ts=4 sw=4 sts=4 ai si et sta

"""Client module for REST API."""


import urllib2
import sys
import ssl

from accessinfo import (NeedToRetry,)


SSL_CREATE_UNVERIFIED_CONTEXT = "_create_unverified_context"

CONTENT_LENGTH_KEY = "Content-Length"


class RestClient:
    """Base class accessing to the server with REST API."""

    def _merge_dicts(self, dict_list):
        """Return the dictionary merged each dictionary in "dict_list"."""

        new_dict = {}
        for add_dict in dict_list:
            new_dict.update(add_dict)
        return new_dict

    def _get_request(self, request_info, headers={}):
        """Return the instance of "urllib2.Request" class."""

        send_headers = self._merge_dicts(
                        [self.headers, request_info.get_headers(), headers])

        request = urllib2.Request(request_info.get_url(),
                            request_info.get_data(),
                            send_headers)
        if request_info.get_method():
            request.get_method = lambda: request_info.get_method()

        return request

    def _urlopen(self, request_info, headers={}):
        """Open "url" and return the file like object.
           "request_info" must be a instance of the "RequestInfo" class
           or the class derived from it.
        """

        count = 0
        while True:
            try:
                request = self._get_request(request_info, headers)

                if self.opener != None:
                    return self.opener.open(request)

                return urllib2.urlopen(request)
            except:
                try:
                    self.access_info.handle_exception(sys.exc_info()[1],
                                                        request_info, count)
                except NeedToRetry, retry_info:
                    count += 1
                    request_info = retry_info.get_request_info()
                    continue

    def __init__(self, access_info, headers={}, proxies=None):
        """Constructor.
           "access_info" must be a instance of the derived class
           from "AccessInfo" class.
        """

        self.access_info = access_info
        self.headers = headers
        self.opener = None
        self.is_session_opened = False

        self.set_proxies(proxies)

    def __del__(self):
        """Destructor."""

        if self.is_session_opened:
            try:
                self.close_session()
            except:
                # Ignore Error
                pass

    def set_proxies(self, proxies):
        """Set proxies accessing to the server."""

        handlers = []
        if hasattr(ssl, SSL_CREATE_UNVERIFIED_CONTEXT):
            handlers += [urllib2.HTTPSHandler(
                                    context=ssl._create_unverified_context())]
        if proxies != None:
            handlers += [urllib2.ProxyHandler(proxies)]

        try:
            handlers += self.access_info.get_url_handlers()
        except NotImplementedError:
            pass

        if handlers:
            self.opener = urllib2.build_opener(*handlers)
        else:
            self.opener = None
        return proxies

    def open_session(self, headers={}):
        """Open session to Server."""

        try:
            request_info = self.access_info.get_open_session_req_info()
            self.access_info.set_session_info(
                    self._urlopen(request_info, headers))
            self.is_session_opened = True
        except NotImplementedError:
            return

    def close_session(self):
        """Close session to Server."""

        try:
            request_info = self.access_info.get_close_session_req_info()
            self._urlopen(request_info)
            self.access_info.set_session_info()
            self.is_session_opened = False
        except NotImplementedError:
            return


class FileClient(RestClient):
    """Class to access files on server with REST API."""

    def _prepare_path(self, path, purpose):
        """Prepare to access a "path" for "purpose"."""

        try:
            while True:
                request_info = \
                    self.access_info.get_prepare_path_req_info(path, purpose)
                if request_info == None:
                    return

                response = self._urlopen(request_info)
                self.access_info.set_path_info(response)

        except NotImplementedError:
            return

    def _try_set_create_path_info(self, path, response):
        """Try set the path information which is in "response" of
        request for creating the "path".
        """

        try:
            self.access_info.set_create_path_info(path, response)
        except NotImplementedError:
            return

    def __init__(self, access_info, headers={}, proxies=None):
        """Constructor.
           "access_info" must be a instance of the derived class
           from "AccessInfo" class.
        """

        RestClient.__init__(self, access_info, headers, proxies)

    def convert_path(self, path):
        """Convert charcter in "path" according to the server rules."""

        return self.access_info.convert_path(path)

    def compare_path(self, path, path_on_server):
        """Compare "path" and "path_on_server".
           "path" is converted according to the server rules.
        """

        return self.access_info.compare_path(path, path_on_server)

    def list_contents(self, path, headers={}):
        """Return a list of contents in "path" directory."""

        self._prepare_path(path, self.access_info.Purpose.ACCESS_DIRECTORY)
        request_info = self.access_info.get_list_contents_req_info(path)
        response = self._urlopen(request_info, headers)
        return self.access_info.to_content_list(response)

    def make_directory(self, path, headers={}):
        """Make "path" directory."""

        self._prepare_path(path, self.access_info.Purpose.MAKE_DIRECTORY)
        request_info = self.access_info.get_make_directory_req_info(path)
        response = self._urlopen(request_info, headers)
        self._try_set_create_path_info(path, response)

    def delete_directory(self, path, headers={}):
        """Delete "path" directory."""

        self._prepare_path(path, self.access_info.Purpose.DELETE_DIRECTORY)
        request_info = self.access_info.get_delete_directory_req_info(path)
        self._urlopen(request_info, headers)

    def stat_directory(self, path, headers={}):
        """Get status of "path" directory."""

        self._prepare_path(path, self.access_info.Purpose.ACCESS_DIRECTORY)
        request_info = self.access_info.get_stat_directory_req_info(path)
        response = self._urlopen(request_info, headers)
        return self.access_info.to_stat_info(response)

    def rename_directory(self, path, new_name, headers={}):
        """Rename "path" directory to "new_name"."""

        self._prepare_path(path, self.access_info.Purpose.RENAME_DIRECTORY)
        request_info = self.access_info.get_rename_directory_req_info(path,
                                                                new_name)
        self._urlopen(request_info, headers)

    def move_directory(self, path, new_path, headers={}):
        """Move "path" directory to "new_path"."""

        self._prepare_path(path, self.access_info.Purpose.MOVE_DIRECTORY)
        self._prepare_path(new_path, self.access_info.Purpose.MOVE_TO)
        request_info = self.access_info.get_move_directory_req_info(path,
                                                                new_path)
        self._urlopen(request_info, headers)

    def delete_file(self, path, headers={}):
        """Delete "path" file."""

        self._prepare_path(path, self.access_info.Purpose.DELETE_FILE)
        request_info = self.access_info.get_delete_file_req_info(path)
        self._urlopen(request_info, headers)

    def stat_file(self, path, headers={}):
        """Get status of "path" file."""

        self._prepare_path(path, self.access_info.Purpose.ACCESS_FILE)
        request_info = self.access_info.get_stat_file_req_info(path)
        response = self._urlopen(request_info, headers)
        return self.access_info.to_stat_info(response)

    def rename_file(self, path, new_name, headers={}):
        """Rename "path" file to "new_name"."""

        self._prepare_path(path, self.access_info.Purpose.RENAME_FILE)
        request_info = self.access_info.get_rename_file_req_info(path,
                                                                new_name)
        self._urlopen(request_info, headers)

    def move_file(self, path, new_path, headers={}):
        """Move "path" file to "new_path"."""

        self._prepare_path(path, self.access_info.Purpose.MOVE_FILE)
        self._prepare_path(new_path, self.access_info.Purpose.MOVE_TO)
        request_info = self.access_info.get_rename_file_req_info(path,
                                                                new_path)
        self._urlopen(request_info, headers)

    def read_file(self, path, headers={}):
        """Read from "path" file."""

        self._prepare_path(path, self.access_info.Purpose.ACCESS_FILE)
        request_info = self.access_info.get_read_file_req_info(path)
        return self._urlopen(request_info, headers)

    def write_file(self, path, data, length=0, headers={}, overwrite=False):
        """Write to "path" file."""

        self._prepare_path(path, self.access_info.Purpose.WRITE_FILE)
        request_info = self.access_info.get_write_file_req_info(path,
                                                    data, length, overwrite)
        response = self._urlopen(request_info, headers)
        self._try_set_create_path_info(path, response)
