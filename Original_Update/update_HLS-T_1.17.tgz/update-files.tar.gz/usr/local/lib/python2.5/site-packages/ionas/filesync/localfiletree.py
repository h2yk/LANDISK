#!/usr/bin/env python
# -*- mode: landisk-python; coding: utf-8; -*-
# vim:ts=4 sw=4 sts=4 ai si et sta

from __future__ import with_statement

from basefilesync import (SrcFull, DstFull, MODE_CH_FILE,
    MODE_CH_DIR, MTIME_NAME, STATE_SAME, ERRINFO_NAME, DEBUG)
from ionas.exception import *
from ..fileaccess import LocalAccess

import stat


class LocalFileTree(SrcFull, DstFull):

    def __init__(self, path, ignored_list=[],
        log_callback=None, tmp_path="", encoding="",
        ctime=True, for_sync=True, is_skip_file_callback=None):
        self.local_access = LocalAccess(encoding, ctime)
        SrcFull.__init__(self, path, ignored_list, log_callback)
        DstFull.__init__(self, path, log_callback, tmp_path, for_sync=for_sync,
                         is_skip_file_callback=is_skip_file_callback)

        self.MAX_FILE_SIZE = None

        try:
            self.local_access.stat(path)
        except NoEntryError:
            raise NoRootEntryError

        self.sep = self.local_access.sep
        self.ctime = ctime

    def listdir(self, path):
        return self.local_access.listdir(path)

    def open(self, path, mode):
        return self.local_access.open(path, mode)

    def mkdir(self, path):
        self.local_access.mkdir(path)

    def stat(self, path, ctime=None):
        if ctime == None:
            ctime = self.ctime
        return self.local_access.stat(path, ctime)

    def chmod(self, path, mode):
        self.local_access.chmod(path, mode)

    def utime(self, path, mtime):
        self.local_access.utime(path, mtime)

    def remove(self, path):
        self.local_access.remove(path)

    def rmdir(self, path):
        self.local_access.rmdir(path)

    def move(self, src, dst):
        self.local_access.move(src, dst)

    def pre_file_transfer(self, file_relpath, file_info):
        # COMMENT 同名dirが既存の場合、tmp_pathからのmoveの際に
        # そのdirの下に.tmp***の
        # 名前のファイルをmoveしてしまう
        # COMMENT XR 1.55ではdir優先決め打ち
        file_path = self.sep.join([self.root] + file_relpath)
        try:
            if stat.S_ISDIR(self.stat(file_path)[stat.ST_MODE]):
                raise ExistsError
        except NoEntryError:
            pass

    def pre_dir_create(self, dir_relpath, dir_info):
        # COMMENT XR 1.55ではdir優先決め打ち
        file_path = self.sep.join([self.root] + dir_relpath)
        try:
            if not stat.S_ISDIR(self.stat(file_path)[stat.ST_MODE]):
                self.remove(file_path)
                self.update_delta_info(dir_relpath, delete=True)
        except:
            pass

    def post_file_transfer(self, file_relpath, file_info):
        self.utime(self.sep.join(
            [self.root] + file_relpath), file_info[MTIME_NAME])
        self.chmod(self.sep.join(
            [self.root] + file_relpath), MODE_CH_FILE)

        if self.for_sync:
            self.src.update_delta_info(file_relpath,
                                       state=STATE_SAME,
                                       delete_keys=[ERRINFO_NAME])

            dst_stat = self.stat(self.sep.join([self.root] + file_relpath))
            dst_size = dst_stat[stat.ST_SIZE]
            dst_mtime = dst_stat[stat.ST_MTIME]
            self.update_delta_info(file_relpath, state=STATE_SAME,
                                   size=dst_size, mtime=dst_mtime,
                                   delete_keys=[ERRINFO_NAME])

    def post_file_delete(self, file_relpath, file_info):
        if self.for_sync:
            self.update_delta_info(file_relpath, delete=True)

    def post_dir_create(self, dir_relpath, dir_info):
        self.utime(self.sep.join(
            [self.root] + dir_relpath), dir_info[MTIME_NAME])
        self.chmod(self.sep.join(
            [self.root] + dir_relpath), MODE_CH_DIR)

        if self.for_sync:
            self.src.update_delta_info(dir_relpath,
                                       state=STATE_SAME,
                                       delete_keys=[ERRINFO_NAME])

            dst_stat = self.stat(self.sep.join([self.root] + dir_relpath))
            dst_mtime = dst_stat[stat.ST_MTIME]
            self.update_delta_info(dir_relpath, state=STATE_SAME,
                                   mtime=dst_mtime, is_dir=True,
                                   delete_keys=[ERRINFO_NAME])

    def post_dir_delete(self, dir_relpath, dir_info):
        # COMMENT dir優先決め打ち
        if self.for_sync:
            self.update_delta_info(dir_relpath, delete=True)
