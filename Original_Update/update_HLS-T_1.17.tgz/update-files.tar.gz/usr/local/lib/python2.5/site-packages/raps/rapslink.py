# -*- mode: landisk-python; coding: utf-8; -*-
# vim:ts=4 sw=4 sts=4 ai si et sta

import os
import time
import hashlib
import urllib
import subprocess
import traceback
import uuid

class rapslink:
    '''
    This class is a class which manages URL temporarily. 
    '''
    SHARE_PATH = "/raps/share/"

    c_comm = None

    def __init__(self, comm):
        '''
        Constructor
        '''
        self.c_comm = comm
        

    def LINK_PATH(self):
        if self.c_comm == None:
            return ""
        if self.c_comm.CONFIG == None:
            return ""
        return self._getPath(self.c_comm.CONFIG.LINK_PATH)
    
    def COMMAND_PATH(self):
        if self.c_comm == None:
            return ""
        if self.c_comm.CONFIG == None:
            return ""
        return self._getPath(self.c_comm.CONFIG.COMMAND_PATH)
    
    def _getPath(self, path):
        if path == None:
            return ""
        path = path.rstrip("/") + "/"
        return path

    def _send_sig_to_link_del_py(self):
        try:
            proc = subprocess.Popen(["pgrep","-f","link_del.py"],stdout=subprocess.PIPE)
            pid_list = proc.stdout.readlines()
            proc.wait()
            for pid in pid_list:
                pid = pid.strip()
                self.c_comm.logout("send sig to link_del.py(" + pid +")")
                subprocess.call(["sudo","kill","-USR1",pid])
        except:
            traceback.print_exc(file=open(self.c_comm.CONFIG.LOG,"w"))
            pass

    def create(self, srcfile, protocol, hostname, expire):
        '''
        Creation of file one time URL.
        '''
        n_result = self.c_comm.RESULT.RESULT_NO_ERROR
        s_url = ""

        # File's existence check
        if os.path.exists( srcfile ) == False:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result, s_url
        
        # Creation of a directory which stores a symbol file
        savepath = self._make_link_path(expire)
        if len(savepath) == 0:
            n_result = self.c_comm.RESULT.RESULT_ERROR
            return n_result, s_url
        
        # create directory
        dstpath = os.path.join(self.LINK_PATH(), protocol)
        dstpath = os.path.join(dstpath, savepath)
        if os.path.exists( dstpath ) == True:
            n_result = self.c_comm.RESULT.RESULT_ERR_EXIST
            return n_result, s_url

        if self.c_comm.MakeDirs(dstpath) == False:
            n_result = self.c_comm.RESULT.RESULT_ERR_WRITE
            return n_result, s_url

        # get file name
        srcname = os.path.basename(srcfile)
        dstfile = os.path.join(dstpath, srcname)

        # create link file
        try:
            os.symlink(srcfile, dstfile)
        except:
            n_result = self.c_comm.RESULT.RESULT_ERR_WRITE

        # create URL's
        s_url = protocol + "://" + hostname + self.SHARE_PATH + savepath + "/" + urllib.quote( srcname )

        # search next delete file
        self._send_sig_to_link_del_py()

        return n_result, s_url

    def disable(self, url):
        '''
        Remove of file one time URL.
        '''
        n_result = self.c_comm.RESULT.RESULT_NO_ERROR

        l_urls = url.split( "/" )
        n_count = len(l_urls)
        if n_count < 2:
            n_result = self.c_comm.RESULT.RESULT_INVALID_URL
            return n_result

        s_prot = l_urls[0].rstrip(":")
        s_path = l_urls[n_count-2]

        # get epoc time
        n_epoc = self._get_epoc(s_path)
        if n_epoc == 0:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result

        # delete directory
        dstpath = os.path.join(self.LINK_PATH(), s_prot)
        dstpath = os.path.join(dstpath, s_path)
        if os.path.exists( dstpath ) == False:
            n_result = self.c_comm.RESULT.RESULT_NOT_FOUND
            return n_result

        if self.c_comm.RemoveDirFource(dstpath) == False:
            n_result = self.c_comm.RESULT.RESULT_ERR_DELETE
            return n_result

        # search next delete file
        self._send_sig_to_link_del_py()

        return n_result

    def remove(self):
        '''
        remove link file
        '''
        n_result = self.c_comm.RESULT.RESULT_NO_ERROR
        try:
            l_dirs = os.listdir( self.LINK_PATH() )
            for s_dname in l_dirs:
                s_dir = os.path.join( self.LINK_PATH(), s_dname )
                l_files = os.listdir( s_dir )
                for s_name in l_files:
                    s_file = os.path.join( s_dir, s_name )
                    if os.path.isdir(s_file) == True:
                        # get epoc time
                        n_epoc = self._get_epoc(s_name)
                        if n_epoc == 0:
                            self.c_comm.RemoveDirFource(s_file)
                        else:
                            if int(time.time()) >= n_epoc: 
                                self.c_comm.RemoveDirFource(s_file)
                    else:
                        self.c_comm.Remove(s_file)
        except:
            n_result = self.c_comm.RESULT.RESULT_ERR_DELETE
        
        return n_result

    def _make_link_path(self, expire):
        '''
        Creation of a link file folder name.
        '''
        s_path = ""
        try:
            s_uuid = uuid.uuid4().hex
            s_epoc = hex(int(time.time()+expire)).strip("L")
            if s_epoc[0:2] == "0x":
                s_epoc = s_epoc[2:]
            s_path = s_uuid + s_epoc
        except:
            pass
        
        return s_path

    def _get_epoc(self, path):
        '''
        get epoc time
        '''
        n_epoc = 0
        n_hashlen = hashlib.md5().digest_size * 2
        if n_hashlen > len(path):
            return 0
        
        s_epoc = path[n_hashlen:]
        try:
            n_epoc = int( s_epoc, 16 )
        except:
            pass
        
        return n_epoc

