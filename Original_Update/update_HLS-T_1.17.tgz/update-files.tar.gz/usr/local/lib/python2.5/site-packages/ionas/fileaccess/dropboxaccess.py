#!/usr/bin/env python
# -*- mode: landisk-python; coding: utf-8; -*-
# vim:ts=4 sw=4 sts=4 ai si et sta

from __future__ import with_statement

from ..fileaccess import (MODE_READ, MODE_WRITE, ST_MODE_DIR, ST_MODE_FILE,
    DEFAULT_LOCALE, DEBUG)
from ionas.exception import *
from filelikeobj import FileLikeObj

try:
    import email.utils as emailut
except:
    import email.Utils as emailut

import os
import sys
import stat
import locale
import re
import httplib
import socket

from dropbox import client, rest

DROPBOX_ERRS = (rest.ErrorResponse, rest.RESTSocketError)

STATUS_BAD_INPUT_PARAM = 400
STATUS_ALREADY_EXISTS = 403
STATUS_NOT_FOUND = 404
STATUS_FILE_TOO_LARGE = 413
STATUS_NO_SPACE = 507

CONTENTS_NAME = "contents"
PATH_NAME = "path"
MODIFIED_NAME = "modified"
BYTES_NAME = "bytes"
IS_DIR_NAME = "is_dir"

RETRY_NUM = 3


def is_retry_err(exc):
    if isinstance(exc, rest.ErrorResponse):
        if str(exc.status).startswith("5"):
            return True
    if isinstance(exc, rest.RESTSocketError):
        return True
    if isinstance(exc, socket.error):
        return True
    if isinstance(exc, httplib.BadStatusLine):
        return True
    return False


def dropbox_except_handler(exc, path):
    if isinstance(exc, rest.ErrorResponse):
        if exc.status == STATUS_NO_SPACE:
            raise NoSpaceError(exc, path)
        if exc.status == STATUS_NOT_FOUND:
            raise NoEntryError(exc, path)
        if exc.status == STATUS_ALREADY_EXISTS:
            raise ExistsError(exc, path)
        if exc.status == STATUS_FILE_TOO_LARGE:
            raise SizeTooLargeError(exc, path)
    raise exc, None, sys.exc_info()[2]


def retry_func(func, *args, **kwargs):
    # ここでdropbox_except_handlerをすると
    # path変数を渡しづらくなるので
    # 各呼び出し元でdropbox_except_handlerをする
    def _retry_func(retry_num=RETRY_NUM):
        try:
            return func(*args, **kwargs)
        except Exception, ins:
            if retry_num and is_retry_err(ins):
                return _retry_func(retry_num - 1)
            else:
                raise ins
    return _retry_func()
            

class DropboxFileObj(FileLikeObj):

    def __init__(self, file, path, dclient=None):
        self.dclient = dclient
        FileLikeObj.__init__(self, file, path)

    def __len__(self):
        raise NotImplementedError

    def tell(self):
        raise NotImplementedError

    def seek(self, offset, whence=os.SEEK_SET):
        raise NotImplementedError

    def get_path(self):
        raise NotImplementedError

    def read(self, size):
        """
        self.fileのreadの実装は
        socketのreadであり、
        seek不可なのでリトライしない。
        ファイル単位でのリトライをするとなると
        basefilesyncのexec_file_transferでやる必要あり
        """
        try:
            return self.file.read(size)
        except DROPBOX_ERRS, ins:
            dropbox_except_handler(ins, self.path)

    def _write_by_path(self, file_like):
        # リトライ時を考慮し毎回先頭へseek
        file_like.seek(0)

        self.dclient.put_file(self.path, file_like, True)
 
    def write_by_path(self, file_like):
        try:
            return retry_func(self._write_by_path, file_like)
        except DROPBOX_ERRS, ins:
            dropbox_except_handler(ins, self.path)

    def close(self):
        pass


class DropboxAccess():

    def __init__(self, session, encoding=""):
        self.sep = "/"

        if encoding:
            self.encoding = encoding
        else:
            self.encoding = locale.getdefaultlocale()[1]
            if not self.encoding:
                self.encoding = DEFAULT_LOCALE

        try:
            self.__dclient = client.DropboxClient(session)

        except DROPBOX_ERRS, ins:
            dropbox_except_handler(ins, "")

    def _listdir(self, path):
        metadata = self.__dclient.metadata(path)
        content_list = []
        for content in metadata.get(CONTENTS_NAME):
            server_path = content[PATH_NAME].encode(self.encoding)
            name =server_path.split(self.sep)[-1]
            content_list.append(name)
        return content_list

    def _open(self, path, mode):
        if mode == MODE_READ:
            return DropboxFileObj(self.__dclient.get_file(path),
                                  path)
        if mode == MODE_WRITE:
            return DropboxFileObj("",
                                  path,
                                  self.__dclient)

    def _mkdir(self, path):
        self.__dclient.file_create_folder(path)

    def _stat(self, path):
        metadata = self.__dclient.metadata(path)
        if metadata.get(IS_DIR_NAME, False):
            st_mode = ST_MODE_DIR
        else:
            st_mode = ST_MODE_FILE
        st_mtime = metadata.get(MODIFIED_NAME, None)
        if st_mtime:
            st_mtime = int(emailut.mktime_tz(
                emailut.parsedate_tz(
                    st_mtime.encode(self.encoding))))

        st_size = metadata[BYTES_NAME]

        return {
            stat.ST_MODE: st_mode,
            stat.ST_MTIME: st_mtime,
            stat.ST_SIZE: st_size}

    def _remove(self, path):
        self.__dclient.file_delete(path)

    def _rmdir(self, path):
        self.__dclient.file_delete(path)

    def listdir(self, path):
        try:
            return retry_func(self._listdir, path)
        except DROPBOX_ERRS, ins:
            dropbox_except_handler(ins, path)

    def open(self, path, mode):
        try:
            return retry_func(self._open, path, mode)
        except DROPBOX_ERRS, ins:
            dropbox_except_handler(ins, path)

    def mkdir(self, path):
        try:
            return retry_func(self._mkdir, path)
        except DROPBOX_ERRS, ins:
            dropbox_except_handler(ins, path)

    def stat(self, path):
        try:
            return retry_func(self._stat, path)
        except DROPBOX_ERRS, ins:
            dropbox_except_handler(ins, path)

    def remove(self, path):
        try:
            return retry_func(self._remove, path)
        except DROPBOX_ERRS, ins:
            dropbox_except_handler(ins, path)

    def rmdir(self, path):
        try:
            return retry_func(self._rmdir, path)
        except DROPBOX_ERRS, ins:
            dropbox_except_handler(ins, path)
