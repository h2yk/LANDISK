#!/usr/bin/env python
# -*- mode: landisk-python; coding: utf-8; -*-
# vim:ts=4 sw=4 sts=4 ai si et sta

from __future__ import with_statement

from ionas.exception import *
from ionas.fileaccess import rapsaccess
from ionas.fileaccess import (
    RAPSAccess,
    RAPS_TIME_FMT,
    PRIORITY_NONE,
    PRIORITY_FILE,
    PRIORITY_DIR)
from basefilesync import(
    SrcFull, DstFull,
    DIRS_NAME,
    FILES_NAME,
    MTIME_NAME,
    SIZE_NAME,
    CHILDREN_NAME,
    STATE_NAME,
    STATE_NEW,
    STATE_DEL,
    STATE_SAME,
    ERR_STATE_PREFIX,
    NG_LOG,
    GET_TREE_LOG,
    GET_DELTA_TREE_LOG,
    ERROR_LOG_LV,
    get_new_tree)

import re
import time
import calendar
from datetime import datetime as dt


class RAPSFileTree(SrcFull, DstFull):

    # 同期系は大抵DISCONNECT_RL3であると
    # 思われるのでDISCONNECT_RL3をdefault引数とする
    # 2018/01/10
    # センターサーバへの接続要求軽減のため、基本切断しない実装へ変更
    # DISCONNECT_NONEをdefault引数とする
    def __init__(self, client, share="", ignored_list=[],
        log_callback=None, tmp_path="", encoding="", for_sync=True,
        same_name_priority=PRIORITY_NONE,
        disconnect_mode=rapsaccess.DISCONNECT_NONE):
        self.raps_access = RAPSAccess(client, share, encoding,
                                      disconnect_mode=disconnect_mode)
        SrcFull.__init__(self,
                         share,
                         ignored_list,
                         log_callback,
                         same_name_priority)
        DstFull.__init__(self,
                         share,
                         log_callback,
                         tmp_path,
                         for_sync=for_sync,
                         err_del=False)

        self.MAX_FILE_SIZE = 64 * 1024 * 1024 * 1024

        self.sep = self.raps_access.sep
        self.encoding = self.raps_access.encoding

        # COMMENT 完全同名のfile,dirが作成されている場合
        # どちらを優先して取得するかのフラグ
        self.same_name_priority = same_name_priority

    def connect(self):
        self.raps_access.connect()
        
    def disconnect(self):
        self.raps_access.disconnect()
        
    def listdir(self, path):
        return self.raps_access.listdir(path)

    def open(self, path, mode):
        return self.raps_access.open(path, mode)

    def mkdir(self, path):
        self.raps_access.mkdir(path)

    def stat(self, path):
        return self.raps_access.stat(path)

    def remove(self, path):
        self.raps_access.remove(path)

    def move(self, src, dst):
        self.raps_access.move(src, dst)

    def rmdir(self, path):
        self.raps_access.rmdir(path)

    def _get_time(self, _file):
        timetuple = dt.strptime(_file.a_mtime, RAPS_TIME_FMT).timetuple()
        return time.mktime(time.localtime(calendar.timegm(timetuple)))

    def _get_size(self, _file):
        return int(_file.a_size)

    def _get_fpath(self, _file):
        return self.sep.join([_file.t_directory.text.strip(self.sep),
                              _file.t_name.text])

    def _is_dir(self, _file):
        return self.raps_access.is_dir(_file)

    def __add_file(self, tree, name, size, mtime):
        if self.same_name_priority == PRIORITY_DIR:
            try:
                tree[DIRS_NAME][name]
            except KeyError:
                tree[FILES_NAME][name] = {
                    MTIME_NAME: mtime,
                    SIZE_NAME: size}
            return
        if self.same_name_priority == PRIORITY_FILE:
            try:
                del tree[DIRS_NAME][name]
            except:
                pass
            finally:
                tree[FILES_NAME][name] = {
                    MTIME_NAME: mtime,
                    SIZE_NAME: size}
            return
        if self.same_name_priority == PRIORITY_NONE:
            tree[FILES_NAME][name] = {
                    MTIME_NAME: mtime,
                    SIZE_NAME: size}
            return

    def __add_dir(self, tree, name, mtime):
        if tree[DIRS_NAME].has_key(name):
            return

        if self.same_name_priority == PRIORITY_DIR:
            try:
                del tree[FILES_NAME][name]
            except:
                pass
            finally:
                tree[DIRS_NAME][name] = {
                    MTIME_NAME: mtime,
                    CHILDREN_NAME: {DIRS_NAME: {}, FILES_NAME: {}}}
            return
        if self.same_name_priority == PRIORITY_FILE:
            try:
                tree[FILES_NAME][name]
            except KeyError:
                tree[DIRS_NAME][name] = {
                    MTIME_NAME: mtime,
                    CHILDREN_NAME: {DIRS_NAME: {}, FILES_NAME: {}}}
            return
        if self.same_name_priority == PRIORITY_NONE:
            tree[DIRS_NAME][name] = {
                MTIME_NAME: mtime,
                CHILDREN_NAME: {DIRS_NAME: {}, FILES_NAME: {}}}

    def get_tree_economy(self, _file, tree, prefix=""):
        fpath = self._get_fpath(_file)
        suffix = re.sub(r"^%s" % re.escape(prefix) + self.sep,
            "", fpath.encode(self.encoding))
        path_list = suffix.rstrip(self.sep).split(self.sep)
        mtime = self._get_time(_file)
        size = self._get_size(_file)
        name = path_list[0]
        if len(path_list) == 1:
            if self._is_dir(_file):
                """ This is Directory. """
                self.__add_dir(tree, name, mtime)
            else:
                """ This is File. """
                self.__add_file(tree, name, size, mtime)

        else:
            dirs = tree[DIRS_NAME]
            try:
                children = dirs[name][CHILDREN_NAME]
            except KeyError:
                self.__add_dir(tree, name, mtime)
                try:
                    children = dirs[name][CHILDREN_NAME]
                except KeyError:
                    return
            self.get_tree_economy(
                _file,
                children,
                str(prefix + self.sep + name).lstrip(self.sep))

    def __set_update_economy(self, root_tree, update_tree):
        is_updated = False
        for update_name in update_tree[FILES_NAME]:
            if update_name in root_tree[FILES_NAME].keys():
                update_info = update_tree[FILES_NAME][update_name]
                root_info = root_tree[FILES_NAME][update_name]
                if root_info[STATE_NAME].startswith(ERR_STATE_PREFIX):
                    root_info[STATE_NAME] = re.sub(
                        "^" + ERR_STATE_PREFIX, "", root_info[STATE_NAME])
                    is_updated = True

                elif root_info[STATE_NAME] == STATE_DEL:
                    root_info[STATE_NAME] = STATE_SAME

                elif (update_info[MTIME_NAME] != root_info[MTIME_NAME] or
                      update_info[SIZE_NAME] != root_info[SIZE_NAME]):
                    root_info[MTIME_NAME] = update_info[MTIME_NAME]
                    root_info[SIZE_NAME] = update_info[SIZE_NAME]
                    root_info[STATE_NAME] = STATE_NEW
                    is_updated = True

            else:
                is_updated = True
                root_tree[FILES_NAME][update_name] = {
                    MTIME_NAME: update_tree[
                        FILES_NAME][update_name][MTIME_NAME],
                    SIZE_NAME: update_tree[
                        FILES_NAME][update_name][SIZE_NAME],
                    STATE_NAME: STATE_NEW}

        for update_dir in update_tree[DIRS_NAME]:
            if update_dir in root_tree[DIRS_NAME].keys():
                update_info = update_tree[DIRS_NAME][update_dir]
                root_info = root_tree[DIRS_NAME][update_dir]

                if root_info[STATE_NAME] == STATE_DEL:
                    root_info[STATE_NAME] = STATE_SAME

                elif root_info[
                    STATE_NAME].startswith(ERR_STATE_PREFIX):
                    root_info[STATE_NAME] = re.sub(
                        "^" + ERR_STATE_PREFIX, "", root_info[STATE_NAME])
                    is_updated = True

                else:
                    # COMMENT exact_first時に
                    # 両方にほぼ同時刻のdir"A"があり、
                    # その下のfile,dirに差異がある場合に、
                    # get_sync_dup_tree_distrust_new()では
                    # dir"A"はsameになるが、
                    # その下はnewになり、dst.update()内では
                    # dir"A"はsameなので
                    # update_delta_infoされず、
                    # その下のfile,dirの転送の際に
                    # update_delta_infoされるので、そのとき
                    # update_delta_infoの"mtimeのない
                    # dirエントリができる"ルーチンを
                    # 通ることへの対処。
                    # mtimeがないと、
                    # 後のget_sync_dup_tree_distrust_newで
                    # KeyErrorになる
                    try:
                        root_info[MTIME_NAME]
                    except KeyError:
                        root_info[MTIME_NAME] = update_info[MTIME_NAME]
                        root_info[STATE_NAME] = STATE_SAME

            else:
                is_updated = True
                root_tree[DIRS_NAME][update_dir] = {
                    MTIME_NAME: update_tree[DIRS_NAME][update_dir][MTIME_NAME],
                    STATE_NAME: STATE_NEW,
                    CHILDREN_NAME: {DIRS_NAME: {}, FILES_NAME: {}}}
            if self.__set_update_economy(
                root_tree[DIRS_NAME][update_dir][CHILDREN_NAME],
                update_tree[DIRS_NAME][update_dir][CHILDREN_NAME]):
                is_updated = True
        return is_updated

    def __set_delete_economy(self, root_tree, update_tree):
        is_updated = False
        for file in root_tree[FILES_NAME]:
            if (not file in update_tree[FILES_NAME].keys() and
                root_tree[FILES_NAME][file][STATE_NAME] != STATE_DEL):
                is_updated = True
                root_tree[FILES_NAME][file][STATE_NAME] = STATE_DEL

        for dir in root_tree[DIRS_NAME]:
            if not dir in update_tree[DIRS_NAME].keys():
                if root_tree[DIRS_NAME][dir][STATE_NAME] != STATE_DEL:
                    is_updated = True
                    root_tree[DIRS_NAME][dir][STATE_NAME] = STATE_DEL
            else:
                if self.__set_delete_economy(
                    root_tree[DIRS_NAME][dir][CHILDREN_NAME],
                    update_tree[DIRS_NAME][dir][CHILDREN_NAME]):
                    is_updated = True
        return is_updated

    def __get_delta_tree_economy(self, root_tree, update_tree):
        is_updated = False
        if self.__set_update_economy(root_tree, update_tree):
            is_updated = True
        if self.__set_delete_economy(root_tree, update_tree):
            is_updated = True
        return (is_updated, root_tree)

    def get_delta_tree_economy(self):
        # COMMENT 戻り値:(更新有無, 差分情報ツリー)
        try:
            if not self.tree:
                self.tree = get_new_tree(self.get_tree())
                return (True, self.tree)
            else:
                update_tree = self.get_tree()
                is_updated, self.tree = self.__get_delta_tree_economy(
                    self.tree, update_tree)
                return (is_updated, self.tree)
        except Exception, ins:
            self.logging(ERROR_LOG_LV, GET_DELTA_TREE_LOG + " " + NG_LOG,
                src=self.root, trace=True)
            raise ins

    def get_tree(self):
        """ Over ride. """
        try:
            tree = {DIRS_NAME: {}, FILES_NAME: {}}
            index = 0

            while True:
                ac = self.raps_access.get_list(self.root, index)
                fl = ac.t_response.t_filelist

                total = int(fl.a_total)
                index = int(fl.a_index)
                _list = fl.l_file if total else []

                for _file in _list:
                    self.get_tree_economy(_file, tree, self.root)

                index = index + len(_list)

                if index == total:
                    break

            return tree

        except Exception, ins:
            self.logging(ERROR_LOG_LV, GET_TREE_LOG + " " + NG_LOG,
                src=self.root, trace=True)
            raise ins

    def get_delta_tree(self):
        """ Over ride. """
        return self.get_delta_tree_economy()

    def pre_file_transfer(self, file_relpath, file_info):
        if self.MAX_FILE_SIZE:
            if file_info[SIZE_NAME] >= self.MAX_FILE_SIZE:
                raise SizeTooLargeError

    def post_file_transfer(self, file_relpath, file_info):
        if self.for_sync:
            mtime = file_info[MTIME_NAME]
            size = file_info[SIZE_NAME]

            self.update_delta_info(
                file_relpath, mtime=mtime, size=size, state=STATE_SAME)
            self.src.update_delta_info(
                file_relpath, mtime=mtime, size=size, state=STATE_SAME)

        else:
            self.src.update_delta_info(
                file_relpath, state=STATE_SAME)

    def post_dir_create(self, dir_relpath, dir_info):
        if self.for_sync:
            mtime = dir_info[MTIME_NAME]

            self.update_delta_info(
                dir_relpath, mtime=mtime, state=STATE_SAME, is_dir=True)
            self.src.update_delta_info(
                dir_relpath, mtime=mtime, state=STATE_SAME)

        else:
            self.src.update_delta_info(dir_relpath, state=STATE_SAME)

    def post_file_delete(self, file_relpath, file_info):
        if self.for_sync:
            self.update_delta_info(file_relpath, delete=True)

    def post_dir_delete(self, dir_relpath, dir_info):
        if self.for_sync:
            self.update_delta_info(dir_relpath, delete=True)

    def is_misc_skip_err(self, exc_type, exc_ins):
        # FATへの4GB超書き込み時のWriteErrorはskip
        if exc_type == WriteError:
            return True
        return False
