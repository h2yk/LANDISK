#!/usr/bin/env python
# -*- mode: landisk-python; coding: utf-8; -*-
# vim:ts=4 sw=4 sts=4 ai si et sta

from __future__ import with_statement

from ..fileaccess import (MODE_READ, MODE_WRITE, ST_MODE_DIR, ST_MODE_FILE,
    DEFAULT_LOCALE, DEBUG)
from ionas.exception import *
from filelikeobj import FileLikeObj
from localaccess import local_except_handler

try:
    import email.utils as emailut
except:
    import email.Utils as emailut

import os
import sys
import stat
import locale
import re
import time
from datetime import datetime as dt

import rapsclient as rc

RAPS_ERRS = (rc.RapsError, rc.TouError)
RAPS_TIME_FMT = "%Y%m%d%H%M%S"

RESULT_ERR_AUTH = 10
RESULT_ERR_EXCEED_SESSION_LIMIT = 11
RESULT_NOT_FOUND = 256
RESULT_ERR_PERMISSION = 257
RESULT_ERR_WRITE = 262
RESULT_ERR_EXIST = 268
RESULT_ERR_TOO_LARGE_FILE = 265
RESULT_ERR_FILESYSTEM_FULL = 266

TOU_RESULT_ERR_EXCEED_SESSION_LIMIT_LIST = ((50001, 1),(50201, 4), (50202, 4))

LIST_NUM = "5000"

DISCONNECT_NONE = 0
DISCONNECT_RAPS = 1
DISCONNECT_RL3 = 2
DISCONNECT_ALL = DISCONNECT_RAPS | DISCONNECT_RL3

PRIORITY_NONE = "none"
PRIORITY_FILE = "file"
PRIORITY_DIR = "dir"

def raise_():
    exc, val, trace = sys.exc_info()
    raise exc, val, trace


def raps_except_handler(exc, path):
    if isinstance(exc, rc.RapsError):
        result = exc.status
        if result == RESULT_ERR_AUTH:
            raise InvalidIdentifierError(exc, path)
        if result == RESULT_ERR_PERMISSION:
            raise PermissionError(exc, path)
        if result == RESULT_ERR_WRITE:
            raise WriteError(exc, path)
        if result == RESULT_ERR_FILESYSTEM_FULL:
            raise NoSpaceError(exc, path)
        if result == RESULT_NOT_FOUND:
            raise NoEntryError(exc, path)
        if result == RESULT_ERR_EXIST:
            raise ExistsError(exc, path)
        if result == RESULT_ERR_TOO_LARGE_FILE:
            raise SizeTooLargeError(exc, path)
        if result == RESULT_ERR_TOO_LARGE_FILE:
            raise SizeTooLargeError(exc, path)
        if result == RESULT_ERR_EXCEED_SESSION_LIMIT:
            raise ExceedSessionError(exc, path)

    if isinstance(exc, rc.TouError):
        err_set = (exc.result_code, exc.err_code)
        if err_set in TOU_RESULT_ERR_EXCEED_SESSION_LIMIT_LIST:
            raise ExceedSessionError(exc, path)
        
    raise exc


# NoEntryError毎に、共有フォルダーが不在だったら
# NoRootEntryErrorを発行するデコレータ
def chk_root_exists(orig_func):

    def managed_func(self, *args, **kwargs):
        try:
            return orig_func(self, *args, **kwargs)
        except NoEntryError, exc:
            if not self.do_chk_root_exists:
                raise_()

            try:
                try:
                    if isinstance(self, RAPSAccess):
                        ac = self.client.getdir(self._to_uc(self.sep + self.share))
                    elif isinstance(self, RAPSFileObj):
                        sep = self.sep
                        share = self.path.lstrip(sep).split(sep)[0]
                        ac = self.client.getdir(self._to_uc(self.sep + share))
                    else:
                        raise_()

                except RAPS_ERRS, ins:
                    raps_except_handler(ins, self.share)

            except NoEntryError, exc:
                raise NoRootEntryError(exc.detail)

            raise_()

    return managed_func


class RAPSFileObj(FileLikeObj):

    def __init__(self, file, path, client,
                 do_chk_root_exists=True, encoding=""):
        self.client = client
        self.do_chk_root_exists = do_chk_root_exists
        self.sep = "/"

        if encoding:
            self.encoding = encoding
        else:
            self.encoding = locale.getdefaultlocale()[1]
            if not self.encoding:
                self.encoding = DEFAULT_LOCALE

        FileLikeObj.__init__(self, file, path)

    def __len__(self):
        raise NotImplementedError

    def _to_uc(self, txt):
        if not isinstance(txt, unicode):
            return txt.decode(self.encoding)
        return txt

    def tell(self):
        raise NotImplementedError

    def seek(self, offset, whence=os.SEEK_SET):
        raise NotImplementedError

    def get_path(self):
        raise NotImplementedError

    @chk_root_exists
    def read_by_path(self, file_like):
        try:
            self.client.download(self.path,
                                 file_like.file)
        except RAPS_ERRS, ins:
            raps_except_handler(ins, self.path)
        except (IOError, OSError), ins:
            local_except_handler(ins, self.path)

    @chk_root_exists
    def write_by_path(self, file_like):
        try:
            st = file_like.get_stat()
            mtime = time.strftime(RAPS_TIME_FMT,
                                  time.gmtime(int(st.st_mtime)))
            self.client.upload(self.path,
                               file_like.file,
                               st.st_size,
                               mtime=mtime,
                               overwrite=True)
        except RAPS_ERRS, ins:
            raps_except_handler(ins, self.path)

    def close(self):
        pass


class RAPSAccess():

    def __init__(self, client, share="", encoding="",
                 do_chk_root_exists=True,
                 disconnect_mode=DISCONNECT_ALL):
        self.sep = "/"

        if encoding:
            self.encoding = encoding
        else:
            self.encoding = locale.getdefaultlocale()[1]
            if not self.encoding:
                self.encoding = DEFAULT_LOCALE

        self.share = share
        self.client = client

        self.do_chk_root_exists = do_chk_root_exists
        self.disconnect_mode = disconnect_mode

    def _to_uc(self, txt):
        if not isinstance(txt, unicode):
            return txt.decode(self.encoding)
        return txt

    def set_disconnect_mode(self, mode=DISCONNECT_ALL):
        self.disconnect_mode = mode

    def connect(self):
        try:
            self.client.connect()
        except RAPS_ERRS, ins:
            raps_except_handler(ins, "")

    def disconnect(self):
        try:
            try:
                if self.disconnect_mode & DISCONNECT_RAPS:
                    self.client.raps_disconnect()
            finally:
                if self.disconnect_mode & DISCONNECT_RL3:
                    self.client.rl3_disconnect()

        except RAPS_ERRS, ins:
            raps_except_handler(ins, "")

    @chk_root_exists
    def listdir(self, path):
        try:
            ac = self.client.getdir(self._to_uc(self.sep + path))

            if not int(ac.t_response.t_filelist.a_total):
                return []

            return [file.t_name.text
                    for file
                    in ac.t_response.t_filelist.l_file]
                    
        except RAPS_ERRS, ins:
            raps_except_handler(ins, path)

    @chk_root_exists
    def open(self, path, mode):
        try:
            return RAPSFileObj("", self._to_uc(self.sep + path), self.client,
                               encoding=self.encoding)

        except RAPS_ERRS, ins:
            raps_except_handler(ins, path)

    @chk_root_exists
    def mkdir(self, path):
        try:
            self.client.mkdir(self._to_uc(self.sep + path))
        except RAPS_ERRS, ins:
            raps_except_handler(ins, path)

    @chk_root_exists
    def stat(self, path):
        try:
            path = path.rstrip(self.sep)

            splited = path.split(self.sep)

            par_path = self.sep.join(splited[:-1])
            child_name = splited[-1]

            par_path = self._to_uc(self.sep + par_path)
            regex = "^" + re.escape(self._to_uc(child_name)) + "$"

            ac = self.client.getdir(par_path,
                                    regex=regex,
                                    item=["mtime", "size"])

            file = ac.t_response.t_filelist.t_file

            if rc.isdir(file):
                st_mode = ST_MODE_DIR
            else:
                st_mode = ST_MODE_FILE
            timetuple = dt.strptime(file.a_mtime, RAPS_TIME_FMT).timetuple()
            st_mtime = int(time.mktime(timetuple))
            st_size = int(file.a_size)

            return {
                stat.ST_MODE: st_mode,
                stat.ST_MTIME: st_mtime,
                stat.ST_SIZE: st_size}

        except RAPS_ERRS, err:
            raps_except_handler(err, path)

    @chk_root_exists
    def remove(self, path):
        try:
            self.client.delete(self._to_uc(self.sep + path))
        except RAPS_ERRS, err:
            raps_except_handler(err, path)

    @chk_root_exists
    def rmdir(self, path):
        try:
            self.client.delete(self._to_uc(self.sep + path))
        except RAPS_ERRS, err:
            raps_except_handler(err, path)

    @chk_root_exists
    def move(self, src, dst):
        try:
            self.client.move(self._to_uc(self.sep + src),
                             self._to_uc(self.sep + dst))
        except RAPS_ERRS, err:
            raps_except_handler(err, dst)

    @chk_root_exists
    def get_list(self, share="", index=0):
        try:
            if not share:
                path = self._to_uc(self.sep + self.share)
            else:
                path = self._to_uc(self.sep + share)

            item = ["mtime", "size"]

            ac = self.client.find(path, item=item,
                                  index=str(index), maxnum=LIST_NUM)

            return ac

        except RAPS_ERRS, err:
            raps_except_handler(err, share)

    @chk_root_exists
    def is_dir(self, _file):
        return rc.is_dir(_file)
