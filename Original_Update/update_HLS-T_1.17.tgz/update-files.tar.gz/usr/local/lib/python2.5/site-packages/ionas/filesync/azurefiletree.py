#!/usr/bin/env python
# -*- mode: landisk-python; coding: utf-8; -*-
# vim:ts=4 sw=4 sts=4 ai si et sta

from __future__ import with_statement

from ionas.exception import *
from ionas.fileaccess import (
    AzureAccess,
    PRIORITY_NONE,
    PRIORITY_FILE,
    PRIORITY_DIR,
    MODE_WRITE)
from basefilesync import(
    DEBUG,
    SrcFull, DstFull,
    DIRS_NAME,
    FILES_NAME,
    MTIME_NAME,
    SIZE_NAME,
    CHILDREN_NAME,
    STATE_NAME,
    ERRINFO_NAME,
    STATE_NEW,
    STATE_DEL,
    STATE_SAME,
    ERR_STATE_PREFIX,
    NG_LOG,
    GET_TREE_LOG,
    GET_DELTA_TREE_LOG,
    ERROR_LOG_LV,
    get_new_tree,
    MODE_CH_FILE,
    MODE_CH_DIR)

import re
import stat
try:
    import email.utils as emailut
except:
    import email.Utils as emailut

from azure.http import HTTPError

DEFAULT_MAX_FILE_SIZE = 200 * 1024 * 1024 * 1024

LINE_FMT = "%s,%s,%s,%s\n"

NOTHING = None

FNAME_IDX = -4
ID_IDX = -3
TIME_IDX = -2
SIZE_IDX = -1

INT_NONE = -1


class AzureFileTree(SrcFull, DstFull):

    def __init__(self, account_name, account_key, container,
        log_callback=None, ignored_list=[], encoding="",
        for_sync=True, protocol="https",
        proxy_host=None, proxy_port=None,
        same_name_priority=PRIORITY_DIR,
        unique_info=""):

        self.azure_access = AzureAccess(
            account_name, account_key, container,
            protocol, encoding, proxy_host, proxy_port,
            same_name_priority, unique_info)

        SrcFull.__init__(self, container,
                         ignored_list, log_callback)
        DstFull.__init__(self, container,
                         log_callback, for_sync=for_sync, err_del=False)

        self.MAX_FILE_SIZE = DEFAULT_MAX_FILE_SIZE

        self.sep = self.azure_access.sep
        self.encoding = self.azure_access.encoding

        # COMMENT Blob Storageは完全同名のfile,dirを作成可能
        # どちらを優先して取得するかのフラグ
        self.same_name_priority = same_name_priority

        # COMMENT reset_proxy_infoのため
        self.account_name = account_name
        self.account_key = account_key
        self.container = container
        self.protocol = protocol
        self.proxy_host = proxy_host
        self.proxy_port = proxy_port
        self.unique_info = unique_info

    def listdir(self, path):
        return self.azure_access.listdir(path)

    def open(self, path, mode):
        return self.azure_access.open(path, mode)

    def mkdir(self, path):
        pass

    def stat(self, path):
        return self.azure_access.stat(path)

    # COMMENT いずれAPIが対応するかも
    #def utime(self, path, mtime):
    #    self.azure_access.utime(path, mtime)

    def remove(self, path):
        self.azure_access.remove(path)

    def rmdir(self, path):
        self.azure_access.rmdir(path)

    def __add_file(self, tree, name, size, mtime):
        if self.same_name_priority == PRIORITY_DIR:
            try:
                tree[DIRS_NAME][name]
            except KeyError:
                tree[FILES_NAME][name] = {
                    MTIME_NAME: mtime,
                    SIZE_NAME: size}
            return
        if self.same_name_priority == PRIORITY_FILE:
            try:
                del tree[DIRS_NAME][name]
            except:
                pass
            finally:
                tree[FILES_NAME][name] = {
                    MTIME_NAME: mtime,
                    SIZE_NAME: size}
            return
        if self.same_name_priority == PRIORITY_NONE:
            tree[FILES_NAME][name] = {
                    MTIME_NAME: mtime,
                    SIZE_NAME: size}
            return

    def __add_dir(self, tree, name, mtime):
        if tree[DIRS_NAME].has_key(name):
            return

        if self.same_name_priority == PRIORITY_DIR:
            try:
                del tree[FILES_NAME][name]
            except:
                pass
            finally:
                tree[DIRS_NAME][name] = {
                    MTIME_NAME: mtime,
                    CHILDREN_NAME: {DIRS_NAME: {}, FILES_NAME: {}}}
            return
        if self.same_name_priority == PRIORITY_FILE:
            try:
                tree[FILES_NAME][name]
            except KeyError:
                tree[DIRS_NAME][name] = {
                    MTIME_NAME: mtime,
                    CHILDREN_NAME: {DIRS_NAME: {}, FILES_NAME: {}}}
            return
        if self.same_name_priority == PRIORITY_NONE:
            tree[DIRS_NAME][name] = {
                MTIME_NAME: mtime,
                CHILDREN_NAME: {DIRS_NAME: {}, FILES_NAME: {}}}

    def __get_time(self, blob):
        return emailut.mktime_tz(
               emailut.parsedate_tz(
               blob.properties.last_modified))

    def __get_tree(self, blob, tree, prefix=""):
        suffix = re.sub(r"^%s" % re.escape(prefix) + self.sep,
            "", blob.name.encode(self.encoding))
        path_list = suffix.rstrip(self.sep).split(self.sep)
        mtime = self.__get_time(blob)
        size = blob.properties.content_length
        if len(path_list) == 1:
            if not suffix.endswith(self.sep):
                """ This is File. """
                self.__add_file(tree, path_list[0], size, mtime)
            else:
                """ This is Directory. """
                self.__add_dir(tree, path_list[0], mtime)
        else:
            try:
                children = tree[DIRS_NAME][path_list[0]][CHILDREN_NAME]
            except KeyError:
                self.__add_dir(tree, path_list[0], mtime)
                try:
                    children = tree[DIRS_NAME][path_list[0]][CHILDREN_NAME]
                except KeyError:
                    return
            self.__get_tree(
                blob,
                children,
                str(prefix + self.sep + path_list[0]).lstrip(self.sep))

    def __set_update(self, root_tree, update_tree):
        is_updated = False
        for update_name in update_tree[FILES_NAME]:
            if update_name in root_tree[FILES_NAME].keys():
                update_info = update_tree[FILES_NAME][update_name]
                root_info = root_tree[FILES_NAME][update_name]
                if root_info[STATE_NAME].startswith(ERR_STATE_PREFIX):
                    root_info[STATE_NAME] = re.sub(
                        "^" + ERR_STATE_PREFIX, "", root_info[STATE_NAME])
                    is_updated = True

                elif root_info[STATE_NAME] == STATE_DEL:
                    root_info[STATE_NAME] = STATE_SAME

                elif (update_info[MTIME_NAME] != root_info[MTIME_NAME] or
                    update_info[SIZE_NAME] != root_info[SIZE_NAME]):
                    root_info[MTIME_NAME] = update_info[MTIME_NAME]
                    root_info[SIZE_NAME] = update_info[SIZE_NAME]
                    root_info[STATE_NAME] = STATE_NEW
                    is_updated = True

            else:
                is_updated = True
                root_tree[FILES_NAME][update_name] = {
                    MTIME_NAME: update_tree[
                        FILES_NAME][update_name][MTIME_NAME],
                    SIZE_NAME: update_tree[
                        FILES_NAME][update_name][SIZE_NAME],
                    STATE_NAME: STATE_NEW}

        for update_dir in update_tree[DIRS_NAME]:
            if update_dir in root_tree[DIRS_NAME].keys():
                update_info = update_tree[DIRS_NAME][update_dir]
                root_info = root_tree[DIRS_NAME][update_dir]

                if root_info[STATE_NAME] == STATE_DEL:
                    root_info[STATE_NAME] = STATE_SAME

                elif root_info[
                    STATE_NAME].startswith(ERR_STATE_PREFIX):
                    root_info[STATE_NAME] = re.sub(
                        "^" + ERR_STATE_PREFIX, "", root_info[STATE_NAME])
                    is_updated = True

                else:
                    # COMMENT exact_first時に
                    # 両方にほぼ同時刻のdir"A"があり、
                    # その下のfile,dirに差異がある場合に、
                    # get_sync_dup_tree_distrust_new()では
                    # dir"A"はsameになるが、
                    # その下はnewになり、dst.update()内では
                    # dir"A"はsameなので
                    # update_delta_infoされず、
                    # その下のfile,dirの転送の際に
                    # update_delta_infoされるので、そのとき
                    # update_delta_infoの"mtimeのない
                    # dirエントリができる"ルーチンを
                    # 通ることへの対処。
                    # mtimeがないと、
                    # 後のget_sync_dup_tree_distrust_newで
                    # KeyErrorになる
                    try:
                        root_info[MTIME_NAME]
                    except KeyError:
                        root_info[MTIME_NAME] = update_info[MTIME_NAME]
                        root_info[STATE_NAME] = STATE_SAME

            else:
                is_updated = True
                root_tree[DIRS_NAME][update_dir] = {
                    MTIME_NAME: update_tree[DIRS_NAME][update_dir][MTIME_NAME],
                    STATE_NAME: STATE_NEW,
                    CHILDREN_NAME: {DIRS_NAME: {}, FILES_NAME: {}}}
            if self.__set_update(
                root_tree[DIRS_NAME][update_dir][CHILDREN_NAME],
                update_tree[DIRS_NAME][update_dir][CHILDREN_NAME]):
                is_updated = True
        return is_updated

    def __set_delete(self, root_tree, update_tree):
        is_updated = False
        for file in root_tree[FILES_NAME]:
            if (not file in update_tree[FILES_NAME].keys() and
                root_tree[FILES_NAME][file][STATE_NAME] != STATE_DEL):
                is_updated = True
                root_tree[FILES_NAME][file][STATE_NAME] = STATE_DEL

        for dir in root_tree[DIRS_NAME]:
            if not dir in update_tree[DIRS_NAME].keys():
                if root_tree[DIRS_NAME][dir][STATE_NAME] != STATE_DEL:
                    is_updated = True
                    root_tree[DIRS_NAME][dir][STATE_NAME] = STATE_DEL
            else:
                if self.__set_delete(
                    root_tree[DIRS_NAME][dir][CHILDREN_NAME],
                    update_tree[DIRS_NAME][dir][CHILDREN_NAME]):
                    is_updated = True
        return is_updated

    def __get_delta_tree(self, root_tree, update_tree):
        is_updated = False
        if self.__set_update(root_tree, update_tree):
            is_updated = True
        if self.__set_delete(root_tree, update_tree):
            is_updated = True
        return (is_updated, root_tree)

    def get_tree(self):
        """ Over ride. """
        try:
            tree = {DIRS_NAME: {}, FILES_NAME: {}}
            marker = None
            while True:
                _list = self.azure_access.get_list(self.root, marker=marker)
                for blob in _list:
                    if blob.properties.blob_type != "BlockBlob":
                        continue
                    self.__get_tree(blob, tree)
                if not _list.next_marker:
                    break
                marker = _list.next_marker
            return tree

        except Exception, ins:
            self.logging(ERROR_LOG_LV, GET_TREE_LOG + " " + NG_LOG,
                src=self.root, trace=True)
            raise ins

    def get_delta_tree(self):
        """ Over ride. """
        # COMMENT 戻り値:(更新有無, 差分情報ツリー)
        try:
            if not self.tree:
                self.tree = get_new_tree(self.get_tree())
                return (True, self.tree)
            else:
                update_tree = self.get_tree()
                is_updated, self.tree = self.__get_delta_tree(
                    self.tree, update_tree)
                return (is_updated, self.tree)
        except Exception, ins:
            self.logging(ERROR_LOG_LV, GET_DELTA_TREE_LOG + " " + NG_LOG,
                src=self.root, trace=True)
            raise ins

    def reset_proxy_info(self, proxy_host, proxy_port):
        self.azure_access = AzureAccess(
            self.account_name, self.account_key, self.container,
            self.protocol, self.encoding, proxy_host, proxy_port,
            self.same_name_priority, self.unique_info)

    def pre_file_transfer(self, file_relpath, file_info):
        if self.MAX_FILE_SIZE:
            if file_info[SIZE_NAME] >= self.MAX_FILE_SIZE:
                raise SizeTooLargeError

    def pre_dir_create(self, dir_relpath, dir_info):
        if self.for_sync:
            self.src.chmod(self.src.sep.join(
                [self.src.root] + dir_relpath), MODE_CH_DIR)
            src_dir_stat = self.src.stat(
                self.src.sep.join([self.src.root] + dir_relpath))
            src_mtime = src_dir_stat[stat.ST_MTIME]
            self.src.update_delta_info(dir_relpath, mtime=src_mtime)

    def post_file_transfer(self, file_relpath, file_info):
        # COMMENT dropboxのようにdst側の
        # utimeができない場合の処理。将来不要になるかも
        # 現時点ではdropbox -> dropboxは
        # 時刻同期不可ということ
        # データコピー時は、
        # サーバ側とNAS側の時刻揃える処理不要なので
        # for_syncフラグで制御

        if self.for_sync:
            """
            新fileをupload->すぐにs3側上でそのファイルを削除
            といった操作時に、次のdownload時に
            そのファイルが"元からs3上にない"のか
            "s3上から削除された"のか
            ということを認識するために
            dst.update_delta_infoは必要
            """
            dst_file_stat = self.stat(self.sep.join(
                [self.root] + file_relpath))
            dst_mtime = dst_file_stat[stat.ST_MTIME]
            dst_size = dst_file_stat[stat.ST_SIZE]
            self.update_delta_info(file_relpath, mtime=dst_mtime,
                                   size=dst_size, state=STATE_SAME,
                                   delete_keys=[ERRINFO_NAME])

            self.src.chmod(self.src.sep.join(
                [self.src.root] + file_relpath), MODE_CH_DIR)
            src_file_stat = self.src.stat(
                self.src.sep.join([self.src.root] + file_relpath))
            src_mtime = src_file_stat[stat.ST_MTIME]
            self.src.update_delta_info(file_relpath,
                                       mtime=src_mtime,
                                       state=STATE_SAME,
                                       delete_keys=[ERRINFO_NAME])

    def post_dir_create(self, dir_relpath, dir_info):
        if self.for_sync:
            self.src.update_delta_info(dir_relpath,
                                       state=STATE_SAME,
                                       delete_keys=[ERRINFO_NAME])

    def post_file_delete(self, file_relpath, file_info):
        if self.for_sync:
            self.update_delta_info(file_relpath, delete=True)

    def post_dir_delete(self, dir_relpath, dir_info):
        if self.for_sync:
            self.update_delta_info(dir_relpath, delete=True)

    def is_misc_skip_err(self, exc_type, exc_ins):
        
        if isinstance(exc_ins, HTTPError):
            # unicode名ファイルなどでは
            # ファイル名によってHTTP STATUS Bad Requestが
            # 返るものがある
            if exc_ins.args[0] == "Bad Request":
                return True
