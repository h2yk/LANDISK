#!/usr/bin/env python
# -*- mode: landisk-python; coding: utf-8; -*-
# vim:ts=4 sw=4 sts=4 ai si et sta

"""
Copyright (C) I-O DATA DEVICE, INC.  All rights reserved.
"""
from __future__ import with_statement

import os
import time
import shutil
import traceback as tb
import datetime as dt
import inspect

from sys import exc_info
from types import MethodType

from ionas.exception import (NoEntryError, NoRootEntryError,
                             InvalidIdentifierError, InvalidPasswordError,
                             InvalidFileSystemError, NoSpaceError,
                             ExceedSessionError)
from ionas.filesync import (get_sync_dup_tree, get_sync_dup_tree_distrust_new,
                            get_new_tree_last_time_later, get_same_tree,
                            FILES_NAME, DIRS_NAME, MTIME_NAME, CHILDREN_NAME,
                            STATE_NEW, STATE_NAME,
                            ERR_STATE_PREFIX, MODE_CH_FILE, MODE_CH_DIR,
                            SKIP_ERROR_LOG_LV, FILE_SIZE_OVER_LOG)

SHARE_CHECK_PERIOD = 60
RETRY_PERIOD = 600
RECOVER_PERIOD = 10
RECOVER_CNT = 3

UID_NAME = "uid"
GID_NAME = "gid"

UPLOAD_TIME_INFO = "upload_time"
DOWNLOAD_TIME_INFO = "download_time"

CALLER_IDX = 1
FRAME_IDX = 0
LOCALS_IDX = 3
FILE_IDX = 1
LINE_IDX = 2
FUNC_IDX = 3


debug_path = ""


def set_debug_path(path):
    global debug_path
    debug_path = path


def debug(output_list=[], show_caller=True, do_tb=False, fmt="%s\n"):
    try:
        if not os.path.exists(debug_path):
            return

        txt = ""

        if output_list:
            tmp_output_list = []
            for output in output_list:
                tmp_output_list.append(str(output))
            txt += fmt % tuple(tmp_output_list)

        if show_caller:
            caller_frame_record = inspect.stack()[CALLER_IDX]
            caller_frame = caller_frame_record[FRAME_IDX]
            argvalues = inspect.getargvalues(caller_frame)

            ins = argvalues[LOCALS_IDX].get('self', '')
            caller_file = str(caller_frame_record[FILE_IDX])
            caller_line = str(caller_frame_record[LINE_IDX])
            caller_func = str(caller_frame_record[FUNC_IDX])

            txt += "=== In: "

            if ins:
                txt += ins.__class__.__name__ + "." + caller_func + " "\
                    + caller_file + " " + caller_line + "\n"
            else:
                txt += caller_func + " "\
                    + caller_file + " " + caller_line + "\n"

        if do_tb:
            tb_txt = tb.format_exc()
            if tb_txt:
                txt += str(tb_txt)

        with open(debug_path, "a") as of:
            of.write(txt)
    except:
        pass


def do_nothing(self, *arg, **kwargs):

    pass


############ SyncInfo class ###############
class SyncInfo(object):

    def __init__(self, share_name="", share_abs_path="",
                 uid=None, gid=None):
        self.share_name = share_name
        self.share_abs_path = share_abs_path
        self.uid = uid
        self.gid = gid


class SimpleSyncInfo(SyncInfo):

    pass


class EconomySyncInfo(SyncInfo):

    def __init__(self, share_name="", share_abs_path="",
                 uid=None, gid=None, download_interval=None):
        super(EconomySyncInfo, self).__init__(share_name,
                                         share_abs_path,
                                         uid,
                                         gid)
        self.download_interval = download_interval


############ Sync class ###############
class Sync(object):

    pass


class SyncFull(Sync):

    NO_ROOT_ENTRY_ERR_LOG = ""
    NO_SPACE_ON_LOCAL_ERR_LOG = ""
    NO_SPACE_ON_SERVER_ERR_LOG = ""
    INVALID_IDENTIFIER_ERR_LOG = ""
    INVALID_PASSWORD_ERR_LOG = ""
    INVALID_FS_ERR_LOG = ""
    FILE_TOO_LARGE_ERR_LOG = ""
    EXCEED_SESSION_ERR_LOG = ""
    SKIP_ERR_LOG = ""
    TIMEOUT_ERR_LOG = ""
    MISC_ERR_LOG = ""

    NASCMD_FOR_LOGGING = None

    def __init__(self, info,
                 service_err_list=[],
                 no_root_entry_err_log="",
                 no_space_on_local_err_log="", no_space_on_server_err_log="",
                 invalid_identifier_err_log="", invalid_password_err_log="", 
                 invalid_fs_err_log="", file_too_large_err_log="",
                 exceed_session_err_log="",
                 skip_err_log="", timeout_err_log="", misc_err_log="",
                 nascmd_for_logging=None,
                 _set_trees=do_nothing, _init_check=do_nothing,
                 _is_timeout_err=do_nothing, _log_event=do_nothing,
                 _clear_announce=do_nothing, reset_proxy_info=do_nothing,
                 _post_success_upload=do_nothing, _post_success_download=do_nothing,
                 _pre_sync=do_nothing, _post_sync=do_nothing,
                 _misc_err_handle=None, _is_misc_recover_err=None):

        self.info = info

        self.SERVICE_ERR_LIST = service_err_list

        self.NO_ROOT_ENTRY_ERR_LOG = no_root_entry_err_log
        self.NO_SPACE_ON_LOCAL_ERR_LOG = no_space_on_local_err_log
        self.NO_SPACE_ON_SERVER_ERR_LOG = no_space_on_server_err_log
        self.INVALID_IDENTIFIER_ERR_LOG = invalid_identifier_err_log
        self.INVALID_PASSWORD_ERR_LOG = invalid_password_err_log
        self.INVALID_FS_ERR_LOG = invalid_fs_err_log
        self.FILE_TOO_LARGE_ERR_LOG = file_too_large_err_log
        self.EXCEED_SESSION_ERR_LOG = exceed_session_err_log
        self.SKIP_ERR_LOG = skip_err_log
        self.TIMEOUT_ERR_LOG = timeout_err_log
        self.MISC_ERR_LOG = misc_err_log

        self.NASCMD_FOR_LOGGING = nascmd_for_logging

        self._set_trees = MethodType(_set_trees, self, SyncFull)
        self._init_check = MethodType(_init_check, self, SyncFull)
        self._is_timeout_err = MethodType(_is_timeout_err, self, SyncFull)
        self._log_event = MethodType(_log_event, self, SyncFull)
        self._clear_announce = MethodType(_clear_announce, self, SyncFull)
        self.reset_proxy_info = MethodType(reset_proxy_info, self, SyncFull)
        self._post_success_upload = MethodType(_post_success_upload, self, SyncFull)
        self._post_success_download = MethodType(_post_success_download, self, SyncFull)
        self._pre_sync = MethodType(_pre_sync, self, SyncFull)
        self._post_sync = MethodType(_post_sync, self, SyncFull)

        # 下記は基本動作を定義済みなので、
        # 無条件では上書きしない
        if callable(_misc_err_handle):
            self._misc_err_handle = MethodType(_misc_err_handle, self, SyncFull)
        if callable(_is_misc_recover_err):
            self._is_misc_recover_err = MethodType(_is_misc_recover_err, self, SyncFull)

        try:
            self._init_check()
            self._set_trees()
        except Exception, exc:
            debug(do_tb=True)
            self._no_retry_err_handle(exc)
            self._misc_err_handle(exc)

    def _misc_err_handle(self, exc):
        self._log_event(self.MISC_ERR_LOG,
                        {"name": self.info.share_name},
                        tb.format_exc())
        raise exc, None, exc_info()[2]

    def _skip_err_log(self, log):
        if log.lv != SKIP_ERROR_LOG_LV:
            return
        if log.log == FILE_SIZE_OVER_LOG:
            self._log_event(self.FILE_TOO_LARGE_ERR_LOG,
                {"name": os.path.join(self.info.share_name, log.relpath)})
        else:
            self._log_event(self.SKIP_ERR_LOG,
                {"name": os.path.join(self.info.share_name, log.relpath)})

    def _init_check(self):
        raise NotImplementedError

    def _set_trees():
        raise NotImplementedError

    def _log_event(self, event, args={}, err_info=""):
        raise NotImplementedError

    def _is_timeout_err(self, exc):
        pass

    def _no_retry_err_handle(self, exc):
        share_name = self.info.share_name

        if isinstance(exc, NoRootEntryError):
            if exc.detail.__class__ in self.SERVICE_ERR_LIST:
                self._log_event(self.NO_ROOT_ENTRY_ERR_LOG,
                                {"name": share_name})

        elif isinstance(exc, InvalidIdentifierError):
            self._log_event(self.INVALID_IDENTIFIER_ERR_LOG,
                            {"name": share_name})

        elif isinstance(exc, InvalidPasswordError):
            self._log_event(self.INVALID_PASSWORD_ERR_LOG,
                            {"name": share_name})

        elif isinstance(exc, InvalidFileSystemError):
            self._log_event(self.INVALID_FS_ERR_LOG,
                            {"name": share_name})

        else:
            return

        self._set_disable_share(share_name)

        debug(["!!! no retry err !!!"])

        raise exc, None, exc_info()[2]

    def _retry_err_handle(self, exc):
        share_name = self.info.share_name
        if isinstance(exc, NoSpaceError):
            if exc.detail.__class__ in self.SERVICE_ERR_LIST:
                event = self.NO_SPACE_ON_SERVER_ERR_LOG
            else:
                event = self.NO_SPACE_ON_LOCAL_ERR_LOG
            self._log_event(event, {"name": share_name})
        elif isinstance(exc, ExceedSessionError):
            event = self.EXCEED_SESSION_ERR_LOG
        else:
            return

        debug(["!!! retry err !!!"])
        time.sleep(RETRY_PERIOD)
        raise exc, None, exc_info()[2]

    def _is_misc_recover_err(self, exc):
        # 不明エラーは基本的に
        # recoverする方針(従来どおり)
        return True

    def _get_ev_log(self, exc):
        if self._is_timeout_err(exc):
            debug(["!!! timeout err !!!"])
            return self.TIMEOUT_ERR_LOG

        if self._is_misc_recover_err(exc):
            debug(["!!! misc recover err !!!"])
            return self.MISC_ERR_LOG

        return None

    def _recover_err_handle(self, exc, do_recover):
        share_name = self.info.share_name

        ev_log = self._get_ev_log(exc)

        if not ev_log:
            return False

        if do_recover:
            debug(["!!! do recover !!!"])
            time.sleep(RECOVER_PERIOD)
            return True

        self._log_event(ev_log, {"name": share_name})

        time.sleep(RETRY_PERIOD)

        raise exc, None, exc_info()[2]

    def _try_access(self, func, recover_retry_num=RECOVER_CNT):
        cur_retry_num = 0
        while True:
            cur_retry_num += 1
            try:
                func()
            except Exception, exc:
                debug(do_tb=True)
                do_recover = cur_retry_num <= recover_retry_num
                self._no_retry_err_handle(exc)
                self._retry_err_handle(exc)
                if self._recover_err_handle(exc, do_recover):
                    continue
                self._misc_err_handle(exc)
            else:
                break

    def log_callback(self, log):
        debug([log.relpath, log.log, dt.datetime.now(),
               log.lv, log.exc_type, log.trace],
              False,
              fmt="*** RelPath: %s, Log: %s, Time: %s, " + \
                  "LogLevel: %s, ExcType: %s\n%s")
        self._skip_err_log(log)

    def set_disable(self, disable=True):
        self.is_disable = disable

    def _set_disable_share(self, share_name):
        self.set_disable()
        self._delete_info_dir(share_name)

    def _delete_info_dir(self, share_name):
        # 必要であれば内部情報の削除等を行う
        pass

    def _post_success_upload(self):
        pass

    def _post_success_download(self):
        pass

    def _pre_sync(self):
        pass

    def _post_sync(self):
        pass

    def try_sync(self):
        raise NotImplementedError


class SimpleSync(SyncFull):

    def __init__(self, info,
                 service_err_list=[],
                 no_root_entry_err_log="",
                 no_space_on_local_err_log="", no_space_on_server_err_log="",
                 invalid_identifier_err_log="", invalid_password_err_log="", 
                 invalid_fs_err_log="", file_too_large_err_log="",
                 exceed_session_err_log="",
                 skip_err_log="", timeout_err_log="", misc_err_log="",
                 nascmd_for_logging=None,
                 _set_trees=do_nothing, _init_check=do_nothing, _is_timeout_err=do_nothing,
                 _log_event=do_nothing, _clear_announce=do_nothing,
                 reset_proxy_info=do_nothing,
                 _post_success_upload=do_nothing, _post_success_download=do_nothing,
                 _pre_sync=do_nothing, _post_sync=do_nothing,
                 _misc_err_handle=None):

        super(SimpleSync, self).__init__(
                 info,
                 service_err_list,
                 no_root_entry_err_log,
                 no_space_on_local_err_log, no_space_on_server_err_log,
                 invalid_identifier_err_log, invalid_password_err_log, 
                 invalid_fs_err_log, file_too_large_err_log,
                 exceed_session_err_log,
                 skip_err_log, timeout_err_log, misc_err_log,
                 nascmd_for_logging,
                 _set_trees, _init_check, _is_timeout_err,
                 _log_event, _clear_announce, reset_proxy_info,
                 _post_success_upload, _post_success_download,
                 _pre_sync, _post_sync, _misc_err_handle)

        # ループ中に同期対象固有のエラー発生した場合、
        # その同期を対象外とするフラグ
        self.is_disable = False

    def _try_transfer(self, src, dst, delta):
        debug()
        dst.update(src, delta)

    def _get_delta(self, tree):
        is_updated, delta = tree.get_delta_tree()

        if is_updated:
            while True:
                time.sleep(SHARE_CHECK_PERIOD)
                is_updating, delta = tree.get_delta_tree()
                if not is_updating:
                    break

        return delta

    def __set_delta(self):
        debug()

        local_delta = self._get_delta(self.local_tree)
        server_delta = self._get_delta(self.server_tree)

        debug(["--- Before Local delta ---:", local_delta],
              False, fmt="%s%s\n")
        debug(["--- Before Server delta ---:", server_delta],
              False, fmt="%s%s\n")

        self.local_delta, self.server_delta = \
                get_sync_dup_tree(local_delta, server_delta)

        debug(["--- After Local delta ---:", local_delta],
              False, fmt="%s%s\n")
        debug(["--- After Server delta ---:", server_delta],
              False, fmt="%s%s\n")

    def __try_upload(self):
        debug()
        if self.is_disable:
            return

        self._try_transfer(self.local_tree,
                           self.server_tree,
                           self.local_delta)

    def __try_download(self):
        debug()
        if self.is_disable:
            return

        before_uid = os.geteuid()
        before_gid = os.getegid()
        os.setegid(self.info.gid)
        os.seteuid(self.info.uid)

        try:
            self._try_transfer(self.server_tree,
                               self.local_tree,
                               self.server_delta)

        finally:
            os.seteuid(before_uid)
            os.setegid(before_gid)

    def _set_delta(self):
        self._try_access(self.__set_delta)
 
    def _try_upload(self):
        self._try_access(self.__try_upload)

    def _try_download(self):
        self._try_access(self.__try_download)
 
    def try_sync(self):
        try:
            self._pre_sync()
            self._set_delta()
            self._try_upload()
            self._try_download()
        finally:
            self._post_sync()
            debug(["--- Sync After Local Tree ---:",
                  self.local_tree.tree], False, fmt="%s%s\n")
            debug(["--- Sync After Server Tree ---:",
                  self.server_tree.tree], False, fmt="%s%s\n")


class EconomySync(SyncFull):

    DOWNLOAD_TARGET_FNAME = ""

    def __init__(self, info,
                 service_err_list=[],
                 no_root_entry_err_log="",
                 no_space_on_local_err_log="", no_space_on_server_err_log="",
                 invalid_identifier_err_log="", invalid_password_err_log="", 
                 invalid_fs_err_log="", file_too_large_err_log="",
                 exceed_session_err_log="",
                 skip_err_log="", timeout_err_log="", misc_err_log="",
                 nascmd_for_logging=None,
                 _set_trees=do_nothing, _init_check=do_nothing, _is_timeout_err=do_nothing,
                 _log_event=do_nothing, _clear_announce=do_nothing,
                 reset_proxy_info=do_nothing, _check_last_target=do_nothing,
                 _post_success_upload=do_nothing, _post_success_download=do_nothing,
                 _pre_sync=do_nothing, _post_sync=do_nothing,
                 _misc_err_handle=None,
                 download_target_fname="", info_dir=""):

        super(EconomySync, self).__init__(
                 info,
                 service_err_list,
                 no_root_entry_err_log,
                 no_space_on_local_err_log, no_space_on_server_err_log,
                 invalid_identifier_err_log, invalid_password_err_log, 
                 invalid_fs_err_log, file_too_large_err_log,
                 exceed_session_err_log,
                 skip_err_log, timeout_err_log, misc_err_log,
                 nascmd_for_logging,
                 _set_trees, _init_check, _is_timeout_err,
                 _log_event, _clear_announce, reset_proxy_info,
                 _post_success_upload, _post_success_download,
                 _pre_sync, _post_sync, _misc_err_handle)

        self.INFO_DIR = info_dir
        self.DOWNLOAD_TARGET_FNAME = download_target_fname
        self._check_last_target = MethodType(_check_last_target, self, EconomySync)

        self.is_first_upload = True
        self.is_first_download = True
        self.is_force_download = False

        # COMMENT 前回失敗時はget_delta_treeで
        # 更新検知しなくても実行するためのフラグ
        self.is_last_upload_error = False
        self.is_last_download_error = False

        # ループ中に同期対象固有のエラー発生した場合、
        # その同期を対象外とするフラグ
        self.is_disable = False

        self._check_last_target()

    def _delete_info_dir(self, share_name):
        try:
            shutil.rmtree(os.path.join(self.INFO_DIR, share_name))
        except:
            pass

    def _get_last_time(self, time_info):
        result = self._get_info(time_info)
        if result == False:
            return None
        return int(result)

    def _set_last_time(self, time_info):
        self._set_info(time_info, str(int(time.time())))

    def _update_delta_tree(self, root_tree, update_tree):
        for update_file in update_tree[FILES_NAME]:
            update_info = update_tree[FILES_NAME][update_file]
            if update_file in root_tree[FILES_NAME].keys():
                root_info = root_tree[FILES_NAME][update_file]
                if update_info[STATE_NAME] == STATE_NEW:
                    root_info[STATE_NAME] = ERR_STATE_PREFIX + STATE_NEW

        for update_dir in update_tree[DIRS_NAME]:
            update_info = update_tree[DIRS_NAME][update_dir]
            if update_dir in root_tree[DIRS_NAME].keys():
                root_info = root_tree[DIRS_NAME][update_dir]
                if update_info[STATE_NAME] == STATE_NEW:
                    root_info[STATE_NAME] = ERR_STATE_PREFIX + STATE_NEW
            else:
                return
            self._update_delta_tree(
                root_info[CHILDREN_NAME], update_info[CHILDREN_NAME])

    def _check_update_fix(self, src):
        while True:
            time.sleep(SHARE_CHECK_PERIOD)
            is_updated, delta = src.get_delta_tree()
            if not is_updated:
                return delta

    def _try_transfer(self, src, dst, last_time=None,
        do_check_update_fix=True, is_last_error=False):
        debug()

        is_updated, delta = src.get_delta_tree()

        if not is_updated and not is_last_error:
            return

        if do_check_update_fix:
            delta = self._check_update_fix(src)

        debug(["--- Before delta ---:", delta], False, fmt="%s%s\n")
        debug(["--- Before src.tree ---:", src.tree], False, fmt="%s%s\n")
        debug(["--- Before dst.tree ---:", dst.tree], False, fmt="%s%s\n")

        if last_time != None:
            delta = get_new_tree_last_time_later(delta, last_time)
            debug(["--- LastTimeLater delta ---:", delta], False, fmt="%s%s\n")

        dst.update(src, delta)

        debug(["--- After src.tree ---:", src.tree], False, fmt="%s%s\n")
        debug(["--- After dst.tree ---:", dst.tree], False, fmt="%s%s\n")

    def _try_dst_tree_access_transfer(
        self, src, dst, do_check_update_fix=True, last_time=None):
        debug()

        is_updated, delta = src.get_delta_tree()

        if not is_updated:
            return

        if do_check_update_fix:
            delta = self._check_update_fix(src)

        debug(["--- Before delta ---:", delta], False, fmt="%s%s\n")
        debug(["--- Before src.tree ---:", src.tree], False, fmt="%s%s\n")
        debug(["--- Before dst.tree ---:", dst.tree], False, fmt="%s%s\n")

        if last_time != None:
            delta = get_new_tree_last_time_later(delta, last_time)
            debug(["--- LastTimeLater delta ---:", delta], False, fmt="%s%s\n")

        src_delta, dst_delta = get_sync_dup_tree_distrust_new(
            delta, get_same_tree(dst.get_tree()))

        debug(["--- DistrustNew src_delta ---:", src_delta],
              False, fmt="%s%s\n")
        debug(["--- DistrustNew dst_delta ---:", dst_delta],
              False, fmt="%s%s\n")

        # COMMENT 削除反映前のサービス再起動への対処
        dst.update_delta_tree(
            lambda dst_tree: self._update_delta_tree(dst_tree, dst_delta))

        debug(["--- PreUpdate dst.tree ---:", dst.tree], False, fmt="%s%s\n")

        dst.update(src, src_delta)

        debug(["--- After src.tree ---:", src.tree], False, fmt="%s%s\n")
        debug(["--- After dst.tree ---:", dst.tree], False, fmt="%s%s\n")

    def _is_exec_download(self, last_download_time):
        if (self.is_force_download or
            (self.info.download_interval and
            self._compare_time(last_download_time,
                               self.info.download_interval))):
            return True
        return False

    def _compare_time(self, last_time, interval):

        if not last_time:
            return True
        cur_time = time.time()

        if last_time + interval > cur_time:
            return False
        return True

    def _get_first_download_tree(self, cur_tree, real_tree):

        for file in cur_tree[FILES_NAME]:
            cur_info = cur_tree[FILES_NAME][file]
            if file in real_tree[FILES_NAME]:
                real_info = real_tree[FILES_NAME][file]
                if cur_info[MTIME_NAME] > real_info[MTIME_NAME]:
                    cur_info[MTIME_NAME] = real_info[MTIME_NAME]

        for dir in cur_tree[DIRS_NAME]:
            if dir in real_tree[DIRS_NAME]:
                self._get_first_download_tree(
                    cur_tree[DIRS_NAME][dir][CHILDREN_NAME],
                    real_tree[DIRS_NAME][dir][CHILDREN_NAME])

        return cur_tree

    def _is_exact_first_upload(self):
        if self._get_info(UPLOAD_TIME_INFO) == False:
            return True
        return False

    def _is_exact_first_download(self):
        if self._get_info(DOWNLOAD_TIME_INFO) == False:
            return True
        return False

    def _post_exact_first_upload(self):
        self._set_last_time(UPLOAD_TIME_INFO)
        self.is_first_upload = False

    def _post_exact_first_download(self):
        self._set_last_time(DOWNLOAD_TIME_INFO)
        self.is_first_download = False
        self.is_force_download = False

    def _post_upload(self):
        self._set_last_time(UPLOAD_TIME_INFO)
        self.is_first_upload = False

    def _post_download(self, is_executed):
        self.is_force_download = False
        if is_executed:
            self.is_first_download = False
            self._set_last_time(DOWNLOAD_TIME_INFO)

    def _try_exact_first_upload(self):
        debug()

        try:
            self._try_dst_tree_access_transfer(self.local_tree,
                                               self.server_tree,
                                               do_check_update_fix=True)

        finally:
            self._post_exact_first_upload()

    def _try_exact_first_download(self):
        debug()
        is_executed = False

        before_uid = os.geteuid()
        before_gid = os.getegid()
        os.setegid(self.info.gid)
        os.seteuid(self.info.uid)

        try:

            last_download_time = self._get_last_time(DOWNLOAD_TIME_INFO)
            if not self._is_exec_download(last_download_time):
                debug(["not exec download"])
                return

            is_executed = True

            self._try_dst_tree_access_transfer(self.server_tree,
                self.local_tree, do_check_update_fix=False)

        finally:
            os.seteuid(before_uid)
            os.setegid(before_gid)
            if is_executed:
                self._post_exact_first_download()

    def _try_first_download(self):
        debug()
        is_executed = False

        before_uid = os.geteuid()
        before_gid = os.getegid()
        os.setegid(self.info.gid)
        os.seteuid(self.info.uid)

        try:
            last_download_time = self._get_last_time(DOWNLOAD_TIME_INFO)

            if not self._is_exec_download(last_download_time):
                return

            is_executed = True

            self._try_dst_tree_access_transfer(self.server_tree,
                                                self.local_tree,
                                                do_check_update_fix=False,
                                                last_time=None)

        finally:
            os.seteuid(before_uid)
            os.setegid(before_gid)
            self._post_download(is_executed)

    def _try_normal_upload(self):
        debug()

        try:
            if self.is_first_upload:
                last_upload_time = self._get_last_time(UPLOAD_TIME_INFO)
            else:
                last_upload_time = None

            self._try_transfer(self.local_tree,
                               self.server_tree,
                               last_upload_time,
                               do_check_update_fix=True,
                               is_last_error=self.is_last_upload_error)

            self.is_last_upload_error = False

        finally:
            self._post_upload()

    def _try_normal_download(self):
        debug()
        is_executed = False

        before_uid = os.geteuid()
        before_gid = os.getegid()
        os.setegid(self.info.gid)
        os.seteuid(self.info.uid)

        try:
            last_download_time = self._get_last_time(DOWNLOAD_TIME_INFO)

            if not self._is_exec_download(last_download_time):
                return
            self._try_transfer(self.server_tree,
                               self.local_tree,
                               do_check_update_fix=False,
                               is_last_error=self.is_last_download_error)

            is_executed = True
            self.is_last_download_error = False

        finally:
            os.seteuid(before_uid)
            os.setegid(before_gid)
            self._post_download(is_executed)

    def _set_should_retry_flag(self, tree_obj, path, tree):
        for file in tree[FILES_NAME]:
            file_info = tree[FILES_NAME][file]
            if (file_info[STATE_NAME] == STATE_NEW or
                file_info[STATE_NAME] == ERR_STATE_PREFIX + STATE_NEW):
                try:
                    debug([tree_obj.sep.join([path, file])],
                          False, fmt="chmod - %s")
                    tree_obj.chmod(
                        tree_obj.sep.join([path, file]),
                        MODE_CH_FILE)
                except NoEntryError:
                    """
                    upload最中に
                    ユーザにファイル削除操作された場合等、
                    既に存在しないファイルへのchmodがあり得、
                    それらはpassする。
                    次のループでSTATE_DELになるので問題ない。
                    """
                    debug(["no entry pass"])
                    pass

        for dir in tree[DIRS_NAME]:
            dir_info = tree[DIRS_NAME][dir]
            if (dir_info[STATE_NAME] == STATE_NEW or
                dir_info[STATE_NAME] == ERR_STATE_PREFIX + STATE_NEW):
                try:
                    debug([tree_obj.sep.join([path, dir])],
                          False, fmt="chmod - %s")
                    tree_obj.chmod(
                        tree_obj.sep.join([path, dir]),
                        MODE_CH_DIR)
                except NoEntryError:
                    """
                    upload最中に
                    ユーザにファイル削除操作された場合等、
                    既に存在しないファイルへのchmodがあり得、
                    それらはpassする。
                    次のループでSTATE_DELになるので問題ない。
                    """
                    debug(["no entry pass"])
                    pass

            self._set_should_retry_flag(tree_obj,
                tree_obj.sep.join([path, dir]), dir_info[CHILDREN_NAME])

    def _set_local_should_retry_flag(self):
        # エラーによって未uploadのものを
        # サービス再起動後もupload対象とするため
        # chmodによってctimeを更新する
        # "更新監視なし"設定のための対処
        self._set_should_retry_flag(self.local_tree,
                                    self.local_tree.root,
                                    self.local_tree.get_current_tree())

    def _get_info(self, key):
        try:
            with open(os.path.join(self.INFO_DIR,
                                   self.info.share_name,
                                   key),
                      "rb") as file:
                return file.read()
            return False
        except:
            return False

    def _set_info(self, key, value):
        try:
            os.makedirs(os.path.join(self.INFO_DIR, self.info.share_name))
        except:
            pass

        with open(os.path.join(self.INFO_DIR,
                               self.info.share_name,
                               key),
                  "wb") as file:
            file.write(value)

    def __try_upload(self):
        debug()
        if self.is_disable:
            return

        try:
            if self._is_exact_first_upload():
                self._try_exact_first_upload()
            else:
                self._try_normal_upload()

        except:
            self.is_last_upload_error = True
            raise

        else:
            self._post_success_upload()

        finally:
            # last_upload_timeとの時間差
            time.sleep(2)

            self._set_local_should_retry_flag()

    def __try_download(self):
        debug()
        if self.is_disable:
            return

        try:
            if self._is_exact_first_download():
                self._try_exact_first_download()
            elif self.is_first_download:
                self._try_first_download()
            else:
                self._try_normal_download()

        except:
            self.is_last_download_error = True
            raise

        else:
            self._post_success_download()

    def _check_last_target(self):
        """
        今回の条件を記録しておき、
        次回起動時に前回起動時から
        それらのいずれかが変わっていれば
        初回同期の動きをするようにする。前回起動時の
        条件から不変なら何もしない

        INFO_DIR/upload_timeファイルや
        INFO_DIR/download_timeファイルが消えることで
        try_uploadやtry_downloadが
        初回同期の動きとなる

        下記はAmazonS3の例

        bucket_name = self._get_info(BUCKET_INFO)
        endpoint_name = self._get_info(ENDPOINT_INFO)
        if not bucket_name:
            self.set_sync_info(BUCKET_INFO, self.info.bucket)
        if not endpoint_name:
            self.set_sync_info(ENDPOINT_INFO, self.info.endpoint)
        if (bucket_name != self.info.bucket or
            endpoint_name != self.info.endpoint):
            self._delete_info_dir(self.info.share_name)
            self.set_sync_info(BUCKET_INFO, self.info.bucket)
            self.set_sync_info(ENDPOINT_INFO, self.info.endpoint)
        """

        raise NotImplementedError

    def _is_timeout_err(self, err):
        raise NotImplementedError

    def reset_proxy_info(self):
        raise NotImplementedError

    def _set_force_download(self, enable=True):
        fname = self.DOWNLOAD_TARGET_FNAME

        if not os.path.exists(fname):
            return

        with open(fname) as rf:
            if rf.read() == self.info.share_name:
                self.is_force_download = True
                os.unlink(fname)

    def _try_upload(self):
        self._try_access(self.__try_upload)

    def _try_download(self):
        self._try_access(self.__try_download, 0)
        
    def try_sync(self):
        try:
            self._pre_sync()
            self._set_force_download()
            self._try_upload()
            self._try_download()
        finally:
            self._post_sync()


class SyncFullEx(object):

    def __init__(self, info):

        self.info = info

        try:
            self._init_check()
            self._set_trees()
        except Exception, exc:
            debug(do_tb=True)
            self._init_except_handler(exc)

    def _init_check(self):
        raise NotImplementedError

    def _init_except_handler(self, exc):
        raise NotImplementedError

    def _access_except_handler(self, exc, is_do_recover=False):

        raise NotImplementedError

    def _try_access(self, func, recover_retry_num=RECOVER_CNT):
        cur_retry_num = 0
        while True:
            cur_retry_num += 1
            try:
                func()
            except Exception, exc:
                debug(do_tb=True)
                is_do_recover = cur_retry_num <= recover_retry_num

                if self._access_except_handler(exc, is_do_recover):
                    continue
            else:
                break

    def _delete_info_dir(self, share_name):

        raise NotImplementedError


    def set_disable(self, disable=True):
        self.is_disable = disable

    def _set_disable_share(self, share_name):
        self.set_disable()
        self._delete_info_dir(share_name)

    def try_sync(self):
        raise NotImplementedError


class EconomySyncEx(SyncFullEx):

    DOWNLOAD_TARGET_FNAME = ""

    def __init__(self, info):

        super(EconomySyncEx, self).__init__(info)

        self.is_first_upload = True
        self.is_first_download = True
        self.is_force_download = False

        # COMMENT 前回失敗時はget_delta_treeで
        # 更新検知しなくても実行するためのフラグ
        self.is_last_upload_error = False
        self.is_last_download_error = False

        # ループ中に同期対象固有のエラー発生した場合、
        # その同期を対象外とするフラグ
        self.is_disable = False
        self._check_last_target()

    def _check_last_target(self):

        raise NotImplementedError

    def _get_last_time(self, time_info):
        result = self._get_info(time_info)
        if result == False:
            return None
        return int(result)

    def _set_last_time(self, time_info):
        self._set_info(time_info, str(int(time.time())))

    def _get_info(self, key):
        try:
            with open(os.path.join(self.info.info_dir,
                                   self.info.share_name,
                                   key),
                      "rb") as file:
                return file.read()
            return False
        except:
            return False

    def _set_info(self, key, value):
        try:
            os.makedirs(os.path.join(self.info.info_dir, self.info.share_name))
        except:
            pass

        with open(os.path.join(self.info.info_dir,
                               self.info.share_name,
                               key),
                  "wb") as file:
            file.write(value)

    def _update_delta_tree(self, root_tree, update_tree):
        for update_file in update_tree[FILES_NAME]:
            update_info = update_tree[FILES_NAME][update_file]
            if update_file in root_tree[FILES_NAME].keys():
                root_info = root_tree[FILES_NAME][update_file]
                if update_info[STATE_NAME] == STATE_NEW:
                    root_info[STATE_NAME] = ERR_STATE_PREFIX + STATE_NEW

        for update_dir in update_tree[DIRS_NAME]:
            update_info = update_tree[DIRS_NAME][update_dir]
            if update_dir in root_tree[DIRS_NAME].keys():
                root_info = root_tree[DIRS_NAME][update_dir]
                if update_info[STATE_NAME] == STATE_NEW:
                    root_info[STATE_NAME] = ERR_STATE_PREFIX + STATE_NEW
            else:
                return
            self._update_delta_tree(
                root_info[CHILDREN_NAME], update_info[CHILDREN_NAME])

    def _check_update_fix(self, src):
        while True:
            time.sleep(SHARE_CHECK_PERIOD)
            is_updated, delta = src.get_delta_tree()
            if not is_updated:
                return delta

    def _try_transfer(self, src, dst, last_time=None,
        do_check_update_fix=True, is_last_error=False):
        debug()

        is_updated, delta = src.get_delta_tree()

        if not is_updated and not is_last_error:
            return

        if do_check_update_fix:
            delta = self._check_update_fix(src)

        debug(["--- Before delta ---:", delta], False, fmt="%s%s\n")
        debug(["--- Before src.tree ---:", src.tree], False, fmt="%s%s\n")
        debug(["--- Before dst.tree ---:", dst.tree], False, fmt="%s%s\n")

        if last_time != None:
            delta = get_new_tree_last_time_later(delta, last_time)
            debug(["--- LastTimeLater delta ---:", delta], False, fmt="%s%s\n")

        dst.update(src, delta)

        debug(["--- After src.tree ---:", src.tree], False, fmt="%s%s\n")
        debug(["--- After dst.tree ---:", dst.tree], False, fmt="%s%s\n")

    def _try_dst_tree_access_transfer(
        self, src, dst, do_check_update_fix=True, last_time=None):
        debug()

        is_updated, delta = src.get_delta_tree()

        if not is_updated:
            return

        if do_check_update_fix:
            delta = self._check_update_fix(src)

        debug(["--- Before delta ---:", delta], False, fmt="%s%s\n")
        debug(["--- Before src.tree ---:", src.tree], False, fmt="%s%s\n")
        debug(["--- Before dst.tree ---:", dst.tree], False, fmt="%s%s\n")

        if last_time != None:
            delta = get_new_tree_last_time_later(delta, last_time)
            debug(["--- LastTimeLater delta ---:", delta], False, fmt="%s%s\n")

        src_delta, dst_delta = get_sync_dup_tree_distrust_new(
            delta, get_same_tree(dst.get_tree()))

        debug(["--- DistrustNew src_delta ---:", src_delta],
              False, fmt="%s%s\n")
        debug(["--- DistrustNew dst_delta ---:", dst_delta],
              False, fmt="%s%s\n")

        # COMMENT 削除反映前のサービス再起動への対処
        dst.update_delta_tree(
            lambda dst_tree: self._update_delta_tree(dst_tree, dst_delta))

        debug(["--- PreUpdate dst.tree ---:", dst.tree], False, fmt="%s%s\n")

        dst.update(src, src_delta)

        debug(["--- After src.tree ---:", src.tree], False, fmt="%s%s\n")
        debug(["--- After dst.tree ---:", dst.tree], False, fmt="%s%s\n")

    def _is_exec_download(self, last_download_time):
        if (self.is_force_download or
            (self.info.download_interval and
            self._compare_time(last_download_time,
                               self.info.download_interval))):
            return True
        return False

    def _compare_time(self, last_time, interval):

        if not last_time:
            return True
        cur_time = time.time()

        if last_time + interval > cur_time:
            return False
        return True

    def _get_first_download_tree(self, cur_tree, real_tree):

        for file in cur_tree[FILES_NAME]:
            cur_info = cur_tree[FILES_NAME][file]
            if file in real_tree[FILES_NAME]:
                real_info = real_tree[FILES_NAME][file]
                if cur_info[MTIME_NAME] > real_info[MTIME_NAME]:
                    cur_info[MTIME_NAME] = real_info[MTIME_NAME]

        for dir in cur_tree[DIRS_NAME]:
            if dir in real_tree[DIRS_NAME]:
                self._get_first_download_tree(
                    cur_tree[DIRS_NAME][dir][CHILDREN_NAME],
                    real_tree[DIRS_NAME][dir][CHILDREN_NAME])

        return cur_tree

    def _is_exact_first_upload(self):
        if self._get_info(UPLOAD_TIME_INFO) == False:
            return True
        return False

    def _is_exact_first_download(self):
        if self._get_info(DOWNLOAD_TIME_INFO) == False:
            return True
        return False

    def _post_exact_first_upload(self):
        self._set_last_time(UPLOAD_TIME_INFO)
        self.is_first_upload = False

    def _post_exact_first_download(self):
        self._set_last_time(DOWNLOAD_TIME_INFO)
        self.is_first_download = False
        self.is_force_download = False

    def _post_upload(self):
        self._set_last_time(UPLOAD_TIME_INFO)
        self.is_first_upload = False

    def _post_download(self, is_executed):
        self.is_force_download = False
        if is_executed:
            self.is_first_download = False
            self._set_last_time(DOWNLOAD_TIME_INFO)

    def _try_exact_first_upload(self):
        debug()

        try:
            self._try_dst_tree_access_transfer(self._local_tree,
                                               self._server_tree,
                                               do_check_update_fix=True)

        finally:
            self._post_exact_first_upload()

    def _try_exact_first_download(self):
        debug()
        is_executed = False

        before_uid = os.geteuid()
        before_gid = os.getegid()
        os.setegid(self.info.gid)
        os.seteuid(self.info.uid)

        try:

            last_download_time = self._get_last_time(DOWNLOAD_TIME_INFO)
            if not self._is_exec_download(last_download_time):
                debug(["not exec download"])
                return

            is_executed = True

            self._try_dst_tree_access_transfer(self._server_tree,
                self._local_tree, do_check_update_fix=False)

        finally:
            os.seteuid(before_uid)
            os.setegid(before_gid)
            if is_executed:
                self._post_exact_first_download()

    def _try_first_download(self):
        debug()
        is_executed = False

        before_uid = os.geteuid()
        before_gid = os.getegid()
        os.setegid(self.info.gid)
        os.seteuid(self.info.uid)

        try:
            last_download_time = self._get_last_time(DOWNLOAD_TIME_INFO)

            if not self._is_exec_download(last_download_time):
                return

            is_executed = True

            self._try_dst_tree_access_transfer(self._server_tree,
                                                self._local_tree,
                                                do_check_update_fix=False,
                                                last_time=None)

        finally:
            os.seteuid(before_uid)
            os.setegid(before_gid)
            self._post_download(is_executed)

    def _try_normal_upload(self):
        debug()

        try:
            if self.is_first_upload:
                last_upload_time = self._get_last_time(UPLOAD_TIME_INFO)
            else:
                last_upload_time = None

            self._try_transfer(self._local_tree,
                               self._server_tree,
                               last_upload_time,
                               do_check_update_fix=True,
                               is_last_error=self.is_last_upload_error)

            self.is_last_upload_error = False

        finally:
            self._post_upload()

    def _try_normal_download(self):
        debug()
        is_executed = False

        before_uid = os.geteuid()
        before_gid = os.getegid()
        os.setegid(self.info.gid)
        os.seteuid(self.info.uid)

        try:
            last_download_time = self._get_last_time(DOWNLOAD_TIME_INFO)

            if not self._is_exec_download(last_download_time):
                return
            self._try_transfer(self._server_tree,
                               self._local_tree,
                               do_check_update_fix=False,
                               is_last_error=self.is_last_download_error)

            is_executed = True
            self.is_last_download_error = False

        finally:
            os.seteuid(before_uid)
            os.setegid(before_gid)
            self._post_download(is_executed)

    def _set_should_retry_flag(self, tree_obj, path, tree):
        for file in tree[FILES_NAME]:
            file_info = tree[FILES_NAME][file]
            if (file_info[STATE_NAME] == STATE_NEW or
                file_info[STATE_NAME] == ERR_STATE_PREFIX + STATE_NEW):
                try:
                    debug([tree_obj.sep.join([path, file])],
                          False, fmt="chmod - %s")
                    tree_obj.chmod(
                        tree_obj.sep.join([path, file]),
                        MODE_CH_FILE)
                except NoEntryError:
                    """
                    upload最中に
                    ユーザにファイル削除操作された場合等、
                    既に存在しないファイルへのchmodがあり得、
                    それらはpassする。
                    次のループでSTATE_DELになるので問題ない。
                    """
                    debug(["no entry pass"])
                    pass

        for dir in tree[DIRS_NAME]:
            dir_info = tree[DIRS_NAME][dir]
            if (dir_info[STATE_NAME] == STATE_NEW or
                dir_info[STATE_NAME] == ERR_STATE_PREFIX + STATE_NEW):
                try:
                    debug([tree_obj.sep.join([path, dir])],
                          False, fmt="chmod - %s")
                    tree_obj.chmod(
                        tree_obj.sep.join([path, dir]),
                        MODE_CH_DIR)
                except NoEntryError:
                    """
                    upload最中に
                    ユーザにファイル削除操作された場合等、
                    既に存在しないファイルへのchmodがあり得、
                    それらはpassする。
                    次のループでSTATE_DELになるので問題ない。
                    """
                    debug(["no entry pass"])
                    pass

            self._set_should_retry_flag(tree_obj,
                tree_obj.sep.join([path, dir]), dir_info[CHILDREN_NAME])

    def _set_local_should_retry_flag(self):
        # エラーによって未uploadのものを
        # サービス再起動後もupload対象とするため
        # chmodによってctimeを更新する
        # "更新監視なし"設定のための対処
        self._set_should_retry_flag(self._local_tree,
                                    self._local_tree.root,
                                    self._local_tree.get_current_tree())

    def __try_upload(self):
        debug()
        if self.is_disable:
            return

        try:
            if self._is_exact_first_upload():
                self._try_exact_first_upload()
            else:
                self._try_normal_upload()

        except:
            self.is_last_upload_error = True
            raise

        else:
            self._post_success_upload()

        finally:
            # last_upload_timeとの時間差
            time.sleep(2)

            self._set_local_should_retry_flag()

    def __try_download(self):
        debug()
        if self.is_disable:
            return

        try:
            if self._is_exact_first_download():
                self._try_exact_first_download()
            elif self.is_first_download:
                self._try_first_download()
            else:
                self._try_normal_download()

        except:
            self.is_last_download_error = True
            raise

        else:
            self._post_success_download()

    def reset_proxy_info(self, host, port):
        self._server_tree.reset_proxy_info(host, port)

    def _set_force_download(self, enable=True):
        fname = self._get_download_target_fname()

        if not os.path.exists(fname):
            return

        with open(fname) as rf:
            if rf.read() == self.info.share_name:
                self.is_force_download = True
                os.unlink(fname)

    def _post_success_upload(self):
        pass

    def _post_success_download(self):
        pass

    def _pre_sync(self):
        pass

    def _post_sync(self):
        pass

    def _try_upload(self):
        self._try_access(self.__try_upload)

    def _try_download(self):
        self._try_access(self.__try_download, 0)
        
    def try_sync(self):
        try:
            self._pre_sync()
            self._set_force_download()
            self._try_upload()
            self._try_download()
        finally:
            self._post_sync()


############ SyncMgr class ###############
class SyncMgr(object):

    INFO_DIR = ""

    SERVICE_ERR_LIST = []

    SYNC_CLASS = None

    def __init__(self):
        self._clear_announce()
        self._make_sync_info_dir()
        self.sync_dict = self._get_sync_dict()
        self.is_last_error = False

    def _make_sync_info_dir(self):
        try:
            os.makedirs(self.INFO_DIR)
        except:
            pass

    def _delete_disable_info_dir(self, sync_dict):
        # COMMENT 以前の共有削除によって
        # 残存した同期情報ファイルを削除
        for name in os.listdir(self.INFO_DIR):
            if not name in sync_dict:
                try:
                    self._pre_delete_disable_info_dir(name)
                    shutil.rmtree(os.path.join(self.INFO_DIR, name))
                except:
                    pass

    def _sync(self):
        try:
            debug([self.__class__.__name__, dt.datetime.now()],
                  False, fmt="/// %s CloudSyncStart /// %s\n")

            is_cur_err = False

            for share, sync in self.sync_dict.iteritems():
                try:
                    debug([share, dt.datetime.now()],
                          False, fmt="+++ %s ShareSyncStart +++ %s\n")
                    sync.try_sync()

                except Exception:
                    debug(do_tb=True)

                    if not sync.is_disable:
                        """
                        認証情報不正などでsync.is_disableとなった場合は、
                        以降その共有は同期対象外となる。
                        なので、ここでis_cur_err = Trueをしてしまうと
                        以降の同期ループ成功によって、
                        認証情報不正のお知らせがクリアされる。
                        それを防ぐため、sync.is_disable = Trueの場合は
                        is_cur_err = Trueをしない。
                        """
                        is_cur_err = True

                    self._reset_proxy_info()

                finally:
                    debug([share, dt.datetime.now()],
                          False, fmt="+++ %s ShareSyncEnd +++ %s\n")

            if self.is_last_error and not is_cur_err:
                self._clear_announce()

            self.is_last_error = is_cur_err

        finally:
            debug([self.__class__.__name__, dt.datetime.now()],
                  False, fmt="/// %s CloudSyncEnd /// %s\n")

    def _get_sync_info(self, share):
        """
        share引数のxmlのpath形式や
        対象サービスのSyncクラスが必要とする情報を元に
        適宜実装する。必要あれば、
        呼び出し元である_make_sync_dictメソッドも
        オーバーライドする。
        下記return値はAmazonS3の例。

        return AmazonS3Info(
            share.get_node(NAME_NAME).get_text(),
            share.get_node(PATH_NAME).get_text(),
            amazons3_node.get_node(BUCKET_NAME).get_text(do_strip=False),
            amazons3_node.get_node(ACCESSKEY_NAME).get_text(do_strip=False),
            amazons3_node.get_node(SECRETKEY_NAME).get_text(do_strip=False),
            is_secure, rrs,
            int(amazons3_node.get_node(DOWNLOADINTERVAL_NAME).get_text()),
            endpoint, uid, gid, proxy_host, proxy_port)
        """

        raise NotImplementedError

    def _pre_delete_disable_info_dir(self, share_name):
        pass

    def _log_event(self, event, args={}, err_info=""):
        raise NotImplementedError

    def _clear_announce(self):
        raise NotImplementedError

    def _get_sync_dict(self):
        raise NotImplementedError

    def _reset_proxy_info(self):
        raise NotImplementedError

    def sync(self):
        self._sync()


class CallBackBase(object):

    def __init__(self, info):

        self.info = info

    def low_level_except_handler(self, e):
        raise NotImplementedError

    def log_callback(self, log):
        raise NotImplementedError
