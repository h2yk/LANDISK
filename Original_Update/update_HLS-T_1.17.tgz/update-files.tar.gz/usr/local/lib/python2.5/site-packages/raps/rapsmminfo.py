# -*- mode: landisk-python; coding: utf-8; -*-
# vim:ts=4 sw=4 sts=4 ai si et sta

import os
import stat
import rapscomm
import time
import hashlib
import fcntl
import subprocess

from PIL import Image
from stat import ST_ATIME
from operator import itemgetter

import commands
import traceback

class FileLocker:
    path = None
    fp = None

    def __init__(self,path=None):
        self.path = path

    def __del__(self,path=None):
        self.unlock()

    def lock(self):
        if self.fp != None:
            return

        self.fp = open(self.path, "w")
        fcntl.flock(self.fp, fcntl.LOCK_EX)

    def unlock(self):
        if self.fp == None:
            return

        fcntl.flock(self.fp, fcntl.LOCK_UN)
        self.fp.close()
        self.fp = None
        try:
            os.remove(self.path)
        except:
            pass

class ExifInfo:
    '''
    Acquisition of Exif information
    '''
    c_comm = None

    d_exif = None
    
    def __init__(self, comm):
        '''
        Constructor
        '''
        self.c_comm = comm
        self.d_exif = { "imagedescription"       : "imagedescription",
                        "make"                   : "make",
                        "model"                  : "model",
                        "orientation"            : "orientation",
                        "xresolution"            : "xresolution",
                        "yresolution"            : "yresolution",
                        "resolutionunit"         : "resolutionunit",
                        "software"               : "software",
                        "datetime"               : "datetime",
                        "copyright"              : "copyright",
                        "datetimeoriginal"       : "datetimeoriginal",
                        "compressedbitsperpixel" : "compressedbitsperpixel",
                        "shutterspeedvalue"      : "shutterspeedvalue",
                        "aperturevalue"          : "aperturevalue",
                        "brightnessvalue"        : "brightnessvalue",
                        "exposurebiasvalue"      : "exposurebiasvalue",
                        "maxaperturevalue"       : "maxaperturevalue",
                        "subjectdistance"        : "subjectdistance",
                        "meteringmode"           : "meteringmode",
                        "lightsource"            : "lightsource",
                        "flash"                  : "flash",
                        "exifimagewidth"         : "exifimagewidth",
                        "exifimagelength"        : "exifimageheight" }

    def GetContent(self, path):
        '''
        Acquisition of Exif information
        '''

        # initialize
        s_content = ""

        # suffix type check
        try:
            suffix = os.path.splitext(path)[1].lower()
            if (suffix in rapscomm.suffix_picture) == False:
                return s_content
        except:
            return s_content

        if suffix == ".jpeg" or suffix == ".jpg": 
            # call jhead
            s_exifinfo = ""
            l_args = ["jhead", "-v", path]
            l_exif = self.c_comm.CmdExec(l_args)
            if len(l_exif) > 0:
                for s_line in l_exif:
                    s_exifinfo += self._getExifInfo(s_line, 3)
    
            if len(s_exifinfo) > 0:
                s_content  = "  <exif>\n"
                s_content += s_exifinfo
                s_content += "  </exif>\n"
            
        return s_content

    def _getExifInfo(self, line, space):
        '''
        serch exif
        '''
        s_value = ""
        s_line  = line.strip()
        n_pos   = s_line.find( "=" )
        if n_pos != -1:
            s_key = s_line[0:n_pos].strip().lower()
            for s_ekey, s_tag in self.d_exif.items():
                if s_ekey == s_key:
                    s_work   = s_line[n_pos+1:]
                    s_work   = s_work.strip()
                    s_work   = s_work.strip("\x22")
                    s_value  = " " * space
                    s_value += "<"
                    s_value += s_tag
                    s_value += ">"
                    try:
                        s_value += self.c_comm.Escape(s_work)
                    except:
                        s_value += s_work
                    s_value += "</"
                    s_value += s_tag
                    s_value += ">\n"
                    try:
                        del self.d_exif[s_ekey]
                    except:
                        pass
                    break

        return s_value

class Thumbnail:
    '''import stat

    Thumbnail operation class  
    '''
    c_main = None
    c_comm = None

    CACHE_PATH = ""
    LOCK_PATH = ""
    THUMB_TMP_DIR = ""

    def __init__(self, main, comm):
        '''
        Constructor
        '''
        self.c_main = main
        self.c_comm = comm
        self.CACHE_PATH = self.c_comm.CONFIG.CACHE_PATH.rstrip("/")
        self.CACHE_PATH += "/"
        self.LOCK_PATH = self.c_comm.CONFIG.LOCK_PATH.rstrip("/")
        self.LOCK_PATH += "/"
        self.THUMB_TMP_DIR = self.c_comm.CONFIG.THUMB_TMP_DIR.rstrip("/")
        self.THUMB_TMP_DIR += "/"

    def _remove_old_files(self,path,threshold,buffer_percent=3):
        '''
        remove old files
        '''
        files = os.listdir(path)
        c_count = len(files)
        if c_count < threshold:
            return 0
        overrun_count = c_count - threshold
        fixed_count = 1
        buffer_count = threshold * buffer_percent / 100
        d_count = overrun_count + fixed_count + buffer_count
        cmd = "ls -rt " + path
        cmd += " | head -n " + str(d_count)
        cmd += " | xargs -n 1 -i{} rm " + path + "/{}"
        ( status, output ) = commands.getstatusoutput(cmd)
        if status != 0:
            return 1
        return 0

    def create(self, srcpath, width = 0, height = 0):
        '''
        return created thumbnail path. 
        '''

        try:
            # get thumb config
            use_default_size = True
            if width > 0 and height > 0:
                use_default_size = False
            else:
                width  = self.c_comm.CONFIG.THUMB_WIDTH
                height = self.c_comm.CONFIG.THUMB_HEIGHT
            filter = self.c_comm.CONFIG.THUMB_FILTER

            lock_file_getmminfo = os.path.join(self.LOCK_PATH, "getmminfo")
            flocker_getmminfo = FileLocker(lock_file_getmminfo)
            flocker_getmminfo.lock()

            try:
                h_name = self._create_hash_name( srcpath, width, height, filter )
            except Exception, exc:
                flocker_getmminfo.unlock()
                traceback.print_exc(file=open(self.c_comm.CONFIG.LOG,"w"))
                raise exc

            flocker_getmminfo.unlock()

            try:
                lock_file_thumb = os.path.join(self.LOCK_PATH, "getmminfo" + h_name)
                flocker_thumb = FileLocker(lock_file_thumb)
                flocker_thumb.lock()
            except Exception, exc:
                traceback.print_exc(file=open(self.c_comm.CONFIG.LOG,"w"))
                raise exc

            try:
                # create cache path
                s_save = os.path.join( self.CACHE_PATH, h_name )
                s_tmp = os.path.join( self.THUMB_TMP_DIR, h_name )

                # thumbnail cache already exists. 
                if os.path.exists(s_save) == True:
                    # update timestamp
                    os.utime(s_save, None)
                    flocker_thumb.unlock()
                    return s_save

                try:
                    suffix = os.path.splitext(srcpath)[1].lower()
                    if (suffix in rapscomm.suffix_movie) == True:
                        if self.c_main._makethumbnail(srcpath, s_tmp) != self.c_comm.RESULT.RESULT_NO_ERROR:
                            raise Exception("failed to create movie thumbnail")
                    elif (suffix in rapscomm.suffix_picture) == True:
                        img = Image.open(srcpath)

                        img.thumbnail( (width, height), getattr(Image, filter))

                        if img.mode != "RGB":
                            img = img.convert("RGB")
            
                        img.save(s_tmp, "JPEG")
                        os.chmod(s_tmp, 0666)
                    else:
                        raise Exception("unsupported file extension: " + suffix)

                except Exception, exc:
                    self.c_comm.Remove(s_tmp)
                    traceback.print_exc(file=open(self.c_comm.CONFIG.LOG,"w"))
                    raise exc

                flocker_getmminfo.lock()

                try:
                    if self.c_comm.CONFIG.THUMB_COUNT > 0:
                        if self._remove_old_files(self.CACHE_PATH, self.c_comm.CONFIG.THUMB_COUNT):
                            raise Exception("failed to remove old files")
                    os.rename(s_tmp, s_save)
                except Exception, exc:
                    self.c_comm.Remove(s_tmp)
                    self.c_comm.Remove(s_save)
                    flocker_getmminfo.unlock()
                    traceback.print_exc(file=open(self.c_comm.CONFIG.LOG,"w"))
                    raise exc

                flocker_getmminfo.unlock()
                flocker_thumb.unlock()
                return s_save

            except Exception, exc:
                flocker_thumb.unlock()
                traceback.print_exc(file=open(self.c_comm.CONFIG.LOG,"w"))
                raise exc

        except Exception, exc:
            traceback.print_exc(file=open(self.c_comm.CONFIG.LOG,"w"))
            self.c_comm.logout("failed to create thumbnail: " + srcpath)
            return ""

    def delete(self, path):
        self.c_comm.logout("called meaningless function")
        return True

    def _create_hash_name(self, path, width, height, filter):
        '''
        return cache file name
        '''
        path = os.path.abspath(path)
        fst = os.stat(path)
        resolution_fmt = str(width) + "x" + str(height)
        time_fmt = time.strftime("%Y%m%d%H%M%S",time.gmtime(fst.st_mtime))
        size_fmt = str(fst.st_size)

        name = path + "_" + time_fmt + "_" + size_fmt + "_" + resolution_fmt + "_" + filter
        h_name = hashlib.md5(name).hexdigest()

        return h_name

    def _send_sig_to_update_thumbs_py(self):
        try:
            proc = subprocess.Popen(["pgrep","-f","update_thumbs.py"],stdout=subprocess.PIPE)
            pid_list = proc.stdout.readlines()
            proc.wait()
            for pid in pid_list:
                pid = pid.strip()
                self.c_comm.logout("send sig to update_thumbs.py(" + pid +")")
                subprocess.call(["sudo","kill","-USR1",pid])
        except:
            traceback.print_exc(file=open(self.c_comm.CONFIG.LOG,"w"))
            pass

    def update_thumbs(self):
        self._send_sig_to_update_thumbs_py()

