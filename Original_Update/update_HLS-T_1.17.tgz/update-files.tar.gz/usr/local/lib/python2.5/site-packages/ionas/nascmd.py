# -*- mode: landisk-python; coding: utf-8; -*-
# vim:ts=4 sw=4 sts=4 ai si et sta

"""NAS command module.

Define classes to implement FAL/PAL and other NAS commands.
"""

import sys
import os
import logging
import inspect
from logging.handlers import RotatingFileHandler
from optparse import OptionParser
from xml.parsers.expat import ExpatError

import ionas.request as request

from iobase.exception import (IoBaseException, NotFoundError, InvalidArgError)


NO_ERROR = 0
TTY_ERROR = 1
NON_XML_ERROR = 2
INVALID_XML_ERROR = 3
RECEIVE_ERROR = 4
SEND_ERROR = 5
INTERNAL_ERROR = 6

DEV_NULL = "/dev/null"


_log_map = {}

_SET_METHOD = "set"


class NasCmdOption:
    """NAS Command option class."""

    DEFAULT_VER_FMT = "%%prog : Ver. %s"

    def __init__(self, argv=sys.argv[1:], version=None, ver_fmt=None,
            usage=None, description=None, option_list=[]):
        """Constructor."""

        parser_opts = {}
        if version != None:
            if ver_fmt == None:
                ver_fmt = self.DEFAULT_VER_FMT
            parser_opts["version"] = ver_fmt % (version,)

        if usage != None:
            parser_opts["usage"] = usage

        if description != None:
            parser_opts["description"] = description

        optparser = OptionParser(**parser_opts)

        optparser.add_option("-i", "--input",
            action="store",
            dest="input",
            help="Specify the input file.")

        optparser.add_option("-o", "--output",
            action="store",
            dest="output",
            help="Specify the output file.")

        optparser.add_option("-f", "--log-file",
            action="store",
            dest="log_file",
            help="Specify the log file.")

        optparser.add_option("-l", "--log-level",
            type="int",
            action="store",
            dest="log_level",
            help="Specify the log level.")

        optparser.add_option("-d", "--debug",
            action="store_true",
            dest="debug",
            help="Enable debug mode.  Normally, set log level for debug.")

        optparser.add_option("-n", "--dry-run",
            action="store_true",
            dest="dry_run",
            help="Do not actually do anything.")

        for option in option_list:
            optparser.add_option(option)

        optparser.set_defaults(
                    input="",
                    output="",
                    log_file="",
                    log_level=logging.NOTSET,
                    debug=False,
                    dry_run=False)

        (self.opts, self.args) = optparser.parse_args(argv)


class NasCmd:
    """Base Class for NAS command."""

    CMDNAME_KEY = "cmdname"
    LOG_FORMAT = "%(asctime).19s: %(filename)s(%(cmdname)s): " + \
                    "%(levelname)-8s: %(message)s"
    LOG_MAX_SIZE = 256 * 1024
    LOG_COUNT = 9
    DEBUG_LOG_XML_LEN = 80
    STDOUT_FD = 1

    class HandlerError(IoBaseException):
        """Error for handling request "entry"."""

        def __init__(self, result, *info):
            """Set the exception information."""

            self.result = result
            IoBaseException.__init__(self, *info)

        def __str__(self):
            """Return the exception information as string."""

            return "Result: %s(%s)" % (str(self.result), str(self.info))

        def get_result(self):
            """Return the "result" entry result."""

            return self.result

    def __stdout_to_null(self):
        """Redirect stdout(1) to "/dev/null"."""

        self.saved_fd = os.dup(self.STDOUT_FD)
        null_fd = os.open(DEV_NULL, os.O_WRONLY)
        os.dup2(null_fd, self.STDOUT_FD)
        os.close(null_fd)

    def __restore_stdout(self):
        """Restore stdout(1) redirected to "/dev/null"."""

        if self.saved_fd != None:
            sys.stdout.flush()
            os.dup2(self.saved_fd, self.STDOUT_FD)
            os.close(self.saved_fd)
            self.saved_fd = None

    def __get_request(self, _from):
        """Get XML request data from "_from"."""

        source = _from
        if isinstance(source, request.RequestData):
            return _from

        if _from == None:
            try:
                if self.input.isatty():
                    self.critical("input is a tty!!")
                    sys.exit(TTY_ERROR)
            except AttributeError:
                    pass
            source = self.input

        request_data = request.RequestData()
        if isinstance(source, str):
            if source[0] == "<":
                return request_data.load(source)
            else:
                source = open(source)

        return request_data.load(source.read())

    def __receive_request(self, _from):
        """Get XML request data from "_from" and update some member.
           This function raise "SystemExit" if some exception is cached.
        """

        try:
            request_data = self.__get_request(_from)
            if request_data.is_debug() and self.log_level > logging.DEBUG:
                self.set_log_level(logging.DEBUG)
                self.debug("debug is enabled by the request data")
            if request_data.is_dry_run():
                self.dry_run = True
                self.debug("dry_run is enabled by the request data")

            return request_data

        except ExpatError:
            self.exception("Non-XML data!!")
            sys.exit(NON_XML_ERROR)
        except InvalidArgError:
            self.exception("Invalid XML data!!")
            sys.exit(INVALID_XML_ERROR)
        except AttributeError:
            self.exception("Fail receiving XML data!!")
            sys.exit(RECEIVE_ERROR)

    def __handle_request(self, request_data):
        """Handle each request in "request_data" and return response data."""

        response_data = request.ResponseData(request_data,
                            entrylist=request.EntryList())

        for req_entry in request_data.get_entry_list():
            entry = req_entry.get_clone()
            try:
                type = entry.get_type()
                if not type in self.handlers:
                    entry = self.invalid_type_handler(entry)
                else:
                    entry = self.handlers[type](entry)
            except self.HandlerError, err:
                self.exception("Handler Error!!")
                entry.set_result(err.get_result())
            except (NotFoundError, InvalidArgError):
                self.exception("Invalid XML data!!")
                entry.set_result(self.results.INVALID_XML)
            except:
                self.exception("Internal Error!!")
                entry.set_result(self.results.INTERNAL_ERROR)

            if entry != None:
                if entry.get_result() != self.results.OK:
                    self.warning("Result:" + entry.get_result() +
                            " - Entry:" + str(entry)[0:self.DEBUG_LOG_XML_LEN])
                response_data.get_entrylist().append_entry(entry)

        return response_data

    def __pre_process(self, request_data, to):
        """Call "pre_process" method."""

        try:
            return self.pre_process(request_data)
        except self.HandlerError, err:
            self.exception("pre_process fail - Handler Error!!")
            self.__send_response_with_result(request_data, to,
                                            err.get_result())
            sys.exit(NO_ERROR)
        except:
            self.exception("pre_process fail!!")
            self.__send_response_with_result(request_data, to,
                                            self.results.PRE_PROCESS_ERROR)
            sys.exit(NO_ERROR)

    def __post_process(self, response_data, to):
        """Call "post_process" method."""

        try:
            return self.post_process(response_data)
        except self.HandlerError, err:
            self.exception("post_process fail - Handler Error!!")
            self.__send_response_with_result(response_data, to,
                                            err.get_result())
            sys.exit(NO_ERROR)
        except:
            self.exception("post_process fail!!")
            self.__restore_stdout()
            self.__send_response_with_result(response_data, to,
                                            self.results.POST_PROCESS_ERROR)
            sys.exit(NO_ERROR)

    def __get_send_dest(self, to):
        """Return destination for sending XML response data."""

        dest = to
        if to == None:
            dest = self.output

        if isinstance(dest, str):
            dest = open(dest, "w")

        return dest

    def __send_response_to_dest(self, response_data, to):
        """Send XML response data to a destination according to "to"."""

        if hasattr(to, _SET_METHOD):
            to.set(response_data.root)
        else:
            self.__get_send_dest(to).write(str(response_data))

    def __send_response(self, response_data, to):
        """Send XML response data to "to"."""

        try:
            self.__send_response_to_dest(response_data, to)
        except:
            self.exception("Send fail")
            sys.exit(SEND_ERROR)

    def __send_response_with_result(self, reqres_data, to, result):
        """Send XML response data of which all results are "result" to "to"."""

        try:
            if isinstance(reqres_data, request.RequestData):
                response_data = request.ResponseData(reqres_data)
            else:
                response_data = reqres_data

            for entry in response_data.get_entry_list():
                entry.set_result(result)

            self.__send_response_to_dest(response_data, to)
        except:
            self.exception("Send fail - result " + result + " for all entry")
            sys.exit(SEND_ERROR)

    def __default_invalid_type_handler(self, entry):
        """Default handler for the invalid type of entry."""

        self.error("Invalid request type: %s!!" % (entry.get_type(),))
        entry.set_result(self.results.INVALID_TYPE)
        return entry

    def __get_log_handler(self, log):
        """Return log handler to "log"."""

        if log == None:
            log = sys.stderr

        if isinstance(log, logging.Handler):
            handler = log
        elif isinstance(log, str):
            handler = RotatingFileHandler(log, "a",
                        self.LOG_MAX_SIZE, self.LOG_COUNT)
        else:
            handler = logging.StreamHandler(log)

        handler.setFormatter(logging.Formatter(self.LOG_FORMAT))
        return handler

    def __load_option(self):
        """Load setting from option."""

        if self.option == None:
            return

        if self.option.opts.input:
            self.input = self.option.opts.input
        if self.option.opts.output:
            self.output = self.option.opts.output
        self.debug_on = self.option.opts.debug
        self.dry_run = self.option.opts.dry_run
        if self.debug_on:
            self.log_level = logging.DEBUG

    def __setup_log(self, logger_name, log, log_level):
        """Setup logger for logging."""

        if self.option != None:
            if self.option.opts.log_level != logging.NOTSET:
                log_level = self.option.opts.log_level
            if self.option.opts.log_file:
                log = self.option.opts.log_file

        if log_level != None:
            self.set_log_level(log_level)

        if logger_name != None:
            self.logger = logging.getLogger(logger_name)

            if logger_name in _log_map:
                if log in _log_map[logger_name]:
                    self.set_log_level(self.log_level)
                    return
            else:
                _log_map[logger_name] = []

            _log_map[logger_name].append(log)
            self.logger.addHandler(self.__get_log_handler(log))
            self.set_log_level(self.log_level)

    def __default_add_info_to_message(self, message):
        """Add default(caller) information to message."""

        stack = inspect.stack()
        message += " : %s(%d)" % (os.path.basename(stack[2][1]), stack[2][2])
        del stack
        return message

    def __init__(self, results, option=None, logger_name=None, log=None,
                log_level=None):
        """Constructor."""

        self.results = results
        self.input = sys.stdin
        self.output = sys.stdout
        self.debug_on = False
        self.dry_run = False
        self.logger = None
        self.log_level = logging.WARNING
        self.option = option
        self.handlers = {}
        self.invalid_type_handler = self.__default_invalid_type_handler
        self.add_info_to_message = self.__default_add_info_to_message
        self.extra = {self.CMDNAME_KEY: os.path.basename(sys.argv[0])}
        self.saved_fd = None

        self.__load_option()
        self.__setup_log(logger_name, log, log_level)

    def debug(self, message, *args):
        """Log "message" for level DEBUG."""

        if self.logger != None:
            self.logger.debug(self.add_info_to_message(message),
                                extra=self.extra, *args)

    def info(self, message, *args):
        """Log "message" for level INFO."""

        if self.logger != None:
            self.logger.info(self.add_info_to_message(message),
                                extra=self.extra, *args)

    def warning(self, message, *args):
        """Log "message" for level WARNING."""

        if self.logger != None:
            self.logger.warning(self.add_info_to_message(message),
                                extra=self.extra, *args)

    def error(self, message, *args):
        """Log "message" for level ERROR."""

        if self.logger != None:
            self.logger.error(self.add_info_to_message(message),
                                extra=self.extra, *args)

    def critical(self, message, *args):
        """Log "message" for level CRITICAL."""

        if self.logger != None:
            self.logger.critical(self.add_info_to_message(message),
                                extra=self.extra, *args)

    def exception(self, message, *args):
        """Log "message" for exception."""

        if self.logger != None:
            self.logger.error(self.add_info_to_message(message),
                                    extra=self.extra, exc_info=True, *args)

    def debug_exception(self, message, *args):
        """Log "message" for level DEBUG on exception."""

        if self.logger != None:
            self.logger.debug(self.add_info_to_message(message),
                                    extra=self.extra, exc_info=True, *args)

    def set_log_level(self, log_level):
        """Set log level about logger and log handler."""

        self.log_level = log_level
        if log_level <= logging.DEBUG:
            self.debug_on = True
        else:
            self.debug_on = False

        if self.logger != None:
            self.logger.setLevel(log_level)
            for handler in self.logger.handlers:
                handler.setLevel(log_level)

    def send_entry(self, entry, target, preserve_result=True,
            preserve_file=True):
        """Pass "entry" through "target" and return result "Entry" instance."""

        if self.dry_run:
            self.info("send_entry to %s - dry run", str(target))
            response_entry = entry.get_clone()
            response_entry.set_result(self.results.OK)
        else:
            response_entry = request.Request(target).request(entry,
                        dry_run=self.dry_run, debug=self.debug_on).get_entry()

            if response_entry.get_result() != self.results.OK:
                self.warning("Request to " + str(target) +
                            " - Result:" + response_entry.get_result() +
                            " - Entry:" +
                            str(response_entry)[0:self.DEBUG_LOG_XML_LEN])
        return response_entry.get_clone(preserve_result, preserve_file)

    def send_entry_with_file(self, entry, target, file_name,
            preserve_result=True, preserve_file=False):
        """Pass "entry" of which file attribute is "file" through "target"
           and return result "Entry" instance.
        """

        entry.set_file(file_name)
        return self.send_entry(entry, target, preserve_result, preserve_file)

    def send_entrylist(self, entrylist, target, preserve_result=True,
            preserve_file=True):
        """Pass "entrylist" through "target" and return result "EntryList"
           instance.
        """

        if self.dry_run:
            self.info("send_entrylist to %s - dry run", str(target.target))
            response_entrylist = request.EntryList()
            for entry in entrylist.get_entry_list():
                response_entry = entry.get_clone()
                response_entry.set_result(self.results.OK)
                response_entrylist.append_entry(response_entry)
        else:
            response_data = request.Request(target).request(entrylist,
                                    dry_run=self.dry_run, debug=self.debug_on)
            response_entrylist = response_data.get_entrylist()

        result_entrylist = request.EntryList()
        for entry in response_entrylist.get_entry_list():
            result_entrylist.append_entry(
                            entry.get_clone(preserve_result, preserve_file))

        return result_entrylist

    def set_handler(self, type, handler):
        """set handler for "type" request."""

        self.handlers[type] = handler

    def pre_process(self, request_data):
        """Method to processing something before handling all "entry".
           This method must return "RequestData" instance for handling later.
        """

        self.debug("pre_process:" +
                str(request_data.get_entry())[0:self.DEBUG_LOG_XML_LEN])
        return request_data

    def post_process(self, response_data):
        """Method to processing something after handling all "entry".
           This method must return "ResponseData" instance for being sent.
        """

        self.debug("post_process:" +
                str(response_data.get_entry())[0:self.DEBUG_LOG_XML_LEN])
        return response_data

    def handle_request(self, _from=None, to=None):
        """Receive request from "_from" or input file by option,
           handle it and send response to "to" or output file by option."""

        request_data = self.__receive_request(_from)
        request_data = self.__pre_process(request_data, to)

        # Force change output from stdout to stderr for avoiding
        # non-XML data outputted to stdout
        self.__stdout_to_null()
        response_data = self.__handle_request(request_data)
        response_data = self.__post_process(response_data, to)
        self.__restore_stdout()
        self.__send_response(response_data, to)


class NasBgCmd(NasCmd):
    """Base Class for NAS command executed in the backgourd."""

    def __daemon(self, request_data, to):
        """Daemonize the current program."""

        pid = os.fork()
        if pid < 0:
            self._NasCmd__send_response_with_result(request_data, to,
                                                self.results.FORK_ERROR)
            sys.exit(NO_ERROR)

        if pid > 0:
            self._NasCmd__send_response_with_result(request_data, to,
                                                self.results.OK)
            sys.exit(NO_ERROR)

        os.setsid()
        pid = os.fork()
        # Ignore "fork" error at this time.
        if pid > 0:
            sys.exit(NO_ERROR)

        # Redirect stdin, stdout and stderr to null device.
        null_fd = os.open(DEV_NULL, os.O_RDWR)
        for fd in (0, 1, 2):
            os.close(fd)
            os.dup2(null_fd, fd)

    def __init__(self, results, option=None, logger_name=None, log=None,
                log_level=None):
        """Constructor."""

        NasCmd.__init__(self, results, option, logger_name, log, log_level)

    def handle_request(self, _from=None, to=None):
        """Receive request from "_from" or input file by option,
           handle it and send response to "to" or output file by option."""

        request_data = self._NasCmd__receive_request(_from)
        request_data = self._NasCmd__pre_process(request_data, to)

        self.__daemon(request_data, to)

        response_data = self._NasCmd__handle_request(request_data)
        response_data = self._NasCmd__post_process(response_data, to)
