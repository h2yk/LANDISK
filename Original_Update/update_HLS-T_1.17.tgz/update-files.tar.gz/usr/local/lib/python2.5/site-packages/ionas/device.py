# -*- mode: landisk-python; coding: utf-8; -*-
# vim:ts=4 sw=4 sts=4 ai si et sta

"""Device module.

Define classes and functions for devices.
"""


from __future__ import with_statement

import os
import re
import glob
import stat
import errno

HDD_DEV_RE = "(.*d[0-9]+)"
HDD_DEV_SUFFIX_RE = "p([0-9]+)"
HDD_PART_DEV_RE = HDD_DEV_RE + HDD_DEV_SUFFIX_RE
PART_MARK = "p"

PART_DEV_GLOB_TMPL = os.path.join("%s", "%sp*")
PART_GLOB_SUFFIX = "p*"
ANY_GLOB = "*"

DEV_FILE_MODE = 0660 | stat.S_IFBLK


class DevMgr:
    """Class for managing devices."""

    def _prepare_save_dir(self):
        """Prepare the directories for saving the device information."""

        for dir in (self.save_link_dir, self.save_dev_dir):
            if dir and not os.path.exists(dir):
                try:
                    os.makedirs(dir)
                except OSError, ins:
                    if ins.errno != errno.EEXIST:
                        raise

    def _get_dev_path_list(self, dev_name, for_all):
        """Return a list of device path related to "dev_name"."""

        if not for_all:
            return [os.path.join(self.dev_dir, dev_name)]

        base_dev_name = self.get_base_dev_name(dev_name)
        if not base_dev_name in self.hdd_dev_list:
            return [os.path.join(self.dev_dir, dev_name)]

        return [os.path.join(self.dev_dir, base_dev_name)] + \
                glob.glob(PART_DEV_GLOB_TMPL % (self.dev_dir, base_dev_name))

    def _create_dev_link(self, dev_name, kdev_name):
        """Create the link file "kdev_name" to "dev_path"."""

        link_file = os.path.join(self.save_link_dir, kdev_name)
        if os.path.islink(link_file) or os.path.exists(link_file):
            os.remove(link_file)
        os.symlink(dev_name, os.path.join(self.save_link_dir, kdev_name))

    def _create_dev_file(self, kdev_name):
        """Create the device file "kdev_name"."""

        dev_file = os.path.join(self.save_dev_dir, kdev_name)
        if os.path.exists(dev_file):
            os.remove(dev_file)
        os.mknod(dev_file, DEV_FILE_MODE,
                os.stat(os.path.join(self.dev_dir, kdev_name)).st_rdev)

    def _save_dev_info(self, dev_path):
        """save the device infomation for "dev_path"."""

        try:
            dev_name = os.path.basename(dev_path)
            kdev_name = os.path.basename(os.readlink(dev_path))
        except:
            return

        if self.save_link_dir:
            self._create_dev_link(dev_name, kdev_name)

            if self.save_dev_dir:
                self._create_dev_file(kdev_name)

    def _is_same_dev(self, dev_name, check_dev):
        """Check if the "dev_name" is same device."""

        if (self.get_base_dev_name(dev_name) ==
                self.get_base_dev_name(check_dev)):

            return True
        return False

    def _get_dev_link_list(self, dev_name, only_not_exists, for_all):
        """Return a list of saved link file related to "dev_name"."""

        if not self.save_link_dir:
            return []

        dev_link_list = []
        dev_link_grob = os.path.join(self.save_link_dir, ANY_GLOB)
        for dev_link in glob.glob(dev_link_grob):
            try:
                link_dest = os.path.basename(os.readlink(dev_link))
            except:
                continue

            if dev_name != link_dest:
                if not for_all or not self._is_same_dev(dev_name, link_dest):
                    continue

            if only_not_exists and \
                    os.path.islink(os.path.join(self.dev_dir, link_dest)):
                continue

            dev_link_list.append(dev_link)

        return dev_link_list

    def _delete_dev_info(self, dev_link):
        """Delete the saved device_infomation."""

        os.remove(dev_link)
        if not self.save_dev_dir:
            return

        dev_file = os.path.join(self.save_dev_dir, os.path.basename(dev_link))
        if os.path.exists(dev_file):
            os.remove(dev_file)

    def _get_saved_kdev_path(self, dev_name):
        """Return the saved kernel device file path corresponding to "dev_name"
           "self.name" or device name of partition "part_no".
        """

        if not self.save_link_dir or not self.save_dev_dir:
            return ""

        dev_link_list = self._get_dev_link_list(dev_name, False, False)

        if len(dev_link_list) <= 0:
            return ""

        for dev_link in dev_link_list:
            kdev_name = os.path.basename(dev_link)
            kdev_path = os.path.join(self.save_dev_dir, kdev_name)
            if not os.path.exists(kdev_path):
                continue

            if (len(dev_link_list) == 1 or
                    not os.path.exists(os.path.join(self.dev_dir, kdev_name))):

                return kdev_path

        # Something wrong if coming here.
        return ""

    def _get_saved_dev_name(self, kdev_name, only_exists):
        """Return the device name which linked by saved kernel device file
           "kdev_name".
        """

        link_file = os.path.join(self.save_link_dir, kdev_name)
        if not os.path.islink(link_file):
            return ""

        if (only_exists and
                not os.path.exists(os.path.join(self.dev_dir, kdev_name))):
            return ""

        return os.path.basename(os.readlink(link_file))

    def __init__(self, dev_dir, save_link_dir="", save_dev_dir="",
            hdd_dev_list=""):
        """Constructor."""

        self.dev_dir = dev_dir
        self.save_link_dir = save_link_dir
        self.save_dev_dir = save_dev_dir
        self.hdd_dev_list = hdd_dev_list

    def save_dev_info(self, dev_name, for_all=True):
        """Save the current device information for "dev_name".
           If "for_all" is True then all informations are saved for the same
           physical devices. (i.e. satad1, satad1p1, satad1p2, ...)
        """

        self._prepare_save_dir()

        for dev_path in self._get_dev_path_list(dev_name, for_all):
            self._save_dev_info(dev_path)

    def delete_dev_info(self, dev_name, only_not_exists=False, for_all=True):
        """Delete the saved device information for "dev_name".
           If "for_all" is True then all informations are deleted for
           the same physical devices. (i.e. satad1, satad1p1, satad1p2, ...)
        """

        for dev_link in \
                self._get_dev_link_list(dev_name, only_not_exists, for_all):

            self._delete_dev_info(dev_link)

    def get_base_dev_name(self, dev_name):
        """Return the device base device name for "dev_name".
           (e.g. "satad1" for "satad1p1")
           If "dev_name" is not HDD device, then "dev_name" is returned.
        """

        if dev_name in self.hdd_dev_list:
            return dev_name

        match = re.match(HDD_PART_DEV_RE, dev_name)
        if match != None:
            if match.group(1) in self.hdd_dev_list:
                return match.group(1)

        return dev_name

    def get_kdev_path(self, dev_name, only_exists=False):
        """Return the kernel device path corresponding to "dev_name"."""

        if not only_exists:
            kdev_path = self._get_saved_kdev_path(dev_name)
            if kdev_path:
                return kdev_path

        dev_path = os.path.join(self.dev_dir, dev_name)
        try:
            kdev_path = os.path.join(self.dev_dir,
                            os.path.basename(os.readlink(dev_path)))
            if os.path.exists(kdev_path):
                return kdev_path
        except:
            pass

        return ""

    def get_kdev_name(self, dev_name, only_exists=False):
        """Return the kernel device name corresponding to "dev_name"."""

        return os.path.basename(self.get_kdev_path(dev_name, only_exists))

    def get_dev_name(self, kdev_name, only_exists=False):
        """Return the device name corresponding to "kdev_name"."""

        dev_link_list = []
        if self.save_link_dir:
            dev_name = self._get_saved_dev_name(kdev_name, only_exists)
            if dev_name:
                return dev_name

        for dev in dev_link_list + \
                    glob.glob(os.path.join(self.dev_dir, ANY_GLOB)):
            if not os.path.islink(dev):
                continue

            if os.path.basename(os.readlink(dev)) == kdev_name:
                if (only_exists and
                        not os.path.exists(os.path.join(self.dev_dir,
                                        kdev_name))):
                    continue
                return os.path.basename(dev)

        return ""
